<!DOCTYPE html>
<html dir="ltr" lang="en">

  <head>
    <title>Instructions - Rubinius</title>
  	<meta charset="UTF-8">
  	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <meta content='en' http-equiv='content-language'>
    <meta content='Rubinius is an implementation of the Ruby programming language. The Rubinius bytecode virtual machine is written in C++. The bytecode compiler is written in pure Ruby. The vast majority of the core library is also written in Ruby, with some supporting primitives that interact with the VM directly.' name='description'>
    <link href='/' rel='home'>
    <link href='/' rel='start'>
    <link href='/doc/en/virtual-machine' rel='prev' title='Virtual Machine'>
    <link href='/doc/en/virtual-machine/custom-dispatch-logic'         rel='next' title='Custom Dispatch Logic'>
    
    <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script><![endif]-->
    <script src="/javascripts/jquery-1.3.2.js"></script>
    <script src="/javascripts/paging_keys.js"></script>
    
    <script src="/javascripts/application.js"></script>
    <style>article, aside, dialog, figure, footer, header, hgroup, menu, nav, section { display: block; }</style>

    <link href="/stylesheets/blueprint/screen.css" media="screen" rel="stylesheet" />
    <link href="/stylesheets/application.css"      media="screen" rel="stylesheet" />
    <link href="/stylesheets/blueprint/print.css"  media="print"  rel="stylesheet" />
    <!--[if IE]><link href="/stylesheets/blueprint/ie.css" media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <!--[if IE]><link href="/stylesheets/ie.css"           media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <link href="/stylesheets/pygments.css" media="screen" rel="stylesheet" />

    <link href="/favicon.ico"                 rel="shortcut icon"    type="image/vnd.microsoft.icon" />
    <link href="/images/apple-touch-icon.png" rel="apple-touch-icon" type="image/png" />
    <link href="/images/apple-touch-icon.png" rel="apple-touch-icon" type="image/png" sizes="72x72"   />
    <link href="/images/apple-touch-icon.png" rel="apple-touch-icon" type="image/png" sizes="114x114" />
  </head>

  <body>
    <div class='container'>
  <div class='span-21 doc_menu'>
    <header>
      <nav>
  <ul>
    <li><a href="/">Home</a></li>
    <li><a id="blog" href="/blog">Blog</a></li>
    <li><a id="documentation" href="/doc/en">Documentation</a></li>
    <li><a href="/projects">Projects</a></li>
    <li><a href="/roadmap">Roadmap</a></li>
    <li><a href="/releases">Releases</a></li>
  </ul>
</nav>

    </header>
  </div>
  <div class='span-3 last'>
  <div id='version'>
    <a href="/releases/1.2.4">1.2.4</a>
  </div>
</div>

</div>


<div class="container languages">
  <nav>
  <span class="label">Languages:</span>
  <ul>
    
    
    
    <li><a href="/doc/fr/virtual-machine/instructions/"
      
      >de</a></li>
    
    
    
    <li><a href="/doc/fr/virtual-machine/instructions/"
      
      class="current"
      
      >en</a></li>
    
    
    
    <li><a href="/doc/fr/virtual-machine/instructions/"
      
      >es</a></li>
    
    
    
    <li><a href="/doc/fr/virtual-machine/instructions/"
      
      >fr</a></li>
    
    
    
    <li><a href="/doc/fr/virtual-machine/instructions/"
      
      >it</a></li>
    
    
    
    <li><a href="/doc/fr/virtual-machine/instructions/"
      
      >ja</a></li>
    
    
    
    <li><a href="/doc/fr/virtual-machine/instructions/"
      
      >pl</a></li>
    
    
    
    <li><a href="/doc/fr/virtual-machine/instructions/"
      
      >pt-br</a></li>
    
    
    
    <li><a href="/doc/fr/virtual-machine/instructions/"
      
      >ru</a></li>
    
  </ul>
  </nav>
</div>


<div class="container doc_page_nav">
  
    
    <span class="label">Previous:</span>
    <a href="/doc/en/virtual-machine">Virtual Machine</a>
    

    <span class="label">Up:</span>
    <a href="/doc/en/">Table of Contents</a>

    
    <span class="label">Next:</span>
    <a href="/doc/en/virtual-machine/custom-dispatch-logic">Custom Dispatch Logic</a>
    
  
</div>


<div class="container documentation">
  <h2>Instructions</h2>

  

  

    <p>The virtual machine instructions are contained in <code>vm/instructions.def</code>. The
documentation below is generated by <code>rakelib/vm.rake</code>.</p>

<h3><a class="instruction" name="noop">noop()</a></h3>

<p>The classic no-op operator. It performs no actions and does not modify the
   stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#pop">pop</a></li>
</ul>
<h3><a class="instruction" name="push_nil">push_nil()</a></h3>

<p>The special object <code>nil</code> is pushed onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>nil</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_true">push_true()</a></h3>

<p>The special value <code>true</code> is pushed onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>true</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_false">push_false()</a></h3>

<p>The special object <code>false</code> is pushed onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>false</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_int">push_int(number)</a></h3>

<p>Pushes the value of the integer literal onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>number</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes">Notes</h4>
<p>Certain common cases (i.e. -1, 0, 1, and 2) are optimised to avoid the
   decoding of the argument.</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#meta_push_0">meta_push_0</a></li>
<li><a href="#meta_push_1">meta_push_1</a></li>
<li><a href="#meta_push_2">meta_push_2</a></li>
<li><a href="#meta_push_neg_1">meta_push_neg_1</a></li>
</ul>
<h3><a class="instruction" name="push_self">push_self()</a></h3>

<p>The current <code>self</code> object is pushed onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>self</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="set_literal">set_literal(literal)</a></h3>

<p>Used to set the value of a literal. The stack top is set to the literal
   indicated by the operand.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-1">Notes</h4>
<p>Unlike other literals such as strings and numbers, creating a Regexp
   literal (i.e. via the /regex/ syntax) is a two step process to create the
   literal slot for the Regexp, create a literal for the string between the
   &lsquo;/&rsquo; delimiters and create a new Regexp object passing it the string.  Only
   then can the literal value be set, using the set_literal opcode.</p>

<h3><a class="instruction" name="push_literal">push_literal(literal)</a></h3>

<p>The value identified by the operand <em>literal</em> in the current state
   literals tuple is retrieved and placed onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>literal</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-2">Notes</h4>
<p>The literals tuple is part of the machine state, and holds all literal
   objects defined or used within a particular scope.</p>

<h3><a class="instruction" name="goto">goto(location)</a></h3>

<p>Unconditionally moves the instruction pointer to the position specified by
   <em>location</em>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-3">Notes</h4>
<p>All goto instructions use absolute addressing. This is absolute movement
   rather than a relative one, so the operand must specify the ip starting
   from 0 to move to.</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#goto_if_true">goto_if_true</a></li>
<li><a href="#goto_if_false">goto_if_false</a></li>
</ul>
<h3><a class="instruction" name="goto_if_false">goto_if_false(location)</a></h3>

<p>Remove the top value on the stack, and if <code>nil</code> or <code>false</code>, set the
   instruction pointer to the value specified by <em>location</em>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#goto">goto</a></li>
<li><a href="#goto_if_true">goto_if_true</a></li>
</ul>
<h3><a class="instruction" name="goto_if_true">goto_if_true(location)</a></h3>

<p>Remove the top value on the stack, and if not <code>nil</code> or <code>false</code>, set the
   instruction pointer to the value specified by <em>location</em>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#goto">goto</a></li>
<li><a href="#goto_if_false">goto_if_false</a></li>
</ul>
<h3><a class="instruction" name="ret">ret()</a></h3>

<p>Return a value to the direct caller</p>

<p>Pops the top value from the stack, and returns to the direct caller of the
   current invocation.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-4">Notes</h4>
<p>In a method, the <code>return</code> keyword uses this instruction. In a block
   though, <code>return</code> uses the raise_return instruction and <code>next</code> uses this
   instruction.</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#raise_return">raise_return</a></li>
<li><a href="#raise_exc">raise_exc</a></li>
</ul>
<h3><a class="instruction" name="swap_stack">swap_stack()</a></h3>

<p>Swaps the top two values on the stack, so that the second value becomes
   the first, and the first value becomes the second.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>s0</td><td>s1</td></tr>
<tr><td>s1</td><td>s0</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="dup_top">dup_top()</a></h3>

<p>Read a value from the top of the stack and push it on the stack again
   without removing the original value.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>s0</td><td>s0</td></tr>
<tr><td>...</td><td>s0</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="dup_many">dup_many(count)</a></h3>

<p>Duplicate multiple values on the stack</p>

<p>Read <em>count</em> values from the stack and push them onto the stack again
   in order without removing the original values.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   value1
</td><td>   value1
</td></tr>
<tr><td>   value2
</td><td>   value2
</td></tr>
<tr><td>   ...
</td><td>   value1
</td></tr>
<tr><td /><td>   value2
</td></tr>
<tr><td /><td>   ...
</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="pop">pop()</a></h3>

<p>Removes the top value from the stack, discarding it.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>

<h4 id="notes-5">Notes</h4>
<p>Pop is typically used when the return value of another opcode is not
   required.</p>

<h3><a class="instruction" name="pop_many">pop_many(count)</a></h3>

<p>Removes <em>count</em> values from the stack and discard them.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   value1
</td><td>   ...
</td></tr>
<tr><td>   value2
</td><td /></tr>
<tr><td>   ...
</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="rotate">rotate(count)</a></h3>

<p>Reverses the order on the stack of the top <em>count</em> values.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   obj1
</td><td>   obj3
</td></tr>
<tr><td>   obj2
</td><td>   obj2
</td></tr>
<tr><td>   obj3
</td><td>   obj1
</td></tr>
<tr><td>   ...
</td><td>   ...
</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="move_down">move_down(positions)</a></h3>

<p>The top value on the stack is moved down by the specified number of
   <em>positions</em>, with all values above that position shuffling up by one.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   obj1
</td><td>   obj2
</td></tr>
<tr><td>   obj2
</td><td>   ...
</td></tr>
<tr><td>   ...
</td><td>   objn
</td></tr>
<tr><td>   objn
</td><td>   obj1
</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="set_local">set_local(local)</a></h3>

<p>Read the top of the stack and set the local variable identified by operand
   <em>local</em> to it. The stack is not modified by this instruction.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#push_local">push_local</a></li>
</ul>
<h3><a class="instruction" name="push_local">push_local(local)</a></h3>

<p>Retrieves the current value of the local variable referenced by operand
   <em>local</em> and push it onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#set_local">set_local</a></li>
</ul>
<h3><a class="instruction" name="push_local_depth">push_local_depth(depth, index)</a></h3>

<p>Pushes the value of a local from an enclosing scope onto the stack</p>

<p>Retrieves the value of a local variable. Operand <em>depth</em> indicates how many
   upward enclosing scopes to walk up and then operand <em>index</em> indicates which
   local in that context to read. The value is then pushed on the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="example">Example</h4>
<pre><code> k = 0
 foo.each do |i|
   bar.each do |j|
     # i is a local variable from enclosing scope at depth 1
     # k is a local variable from enclosing scope at depth 2
     i = i + j + k
   end
 end
</code></pre>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#set_local_depth">set_local_depth</a></li>
</ul>
<h3><a class="instruction" name="set_local_depth">set_local_depth(depth, index)</a></h3>

<p>Updates the value of a local variable contained in an enclosing scope</p>

<p>Read a value from the top of the stack and use it to update a local
   variable in an enclosing scope. The <em>depth</em> and <em>index</em> operands
   identify the specific local the same as in <code>push_local_depth</code>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="example-1">Example</h4>
<pre><code> foo.each do |i|
   bar.each do |j|
     i = i + j  # i is a local variable from enclosing scope at depth 1
   end
 end
</code></pre>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#push_local_depth">push_local_depth</a></li>
</ul>
<h3><a class="instruction" name="passed_arg">passed_arg(index)</a></h3>

<p>Checks if the argument specified by the operand <em>index</em> was passed to
   the current invocation. If so, push true, otherwise false.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>boolean</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-6">Notes</h4>
<p>Arguments are specified via a zero-index, so the first argument is 0.</p>

<h3><a class="instruction" name="push_current_exception">push_current_exception()</a></h3>

<p>Pushes the current exception onto the stack, so that it can be used for
   some purpose, such as checking the exception type, setting an exception
   variable in a rescue clause, etc.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>exception</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="example-2">Example</h4>
<pre><code> begin
   foo = BAR        # BAR is not defined
 rescue NameError   # push_exception used to check type of exception (via ===)
   puts "No BAR"
 end
</code></pre>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#raise_exc">raise_exc</a></li>
</ul>
<h3><a class="instruction" name="clear_exception">clear_exception()</a></h3>

<p>Clears any exceptions from the current thread.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_exception_state">push_exception_state()</a></h3>

<p>Package up the current exception state into an object and push it. This
   is used to preserve the exception state around code that might mutate it.
   For instance, when handling an ensure while an exception is being raised</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>exc_state</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="restore_exception_state">restore_exception_state()</a></h3>

<p>Pops a value off the stack and set the threads exception state from it.
   This instruction is only to be used with a value pushed on the stack
   by the push_exception_state instruction.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>exception</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#push_exception_state">push_exception_state</a></li>
</ul>
<h3><a class="instruction" name="raise_exc">raise_exc()</a></h3>

<p>Raises an exception</p>

<p>Pops a value off the stack and make it the current exception.
   If the value is not an instance of Exception, a TypeError is raised.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="setup_unwind">setup_unwind(ip, type)</a></h3>

<p>Register an unwind handler</p>

<p>Registers what to happen when an exception wants to unwind through the
   current invocation. Operand <em>ip</em> specifies where to set the instruction
   pointer if used. Operand <em>type</em> is either 0 for if the value should be
   used in rescue style (not run when unwinding because of a return caused by
   <code>raise_return</code>) or 1 for ensure style (always used). The registrations are
   nested within the current invocation and are automatically removed from
   the registry when they are used. The <code>pop_unwind</code> instruction can be used
   to remove an unused registration.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-7">Notes</h4>
<p>The registration also contains the value of the stack depth when
   created. If the registration is used, then the stack depth is
   restored to the value contained in the registration</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#pop_unwind">pop_unwind</a></li>
</ul>
<h3><a class="instruction" name="pop_unwind">pop_unwind()</a></h3>

<p>Remove the next unused unwind registration from the current invocation.
   This instruction is paired with <code>setup_unwind</code> to remove registrations
   when control exits a section of code that registered a handler but didn&rsquo;t
   use it. For example, exiting a begin that had a rescue expression.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#setup_unwind">setup_unwind</a></li>
</ul>
<h3><a class="instruction" name="raise_return">raise_return()</a></h3>

<p>Cause the toplevel enclosing scope to return</p>

<p>Only used in a block, pop a value from the stack and raise a special
   internal exception and begin unwinding the stack. The toplevel method
   scope will rescue the exception and return the value.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#ret">ret</a></li>
</ul>
<h3><a class="instruction" name="ensure_return">ensure_return()</a></h3>

<p>Return from a scope but run ensures first</p>

<p>A one use instruction, used only in a method toplevel within a begin
   that has an ensure. Use the same internal exception as <code>raise_return</code>
   which will coax the ensure registration to run.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#ret">ret</a></li>
<li><a href="#raise_return">raise_return</a></li>
</ul>
<h3><a class="instruction" name="raise_break">raise_break()</a></h3>

<p>Cause the method that yielded the current block to return. Used to
   implement the <code>break</code> keyword in a block.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="reraise">reraise()</a></h3>

<p>Continue unwinding the stack with the current exception. Verify that there
   is a current exception, then begin the unwinding process again.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="make_array">make_array(count)</a></h3>

<p>Create an array and populate with values on the stack</p>

<p>Creates a new array, populating its contents by remove the number of
   values specified by operand <em>count</em> and putting them into the array in the
   order they were on the stack. The resulting array is pushed onto the
   stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   valueN
</td><td>   [value1, value2, ..., valueN]
</td></tr>
<tr><td>   ...
</td><td>   ...
</td></tr>
<tr><td>   value2
</td><td /></tr>
<tr><td>   value1
</td><td /></tr>
<tr><td>   ...
</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="cast_array">cast_array()</a></h3>

<p>Removes the object on the top of the stack, and:</p>

<ol>
  <li>If the input is a tuple, a new array object is created based on the
tuple data.</li>
  <li>If the input is an array, it is unmodified.</li>
  <li>If in 1.9 mode and the input is nil, an empty Array is returned</li>
</ol>

<p>If the input is any other type, call <code>Rubinius::Type.coerce_to_array(value)</code>.
   If the return value of the method call is an <code>Array</code>, make it the result.
   Otherwise make the result an 1 element <code>Array</code> contain the original value.</p>

<p>The resulting array is then pushed back onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>array</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="shift_array">shift_array()</a></h3>

<p>Pops an array off the top of the stack. If the array is empty, it is
   pushed back onto the stack, followed by <code>nil</code>.</p>

<p>Otherwise, the array is shifted, then pushed back onto the stack,
   followed by the object that was shifted from the front of the array.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   [value1, value2, ..., valueN]
</td><td>   value1
</td></tr>
<tr><td>   ...
</td><td>   [value2, ..., valueN]
</td></tr>
<tr><td /><td>   ...
</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="set_ivar">set_ivar(index)</a></h3>

<p>Pops a value off the stack, and uses it to set the value of the instance
   variable identifies by the literal specified by operand <em>index</em>.  The
   value popped off the stack is then pushed back on again.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_ivar">push_ivar(index)</a></h3>

<p>Pushes the instance variable identified by <em>index</em> onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_const">push_const(literal)</a></h3>

<p>Locates the constant indicated by the operand <em>literal</em> from the current
   context, and pushes it onto the stack. If the constant cannot be found in
   the current context, nothing is pushed onto the stack, and a NameError
   exception is raised.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>constant</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="example-3">Example</h4>
<pre><code> engine = RUBY_ENGINE # RUBY_ENGINE is a constant defined by Rubinius
</code></pre>

<h3><a class="instruction" name="set_const">set_const(index)</a></h3>

<p>Pops an object off the stack, and uses value to set a constant named
   by the literal <em>index</em>. The value is pushed back onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="set_const_at">set_const_at(index)</a></h3>

<p>Pop a value from the literals table specified by the operand <em>index</em> and
   use it as the value of a constant named inside a Module object popped from
   the stack.  The <em>value</em> is pushed back on the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   value
</td><td>   value
</td></tr>
<tr><td>   module
</td><td>   ...
</td></tr>
<tr><td>   ...
</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="find_const">find_const(index)</a></h3>

<p>Pops <em>module</em> off the stack, and searches within its namespace for the
   constant named by the literal specified by the operand <em>index</em>. If found,
   it is pushed onto the stack; otherwise, nothing is pushed onto the stack,
   and a <code>NameError</code> exception is raised.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>module</td><td>constant</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="example-4">Example</h4>
<pre><code> str = "abc"
 enum = Enumerable::Enumerator(str, :each_byte)
</code></pre>

<h3><a class="instruction" name="push_cpath_top">push_cpath_top()</a></h3>

<p>Pushes the top-level global object that represents the top-level namespace
   for constants. Used to find constants relative to the toplevel. In Ruby,
   this is the class <code>Object</code>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>constant</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_const_fast">push_const_fast(literal, association)</a></h3>

<p>Pushes a constant onto the stack. Caches the lookup to provide faster
   future lookup. This instruction is normally emitted only by the Generator.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>constant</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="example-5">Example</h4>
<pre><code> engine = RUBY_ENGINE # RUBY_ENGINE is a constant defined by Rubinius
</code></pre>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#push_const">push_const</a></li>
</ul>
<h3><a class="instruction" name="set_call_flags">set_call_flags(flags)</a></h3>

<p>The call flags on the current execution context are set to the opcode
   argument <em>flags</em>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-8">Notes</h4>
<p>Currently this only has one use, which is that send_stack_with_splat
   checks if flags is set to CALL_FLAG_CONCAT which indicates that
   the splat represents arguments at the beginning rather than the end.</p>

<h3><a class="instruction" name="allow_private">allow_private()</a></h3>

<p>Indicate that the next send is allowed to see <code>private</code> methods.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="send_method">send_method(literal)</a></h3>

<p>Pops a <em>receiver</em> object off the top of the stack and sends it the
   message specified by the operand <em>literal</em> with zero arguments.</p>

<p>When the method returns, the return value is pushed on the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>receiver</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-9">Notes</h4>
<p>This form of send is for methods that take no arguments.</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#send_stack">send_stack</a></li>
</ul>
<h3><a class="instruction" name="send_stack">send_stack(literal, count)</a></h3>

<p>Sends a message with arguments on the stack</p>

<p>Pops the <em>receiver</em> of the message off the stack and sends the message
   specified by the operand <em>literal</em> with <em>count</em> arguments. The arguments
   are removed from the stack also.</p>

<p>When the method returns, the return value is pushed on the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   argN
</td><td>   value
</td></tr>
<tr><td>   ...
</td><td>   ...
</td></tr>
<tr><td>   arg2
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
<tr><td>   receiver
</td><td /></tr>
</tbody>
</table>

<h4 id="notes-10">Notes</h4>
<p>This opcode does not pass a block to the receiver; see
   <code>send_stack_with_block</code> for the equivalent op code used when a block is to
   be passed.</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#send_stack_with_block">send_stack_with_block</a></li>
</ul>
<h3><a class="instruction" name="send_stack_with_block">send_stack_with_block(literal, count)</a></h3>

<p>Sends a message with arguments and a block on the stack</p>

<p>Pops the <em>receiver</em> of the message off the stack and sends the message
   specified by the operand <em>literal</em> with <em>count</em> arguments. The arguments
   are removed from the stack also. A value that represents the block to pass
   on is popped off the stack after the normal arguments.</p>

<p>When the method returns, the return value will be on top of the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   block
</td><td>   retval
</td></tr>
<tr><td>   argN
</td><td>   ...
</td></tr>
<tr><td>   ...
</td><td /></tr>
<tr><td>   arg2
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
<tr><td>   receiver
</td><td /></tr>
</tbody>
</table>

<h4 id="notes-11">Notes</h4>
<p>This opcode passes a block to the receiver; see <code>send_stack</code> for the
   equivalent op code used when no block is to be passed.</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#send_stack">send_stack</a></li>
</ul>
<h3><a class="instruction" name="send_stack_with_splat">send_stack_with_splat(literal, count)</a></h3>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>block</td><td>value</td></tr>
<tr><td>array</td><td>...</td></tr>
<tr><td>receiver</td><td /></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="send_super_stack_with_block">send_super_stack_with_block(literal, count)</a></h3>

<p>Call a method on the superclass with a block</p>

<p>The same as <code>send_stack_with_block</code>, but receiver is the current self
   instead of being read from the stack, and the method to call is looked up
   starting with the receiver superclass.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   block
</td><td>   retval
</td></tr>
<tr><td>   argN
</td><td>   ...
</td></tr>
<tr><td>   ...
</td><td /></tr>
<tr><td>   arg2
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="send_super_stack_with_splat">send_super_stack_with_splat(literal, count)</a></h3>

<p>Call a method on the superclass, passing args plus a block.</p>

<p>The same as <code>send_stack_with_block</code>, but receiver is the current <code>self</code>
   instead of being read from the stack, and the method to call is looked up
   starting with the receiver superclass.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   block
</td><td>   retval
</td></tr>
<tr><td>   argN
</td><td>   ...
</td></tr>
<tr><td>   ...
</td><td /></tr>
<tr><td>   arg2
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_block">push_block()</a></h3>

<p>Pushes the current block onto the stack. The value is not wrapped in a
   <code>Proc</code> if it is a <code>BlockEnvironment</code>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>block</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#push_proc">push_proc</a></li>
</ul>
<h3><a class="instruction" name="passed_blockarg">passed_blockarg(count)</a></h3>

<p>Check if exactly <em>count</em> arguments were passed to the current invocation.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>boolean</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-12">Notes</h4>
<p><em>This instruction is deprecated and no longer used.</em></p>

<h3><a class="instruction" name="create_block">create_block(literal)</a></h3>

<p>Read a CompiledCode specified by the operand +literal+ and create a
   <code>BlockEnvironment</code>.  Push the new <code>BlockEnvironment</code> object on the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>block</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="cast_for_single_block_arg">cast_for_single_block_arg()</a></h3>

<p>Converts the value on the top of the stack into an argument for a block
   taking one argument.</p>

<p>The value on the top of the stack is popped, and:</p>

<p>If it has no fields, the result is <code>nil</code>.</p>

<p>If the value contains a single field, the result is the value in the
   first field.</p>

<p>Otherwise, package up all the arguments in an <code>Array</code> as the result.</p>

<p>The result is then pushed onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>argument</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-13">Notes</h4>
<p>This is a single use instruction, only used to simplify how to handle a
   block that accepts one argument.</p>

<h3><a class="instruction" name="cast_for_multi_block_arg">cast_for_multi_block_arg()</a></h3>

<p>Converts a block argument single-valued tuple into multiple arguments if
   the arg is an array.</p>

<p>If the Proc invoked from was in lambda mode, and one argument is passed:
     * and it&rsquo;s an Array, push it.
     * and it responds to <code>#to_ary</code>, try and convert it and push it.
     * otherwise wrap it in a one element Array and push it.</p>

<p>Otherwise:
     Package up the arguments into an <code>Array</code> and push it onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   value1
</td><td>   array[value1,..] | value1
</td></tr>
<tr><td>   value2
</td><td>   ...
</td></tr>
<tr><td>   ...
</td><td /></tr>
</tbody>
</table>

<h4 id="example-6">Example</h4>
<pre><code> [[1,2,3]].each do |i,j,k|
   # do something
 end
</code></pre>

<h4 id="notes-14">Notes</h4>
<p>This is a single use instruction, only used to simplify how to handle a
   block that accepts 2 or more arguments. The semantics for this instruction
   change depending on if the current block invocation is from a Proc with
   lambda semantics or not.</p>

<h3><a class="instruction" name="cast_for_splat_block_arg">cast_for_splat_block_arg()</a></h3>

<p>Take all arguments passed to the current invocation and package
   them into an <code>Array</code>, which is then pushed on the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>arguments</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="yield_stack">yield_stack(count)</a></h3>

<p>Invoke the current block, passing <em>count</em> arguments to it.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   argN
</td><td>   value
</td></tr>
<tr><td>   ...
</td><td>   ...
</td></tr>
<tr><td>   arg2
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
<tr><td>   ...
</td><td /></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#send_stack">send_stack</a></li>
</ul>
<h3><a class="instruction" name="yield_splat">yield_splat(count)</a></h3>

<p>Invoke the current block, passing <em>count</em> arguments to it in
   addition to the values in the <code>Array</code> <em>array</em>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   array
</td><td>   value
</td></tr>
<tr><td>   argN
</td><td>   ...
</td></tr>
<tr><td>   ...
</td><td /></tr>
<tr><td>   arg2
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
<tr><td>   ...
</td><td /></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#send_stack_with_splat">send_stack_with_splat</a></li>
</ul>
<h3><a class="instruction" name="string_append">string_append()</a></h3>

<p>Pops two strings off the stack, appends the second to the first, and
   then pushes the combined string back onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>prefix</td><td>string</td></tr>
<tr><td>suffix</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>

<h4 id="notes-15">Notes</h4>
<p>The original string is modified by the append.</p>

<h3><a class="instruction" name="string_build">string_build(count)</a></h3>

<p>Build a new string using many substrings</p>

<p>Remove <em>count</em> elements from the stack and interpret each as a <code>String</code>.
   Build a new string which is all the removed elements concatenated together in
   the order they were on the stack.</p>

<p>Push the resulting string.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   stringN
</td><td>   string1string2..stringN
</td></tr>
<tr><td>   ...
</td><td>   ...
</td></tr>
<tr><td>   string2
</td><td /></tr>
<tr><td>   string1
</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="string_dup">string_dup()</a></h3>

<p>Consume the string on the stack, replacing it with a duplicate. Mutating
   operations on the original string will not affect the duplicate, and
   vice-versa.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>string</td><td>string</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_scope">push_scope()</a></h3>

<p>Pushes the current <code>ConstantScope</code> object on the stack. Many operations are
   defered to the current scope. This operation retrieves the current scope
   so methods can be called on it.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>scope</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="add_scope">add_scope()</a></h3>

<p>Create a new <code>ConstantScope</code> object for the given Module on the stack.
   This scope is chained off the current scope of the method.</p>

<p>This also sets the scope of the current <code>CompiledCode</code> to the new
   <code>ConstantScope</code>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>module</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_variables">push_variables()</a></h3>

<p>Push the <code>VariableScope</code> for the current method/block invocation on the
   stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>scope</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="check_interrupts">check_interrupts()</a></h3>

<p>Perform required occasional checks that must be done.  This instruction is
   used by loops to allow them to be interrupted externally, and thus also
   cause the current method to heat up.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="yield_debugger">yield_debugger()</a></h3>

<p>Pauses virtual machine execution and yields control to the debugger on the
   debug channel. If no debugger is registered, an error is raised.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-16">Notes</h4>
<p><em>This instruction is deprecated and should not be used.</em></p>

<h3><a class="instruction" name="is_nil">is_nil()</a></h3>

<p>Pop the <em>value</em> from the stack, and push <code>true</code> or <code>false</code> depending on
   whether the consumed value was the special value <code>nil</code>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>boolean</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="check_serial">check_serial(literal, serial)</a></h3>

<p>Checks if the specified method serial number matches an expected value.</p>

<p>Pops the <em>receiver</em> object from the stack and checks if it responds to the
   message specified by the operand <em>literal</em> and the target method has
   serial number <em>serial</em>. If so, push <code>true</code>, else push <code>false</code>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>receiver</td><td>boolean</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-17">Notes</h4>
<p>This opcode is typically used to determine at runtime whether an
   optimisation can be performed. At compile time, two code paths are
   generated: a slow, but guaranteed correct path, and a fast path that uses
   certain optimisations. The serial number check is then performed at
   runtime to determine which code path is executed.</p>

<p>For example, a method such as <code>Fixnum#times</code> can be optimised at compile
   time, but we can&rsquo;t know until runtime whether or not the <code>Fixnum#times</code>
   method has been overridden. The serial number check is used to determine
   each time the code is executed, whether or not the standard <code>Fixnum#times</code>
   has been overridden. It leverages the serial number field on a
   <code>CompiledCode</code>, is initialised to either 0 (for kernel land methods) or
   1 (for user land methods).</p>

<h3><a class="instruction" name="check_serial_private">check_serial_private(literal, serial)</a></h3>

<p>Checks if the specified method&rsquo;s serial number matches an expected value.
   Considers <code>private</code> methods too.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>receiver</td><td>boolean</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#check_serial">check_serial</a></li>
</ul>
<h3><a class="instruction" name="push_my_field">push_my_field(index)</a></h3>

<p>Pushes the value of the specified field in the current object onto the
   stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-18">Notes</h4>
<p>Fields are similar to instance variables, but have dedicated storage
   allocated. They are primarily used on core or bootstrap classes.
   This instruction should not be used directly. The VM will specialize
   push_ivar instructions into this.</p>

<h3><a class="instruction" name="store_my_field">store_my_field(index)</a></h3>

<p>Stores the value at the top of the stack into the field specified by
   <em>index</em> on <code>self</code>.</p>

<p>The stack is left unmodified.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-19">Notes</h4>
<p>This instruction should not be used directly. The VM will specialize
   push_ivar instructions into this.</p>

<h3><a class="instruction" name="kind_of">kind_of()</a></h3>

<p>Evaluate if <em>object</em> is an instance of <em>class</em> or of an ancestor of
   <em>class</em>. If so, push <code>true</code>, else push <code>false</code>.</p>

<p>The equivalent of <code>object.kind_of?(klass)</code> in Ruby.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>object</td><td>boolean</td></tr>
<tr><td>class</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#instance_of">instance_of</a></li>
</ul>
<h3><a class="instruction" name="instance_of">instance_of()</a></h3>

<p>Evaluate if <em>object</em> is an instance of <em>class</em>. If so, push <code>true</code>, else
   push <code>false</code>.</p>

<p>The equivalent of <code>object.instance_of?(klass)</code> in Ruby.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>object</td><td>boolean</td></tr>
<tr><td>class</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#kind_of">kind_of</a></li>
</ul>
<h3><a class="instruction" name="meta_push_neg_1">meta_push_neg_1()</a></h3>

<p>Push <code>-1</code> (negative 1) onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-20">Notes</h4>
<p>This is an optimisation applied by the compiler.</p>

<h3><a class="instruction" name="meta_push_0">meta_push_0()</a></h3>

<p>Push <code>0</code> (zero) onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-21">Notes</h4>
<p>This is an optimisation applied by the compiler.</p>

<h3><a class="instruction" name="meta_push_1">meta_push_1()</a></h3>

<p>Push <code>1</code> (one) onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-22">Notes</h4>
<p>This is an optimisation applied by the compiler.</p>

<h3><a class="instruction" name="meta_push_2">meta_push_2()</a></h3>

<p>Push <code>2</code> (two) onto the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-23">Notes</h4>
<p>This is an optimisation applied by the compiler.</p>

<h3><a class="instruction" name="meta_send_op_plus">meta_send_op_plus(literal)</a></h3>

<p>Implementation of <code>#+</code> optimised for <code>Fixnum</code>.</p>

<p>Pops <em>value1</em> and <em>value2</em> off the stack, and pushes the <em>sum</em> (<em>value1</em>
   <code>+</code> <em>value2</em>).  If both values are Fixnums, the addition is done directly
   via the <code>fixnum_add</code> primitive. Otherwise, the <code>#+</code> method is called on
   <em>value1</em>, passing <em>value2</em> as the argument.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value1</td><td>sum</td></tr>
<tr><td>value2</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="meta_send_op_minus">meta_send_op_minus(literal)</a></h3>

<p>Implementation of <code>#-</code> optimised for <code>Fixnum</code>.</p>

<p>Pops <em>value1</em> and <em>value2</em> off the stack, and pushes the <em>difference</em> (<em>value1</em>
   <code>-</code> <em>value2</em>).  If both values are Fixnums, the subtraction is done directly
   via the <code>fixnum_sub</code> primitive. Otherwise, the <code>#-</code> method is called on
   <em>value1</em>, passing <em>value2</em> as the argument.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value1</td><td>difference</td></tr>
<tr><td>value2</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="meta_send_op_equal">meta_send_op_equal(literal)</a></h3>

<p>Implementation of <code>#==</code> optimised for <code>Fixnum</code> and <code>Symbol</code>.</p>

<p>Pops <em>value1</em> and <em>value2</em> off the stack and pushes the logical result
   of (<em>value1</em> <code>==</code> <em>value2</em>). If <em>value1</em> and <em>value2</em> are both Fixnums or
   both Symbols, the comparison is done directly. Otherwise, the <code>#==</code> method
   is called on <em>value1</em>, passing <em>value2</em> as the argument.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value1</td><td>boolean</td></tr>
<tr><td>value2</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="meta_send_op_lt">meta_send_op_lt(literal)</a></h3>

<p>Implementation of <code>#&lt;</code> optimised for <code>Fixnum</code>.</p>

<p>Pops <em>value1</em> and <em>value2</em> off the stack, and pushes the logical result
   of (<em>value1</em> <code>&lt;</code> <em>value2</em>). If <em>value1</em> and <em>value2</em> are both Fixnums, the
   comparison is done directly. Otherwise, the <code>#&lt;</code> method is called on
   <em>value1</em>, passing <em>value2</em> as the argument.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value1</td><td>boolean</td></tr>
<tr><td>value2</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="meta_send_op_gt">meta_send_op_gt(literal)</a></h3>

<p>Implementation of <code>#&gt;</code> optimised for <code>Fixnum</code>.</p>

<p>Pops <em>value1</em> and <em>value2</em> off the stack, and pushes the logical result
   of (<em>value1</em> <code>&gt;</code> <em>value2</em>). If <em>value1</em> and <em>value2</em> are both Fixnums, the
   comparison is done directly. Otherwise, the <code>#&gt;</code> method is called on
   <em>value1</em>, passing <em>value2</em> as the argument.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value1</td><td>boolean</td></tr>
<tr><td>value2</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="meta_send_op_tequal">meta_send_op_tequal(literal)</a></h3>

<p>Implementation of <code>#===</code> (triple equal) optimised for <code>Fixnum</code> and
   <code>Symbol</code>.</p>

<p>Pops <em>value1</em> and <em>value2</em> off the stack, and pushes the logical result
   of (<em>value1</em> <code>===</code> <em>value2</em>). If <em>value1</em> and <em>value2</em> are both Fixnums or
   both Symbols, the comparison is done directly. Otherwise, the <code>#===</code> method
   is called on <em>value1</em>, passing <em>value2</em> as the argument.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value1</td><td>boolean</td></tr>
<tr><td>value2</td><td>...</td></tr>
<tr><td>...</td><td /></tr>
</tbody>
</table>

<h4 id="notes-24">Notes</h4>
<p>Exactly like equal, except calls <code>#===</code> if it can&rsquo;t handle it directly.</p>

<h3><a class="instruction" name="meta_send_call">meta_send_call(literal, count)</a></h3>

<p>Simplified call instruction used for non-dynamic <code>yield</code> calls and for
   simple calls with static arguments.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   argN
</td><td>   retval
</td></tr>
<tr><td>   ...
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
<tr><td>   receiver
</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_my_offset">push_my_offset(index)</a></h3>

<p>Pushes a value read directly from within the body of an object.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>offset</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-25">Notes</h4>
<p>This instruction must never be used directly. The VM will specialize
   <code>push_my_field</code> instructions into this.</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#push_my_field">push_my_field</a></li>
</ul>
<h3><a class="instruction" name="zsuper">zsuper(literal)</a></h3>

<p>Call a superclass method on the current, passing the arguments
   passed to the current invocation.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   argN
</td><td>   value
</td></tr>
<tr><td>   ...
</td><td>   ...
</td></tr>
<tr><td>   arg2
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
<tr><td>   ...
</td><td /></tr>
</tbody>
</table>

<h4 id="notes-26">Notes</h4>
<p>This is a specialization of <code>send_super_with_stack</code> that is necessary for
   Ruby semantics regarding how to read the original arguments.</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#send_super_with_stack">send_super_with_stack</a></li>
</ul>
<h3><a class="instruction" name="push_block_arg">push_block_arg()</a></h3>

<p>Push the block passed as an argument to the current invocation.
   This differs from <code>push_block</code> in that in is not the block for the
   current scope because of how the current block is seen within
   an existing block.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>block</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#push_block">push_block</a></li>
</ul>
<h3><a class="instruction" name="push_undef">push_undef()</a></h3>

<p>Push the special undefined value on the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_stack_local">push_stack_local(which)</a></h3>

<p>Push the stack local identified by operand <em>which</em>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-27">Notes</h4>
<p>Stack locals differ from normal locals in that they are not viewable by
   closures.</p>

<h3><a class="instruction" name="set_stack_local">set_stack_local(which)</a></h3>

<p>Set the stack local identified by operand <em>which</em> using the value on the
   top of the stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-28">Notes</h4>
<p>Stack locals differ from normal locals in that they are not viewable by
   closures.</p>

<h3><a class="instruction" name="push_has_block">push_has_block()</a></h3>

<p>Push <code>true</code> or <code>false</code> based on whether there is a current block.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-29">Notes</h4>
<p>Used to implement <code>block_given?</code> without having to directly expose
   the block object itself. This simplifies JIT inlining.</p>

<h3><a class="instruction" name="push_proc">push_proc()</a></h3>

<p>Wrap the current block in a <code>Proc</code> and push it onto the stack.  If there
   is no current block, push <code>nil</code>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>value</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-30">Notes</h4>
<p>Used to implement <code>&amp;block</code> in a method signature.</p>

<h4>See Also</h4>
<ul class="insn_cross_ref">
<li><a href="#push_block">push_block</a></li>
</ul>
<h3><a class="instruction" name="check_frozen">check_frozen()</a></h3>

<p>Check if the value on the top of the stack is frozen.  If so, raise a
   <code>TypeError</code> indicating so.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>value</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-31">Notes</h4>
<p>An optimization to deal with check for frozen.</p>

<h3><a class="instruction" name="cast_multi_value">cast_multi_value()</a></h3>

<p>Convert a value into an Array</p>

<p>Pop <em>value</em>. If it is an <code>Array</code>, push it back on the stack.  Otherwise,
   attempt to convert it to an <code>Array</code> using <code>#to_ary</code> and push the result.
   If the value can not be converted to an array, it is wrapped in a one
   element <code>Array</code>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>value</td><td>array</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="invoke_primitive">invoke_primitive(literal, count)</a></h3>

<p>Directly invoke a primitive by name.</p>

<p>Pop <em>count</em> values off the stack and pass them directly to the primitive
   operation named by the operand <em>literal</em>.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   argN
</td><td>   value
</td></tr>
<tr><td>   ...
</td><td>   ...
</td></tr>
<tr><td>   arg2
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="push_rubinius">push_rubinius()</a></h3>

<p>Pushes the top-level global <code>Rubinius</code> constant onto the stack.  Generally
   this is done to call a utility method.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>constant</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>
<h3><a class="instruction" name="call_custom">call_custom(literal, count)</a></h3>

<p>Invoke a method via the call custom protocol.</p>

<p>Pop the <em>receiver</em> and <em>count</em> values off the stack and begin the call
   custom invocation protocol with them as arguments.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>   argN
</td><td>   value
</td></tr>
<tr><td>   ...
</td><td>   ...
</td></tr>
<tr><td>   arg2
</td><td /></tr>
<tr><td>   arg1
</td><td /></tr>
<tr><td>   receiver
</td><td /></tr>
</tbody>
</table>
<h3><a class="instruction" name="meta_to_s">meta_to_s(literal)</a></h3>

<p>Pop a value off the stack and if it&rsquo;s not a <code>String</code>, call a method
   indicated by <em>literal</em> on it.  Push the resulting object back on the
   stack.</p>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>object</td><td>string</td></tr>
<tr><td>...</td><td>...</td></tr>
</tbody>
</table>

<h4 id="notes-32">Notes</h4>
<p>Normally literal is <code>:to_s</code>, but this instruction leaves it up to the user
   to indicate for flexibility.</p>

<h3><a class="instruction" name="push_type">push_type()</a></h3>

<table class="stack_effect">
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td>...</td><td>constant</td></tr>
<tr><td /><td>...</td></tr>
</tbody>
</table>



</div>

<div class="container doc_page_nav">
  
    
    <span class="label">Previous:</span>
    <a href="/doc/en/virtual-machine">Virtual Machine</a>
    

    <span class="label">Up:</span>
    <a href="/doc/en/">Table of Contents</a>

    
    <span class="label">Next:</span>
    <a href="/doc/en/virtual-machine/custom-dispatch-logic">Custom Dispatch Logic</a>
    
  
</div>


<div class="container">
  <div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname  = 'rubinius';
  var disqus_identifier = '/doc/fr/virtual-machine/instructions/';
  var disqus_url = 'http://rubini.us/doc/fr/virtual-machine/instructions/';

  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</div>

<footer>
  <div class='container'>
    <nav>
      <ul>
        <li><a rel="external" href="http://twitter.com/rubinius">Follow Rubinius on Twitter</a></li>
        <li><a rel="external" href="http://github.com/rubinius/rubinius">Fork Rubinius on github</a></li>
        <li><a rel="external" href="http://engineyard.com">An Engine Yard project</a></li>
      </ul>
    </nav>
  </div>
</footer>

<script>
  var _gaq=[['_setAccount','UA-12328521-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>


  </body>
</html>
