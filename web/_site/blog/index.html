<!DOCTYPE html>
<html>
  <head>
    <title>Rubinius : Use Ruby&#8482;</title>
    <meta content='text/html;charset=utf-8' http-equiv='content-type'>
    <meta content='en' http-equiv='content-language'>
    <meta content='Rubinius is an implementation of the Ruby programming language. The Rubinius bytecode virtual machine is written in C++. The bytecode compiler is written in pure Ruby. The vast majority of the core library is also written in Ruby, with some supporting primitives that interact with the VM directly.' name='description'>
    <meta content='Less Than Three. &lt;3. http://less.thanthree.com' name='author'>
    <link href='/' rel='home'>
    <link href='/' rel='start'>
    
    
    <link href='/feed/atom.xml' rel='alternate' type='application/atom+xml' title='Rubinius Blog' />
    <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script><![endif]-->
    <script src="/javascripts/jquery-1.3.2.js" type="text/javascript"></script>
    <script src="/javascripts/paging_keys.js" type="text/javascript"></script>
    
    <script src="/javascripts/application.js" type="text/javascript"></script>
    <style>article, aside, dialog, figure, footer, header, hgroup, menu, nav, section { display: block; }</style>

    <link href="/stylesheets/blueprint/screen.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/application.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/blueprint/print.css" media="print" rel="stylesheet" type="text/css" />
    <!--[if IE]><link href="/stylesheets/blueprint/ie.css" media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <!--[if IE]><link href="/stylesheets/ie.css" media="screen" rel="stylesheet" type="text/css" /><![endif]-->
    <link href="/stylesheets/pygments.css" media="screen" rel="stylesheet" type="text/css" />
  </head>
    <body>
        <div class='container'>
      <div class='span-21 blog_menu'>
        <header>
                    <nav>
            <ul>
              <li><a href="/">Home</a></li>
              <li><a id="blog" href="/blog/">Blog</a></li>
              <li><a id="documentation" href="/doc/en/">Documentation</a></li>
              <li><a href="/projects/">Projects</a></li>
              <li><a href="/roadmap/">Roadmap</a></li>
              <li><a href="/releases/">Releases</a></li>
            </ul>
          </nav>

        </header>
      </div>
            <div class='span-3 last'>
        <div id='version'>
          <a href="/releases/1.2.3">1.2.3</a>
        </div>
      </div>

    </div>

            <div class="container posts_nav">
      <nav>
        <a href="/blog/posts_index/">Index of Posts</a>
        <a id="feed_icon" href="/feed/atom.xml"><img alt="subscribe" src="/images/feed-icon16x16.png" /></a>
      </nav>
    </div>


  <div class="container blog_posts">
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/05/26/rubinius-rewards/" title="Announcing Rubinius Rewards" class="post_title">
        Announcing Rubinius Rewards
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Shane Becker</span>
          <span class="date">26 May 2011</span>
          
                      <a href="http://rubini.us/2011/05/26/rubinius-rewards/#disqus_thread"
            data-disqus-identifier="/2011/05/26/rubinius-rewards/"></a>

          
        </p>
      </div>

      <h2 id="tldr">tl;dr</h2>

<p>Email <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#099;&#111;&#109;&#109;&#117;&#110;&#105;&#116;&#121;&#064;&#114;&#117;&#098;&#105;&#110;&#105;&#046;&#117;&#115;">&#099;&#111;&#109;&#109;&#117;&#110;&#105;&#116;&#121;&#064;&#114;&#117;&#098;&#105;&#110;&#105;&#046;&#117;&#115;</a> to get stickers and
t-shirts. Include your mailing address.</p>

<h2 id="we-made-t-shirts-and-stickers">We Made T-Shirts and Stickers</h2>

<p>We heard you like stickers and t-shirts, so we made some. They
debuted at <a href="http://en.oreilly.com/rails2011" title="RailsConf 2011 - O'Reilly Conferences, May 16 - 19, 2011, Baltimore, MD!">RailsConf 2011 in Baltimore, MD</a>.
Then we gave almost all of them away in just a few hours. They went like
hotcakes. It turns out that there was a lot of pent up demand for Rubinius
swag.</p>

<p>Not everyone could be at RailsConf to get the goods, of course. Even some
people who were there didn&rsquo;t get their shirts/stickers. If you didn&rsquo;t get one
and want one, we&rsquo;re very sorry, but don&rsquo;t you worry. We&rsquo;ve got you covered.</p>

<h2 id="general-availability-stickers">General Availability Stickers</h2>

<p><a href="http://www.flickr.com/photos/veganstraightedge/5742057726"><img src="http://farm3.static.flickr.com/2458/5742057726_48c42d5462_z.jpg" alt="A box of Rubinius stickers" title="A box of Rubinius stickers by veganstraightedge, on Flickr" /></a></p>

<p>We&rsquo;ve got a box of stickers in three designs:
<a href="http://asset.rubini.us/web/images/blog/rubinius_square_sticker.png">square</a>,
<a href="http://asset.rubini.us/web/images/blog/rubinius_bumper_sticker.png">bumper</a>
and
<a href="http://asset.rubini.us/web/images/blog/rubinius_diecut_sticker.png">die-cut</a>.</p>

<p><a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#099;&#111;&#109;&#109;&#117;&#110;&#105;&#116;&#121;&#064;&#114;&#117;&#098;&#105;&#110;&#105;&#046;&#117;&#115;">&#069;&#109;&#097;&#105;&#108;&#032;&#117;&#115;</a> and tell us which one you want.</p>

<h2 id="general-availability-t-shirt">General Availability T-Shirt</h2>

<p>We&rsquo;re printing 500 more grey Rubinius t-shirts in the two different designs
and in a a handful of sizes (women&rsquo;s small and medium, unisex small &ndash;
xx-large).</p>

<p><a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#099;&#111;&#109;&#109;&#117;&#110;&#105;&#116;&#121;&#064;&#114;&#117;&#098;&#105;&#110;&#105;&#046;&#117;&#115;">&#069;&#109;&#097;&#105;&#108;&#032;&#117;&#115;</a> and tell us which design / size you want:
<a href="http://asset.rubini.us/web/images/blog/rubinius_use_ruby_square_shirt.jpg">square</a>
or
<a href="http://asset.rubini.us/web/images/blog/rubinius_use_ruby_horizontal_shirt.jpg">horizontal</a>
in
women&rsquo;s small, women&rsquo;s medium, unisex small, unisex medium, unisex large,
unisex x-large or unisex xx-large.</p>

<p><a href="http://www.flickr.com/photos/veganstraightedge/5709097384"><img src="http://farm4.static.flickr.com/3469/5709097384_0bde99e1d3_z.jpg" alt="Rubinius &quot;Use Ruby&trade;&quot; T-Shirts at the Farmhouse in Hollywood, CA" title="Rubinius &quot;Use Ruby&trade;&quot; T-Shirts at the Farmhouse in Hollywood, CA, on Flickr" /></a></p>

<p>Photo by <a href="http://flickr.com/tjnelsonjunior" title="Flickr: tjnelsonjunior's Photostream">Tj Nelson Jr</a>
<a href="http://twitter.com/tjnelsonjr" title="@tjnelsonjr">@tjnelsonjr</a></p>

<h2 id="first-commit-sticker">First Commit Sticker</h2>

<p>Going forward, we want to reward everyone who makes a contribution to
Rubinius. As a very small token of our gratitude, we&rsquo;re mailing a Rubinius
sticker (and a handwritten thank you note from one of us) to everyone after
their first commit. So, if you&rsquo;ve ever thought about dipping your toe into
Rubinius (or diving headlong into the deep end), now&rsquo;s the best time ever.
Help us make Rubinius better (in big and small ways) and we&rsquo;ll send you stuff.</p>

<h2 id="tenth-commit-shirt">Tenth Commit Shirt</h2>

<p>We want you to stick around and keep helping Rubinius to get better and better.
If you make 10 commits to Rubinius, we&rsquo;ll send you a special shirt only
available to committers. That design is still a secret for now, but it&rsquo;s just
for 10+ committers.</p>

<p><em>Please, don&rsquo;t try to game the system by intentionally breaking stuff up into
smaller commits just to bump up your count. Let&rsquo;s keep it honest.</em></p>

<h2 id="quarterly-committer-merit-badge-stickers">Quarterly Committer Merit Badge Stickers</h2>

<p>In addition to getting a generally available sticker after your first commit,
at the end of each calendar quarter (every three months) we&rsquo;re sending a
sticker to everyone who committed to Rubinius <strong>during</strong> that quarter.</p>

<p>E.g. after July 1, 2011, we&rsquo;ll print and ship a sticker to everyone who
committed between April 1 and June 30. Each quarter&rsquo;s sticker has the year /
quarter in the corner. Keep committing every quarter and you&rsquo;ll keep
collecting the merit badge stickers.</p>

<h2 id="one-more-thing-mdash-im-committed-sticker">One More Thing &mdash; I&rsquo;m Committed* Sticker</h2>

<p>Rubinius is obviously older than the new Rubinius Rewards program. To backfill
for all the contributions people have made over the years up until, we have a
<em>super duper limited edition never to be made again</em> sticker&hellip; the asterisk.</p>

<p><a href="http://www.flickr.com/photos/veganstraightedge/5742135762"><img src="http://farm4.static.flickr.com/3187/5742135762_521146bdf9_z.jpg" alt="Rubinius stickers on my laptop" title="The new @Rubinius stickers on my @EngineYard laptop, on Flickr" /></a></p>

<h2 id="get-in-touch">Get in Touch</h2>

<p>If you&rsquo;re a past committer, <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#099;&#111;&#109;&#109;&#117;&#110;&#105;&#116;&#121;&#064;&#114;&#117;&#098;&#105;&#110;&#105;&#046;&#117;&#115;">&#101;&#109;&#097;&#105;&#108;&#032;&#117;&#115;</a> your
mailing address get your special merit sticker. If you&rsquo;re a new committer,
we&rsquo;ll try to take note and reach out to you. If you don&rsquo;t hear from us,
don&rsquo;t be afraid to contact us with your mailing address.</p>

<h3 id="up-next">Up Next&hellip;</h3>

<p>Rubinius International Outposts.</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/05/22/adam-prescott-on-scopes/" title="Adam Prescott on Scopes in Rubinius" class="post_title">
        Adam Prescott on Scopes in Rubinius
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Shane Becker</span>
          <span class="date">22 May 2011</span>
          
                      <a href="http://rubini.us/2011/05/22/adam-prescott-on-scopes/#disqus_thread"
            data-disqus-identifier="/2011/05/22/adam-prescott-on-scopes/"></a>

          
        </p>
      </div>

      <p><cite class="vcard"><a class="url fn" href="http://aprescott.com" title="Adam Prescott">Adam Prescott</a></cite> wrote a lengthy article about <i>variables, closures and scope</i> in Ruby, <a href="http://aprescott.com/posts/variables-closures-and-scope" title="Posts / Variables, closures &amp; scope &mdash; Adam Prescott">mentioning Rubinius at the end</a>:</p>

<blockquote cite="http://aprescott.com/posts/variables-closures-and-scope">
  <p> One of the really cool things about the <a href="http://en.wikipedia.org/wiki/Rubinius">Rubinius</a> implementation of Ruby is that it exposes, by requirement, a level of internals which you can&rsquo;t find in <abbr title="Matz' Ruby Interpreter">MRI</abbr>, including some internals with scopes. Because these internals are exposed in Ruby itself, you can <a href="http://yehudakatz.com/2011/02/18/getting-comfortable-with-rubinius-pure-ruby-internals/">play around with scopes as objects</a>, using <code>VariableScope</code>, including getting access to the available local variables within that scope, with <code>VariableScope.current.locals</code>. </p>
</blockquote>

<p>How are <strong>you</strong> using Rubinius? What are you doing with it that you couldn&rsquo;t do before? What is it missing for you to really dive in? Let us know. We&rsquo;re listening.</p>

<ul>
  <li><a href="community@rubini.us">community@rubini.us</a></li>
  <li><a href="http://twitter.com/rubinius" title="@rubinius on twitter">@rubinius</a></li>
</ul>

<p>&mdash; Use Ruby&trade;</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/04/29/rubinius-t-shirts-and-stickers/" title="Rubinius T-Shirts and Stickers" class="post_title">
        Rubinius T-Shirts and Stickers
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Shane Becker</span>
          <span class="date">29 April 2011</span>
          
                      <a href="http://rubini.us/2011/04/29/rubinius-t-shirts-and-stickers/#disqus_thread"
            data-disqus-identifier="/2011/04/29/rubinius-t-shirts-and-stickers/"></a>

          
        </p>
      </div>

      <h3 id="allow-myself-to-introduce-myself">Allow Myself to Introduce Myself</h3>

<p>Hi. I&rsquo;m Shane (<a href="http://twitter.com/veganstraightedge">@veganstraightedge</a>
/ <a href="http://iamshane.com">iamshane.com</a>). I&rsquo;ll be helping out around here now.
I was recently hired by <a href="http://engineyard.com">Engine Yard</a> to be their Open
Source Cheerleader. (Yes, there will be costumes at some point.) My
primary focus is <strong>Rubinius! Rubinius! Rubinius!</strong></p>

<p>I have lots of big plans for helping get Rubinius used by more people
in more places and how to have a better conversation with people who are using
it. For now though, I tell you about just the first thing that I&rsquo;ve done.</p>

<h3 id="t-shirts">T-Shirts</h3>

<h4 id="the-first-ever-rubinius-t-shirt-from-railsconf-2007">The First Ever Rubinius T-Shirt from RailsConf 2007</h4>
<p><img src="http://asset.rubini.us/web/images/blog/rubinius_sword_shirt.jpg" alt="The First Ever Rubinius T-Shirt from RailsConf 2007" /></p>

<p>A long time ago (2007) in a city far, far away (Seattle, WA), Evan and I made
the first batch of Rubinius t-shirts. There were about two dozen made and
given to the handful of contributors at the time. This was at RailsConf in
Portland, OR. Since then there hasn&rsquo;t been <em>anything</em> made with the Rubinius
logo on it.</p>

<p>Now is the time to rectify that. We&rsquo;ve made two different t-shirts. Same
messaging, slightly different design orientation. Both are the same colors:
white on asphalt. They are available in an assortment of sizes from women&rsquo;s
small to unisex xx-large.</p>

<h4 id="use-ruby-rubinius-t-shirts-from-railsconf-2011">Use Ruby™ Rubinius T-Shirts from RailsConf 2011</h4>
<p><img src="http://asset.rubini.us/web/images/blog/rubinius_use_ruby_square_shirt.jpg" alt="Use Ruby™ Square Ruby T-Shirt from RailsConf 2011" /></p>

<p><img src="http://asset.rubini.us/web/images/blog/rubinius_use_ruby_horizontal_shirt.jpg" alt="Use Ruby™ Horizontal Ruby T-Shirt from RailsConf 2011" /></p>

<p>If you&rsquo;re going to RailsConf 2011 in Baltimore, MD, stop by the Engine Yard booth
to pick up a free Rubinius t-shirt. After RailsConf we&rsquo;ll have ways to get one
from us directly.</p>

<h3 id="stickers">Stickers</h3>

<p>To go along with the t-shirts, we&rsquo;re making a whole grip of Rubinius stickers.
Most of which will also be available for free from the Engine Yard booth at
RailsConf in Baltimore. Again, after RailsConf you&rsquo;ll be able to get them
directly from us. More on that later. Here&rsquo;s what we have in store.</p>

<h4 id="wide-screen-7in-x-375in">Wide Screen (7in x 3.75in)</h4>

<p><img src="http://asset.rubini.us/web/images/blog/rubinius_bumper_sticker.png" alt="Rubinius : Use Ruby bumper sticker" /></p>

<h4 id="square-logo">Square Logo</h4>

<p><img src="http://asset.rubini.us/web/images/blog/rubinius_square_sticker.png" alt="Rubinius : Use Ruby square sticker" /></p>

<h4 id="die-cut-r-logo">Die-Cut R Logo</h4>

<p><img src="http://asset.rubini.us/web/images/blog/rubinius_diecut_sticker.png" alt="Rubinius : r logo diecut sticker" /></p>

<h4 id="im-committed-merit-sticker">I&rsquo;m Committed Merit Sticker</h4>

<p>This one you have to earn. At the end of each quarter, we&rsquo;ll send out a little
one inch square sticker with a year/quarter combination in its corner to
everyone who committed something to Rubinius during that calendar quarter. For
all of the incredible folks who&rsquo;ve contributed something (however big or small)
already, you&rsquo;ll get a special sticker. Instead of a date, there&rsquo;s an asterisk.
Only those of you that&rsquo;ve committed so far will get that one.</p>

<p><img src="http://asset.rubini.us/web/images/blog/rubinius_alumni_sticker.png" alt="Rubinius : I'm committed past committers sticker" /></p>

<p>Come find us to get free Rubinius shirts and stickers. And stay tuned to
<a href="http://rubini.us/blog">the Rubinius blog</a> and to the Twitter account :
<a href="http://twitter.com/rubinius">@rubinius</a>. We have lots more in store.</p>

<p>&mdash; Use Ruby&trade;</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/03/17/running-ruby-with-no-ruby/" title="Running Ruby With No Ruby" class="post_title">
        Running Ruby With No Ruby
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Brian Ford</span>
          <span class="date">17 March 2011</span>
          
                      <a href="http://rubini.us/2011/03/17/running-ruby-with-no-ruby/#disqus_thread"
            data-disqus-identifier="/2011/03/17/running-ruby-with-no-ruby/"></a>

          
        </p>
      </div>

      <p>Humans have come a long way since our cave-dwelling days. No, that&rsquo;s not a
metaphor for primitive software. I mean literally since we lived in caves. One
of the big inventions is the lock. There are birds that bury food and will
move it later if they notice they were watched burying it. But they have no
access control. Any bird may come along and dig up the food.</p>

<p>Humans, though, are smarter than the average bird.</p>

<p>We have numerous systems that implement the analog of a lock, namely, some
sort of access control. For every one of these systems, we have other systems
that attempt to circumvent or defeat the access control. Two sides of the
ubiquitous coin of life.</p>

<p>In software, attempts to implement access control typically involve
distinguishing between source code and some form of executable code. Direct
access to the source code is not permitted. Further, the format of the
executable code resists attempts to derive the source code. There are several
reasons for this:</p>

<ol>
  <li><strong>Licenses:</strong> If a vendor licenses individual copies of the software, they
want to prevent unrestricted copying of the software without paying for a
license.</li>
  <li><strong>Intellectual Property:</strong> A vendor may have trade secrets or other
proprietary information that is disclosed by the source code.</li>
  <li><strong>Security:</strong> Full access to the source code may reveal vulnerabilities in
the software or related systems. This is sometimes called <em>Security Through
Obscurity</em> and is generally disparaged, but things are not so black and
white and there may be valid security concerns in the source code.</li>
</ol>

<p>The process that separates the source code from the executable program is
typically a compilation step. However, Ruby code is not typically associated
with any sort of compilation. That&rsquo;s one of the great things about Ruby,
right? There is no <em>edit-compile-link-load</em> cycle to wait on. Just edit and run. But
if there is no compilation step, how do we separate the source code from the
executable code?</p>

<p>You may recall from my <a href="http://rubini.us/2011/03/11/making-rubinius-rbc-files-disappear/">last
post</a> that
Rubinius does compile Ruby code to a bytecode format that the virtual machine
executes. I also promised to explain how you could run the bytecode directly.</p>

<p>But first, let me very clearly state that there are a number of caveats. In
fact, I&rsquo;ve included a whole section on them below. Please read them. We will
assume that you have and that you understand them. If you have any questions,
please ask.</p>

<h3 id="application-distribution-scenario">Application Distribution Scenario</h3>

<p>Let&rsquo;s review what we would like to accomplish. We&rsquo;ll assume affable Abe is a
developer writing an application for customer Cain.</p>

<ol>
  <li>Abe writes some Ruby code.</li>
  <li>Abe compiles the code to a set of files.</li>
  <li>Abe packages the files up into an application with no Ruby source.</li>
  <li>Abe sends the application to Cain.</li>
  <li>Cain installs the application.</li>
  <li>Cain runs the application.</li>
</ol>

<p>In this scenario, I&rsquo;m assuming a very vague definition of application. In
other words, the process below will fit in with a broad spectrum of bundling
and distribution schemes.</p>

<h3 id="application-layout">Application Layout</h3>

<p>Let&rsquo;s assume that you have the following application layout. This mirrors what
you would expect to see in a gem. You could also consider this as a subtree in
your larger project.</p>

<pre><code>widget
|- lib
|- widget.rb
\- widget
   |- red.rb
   |- blue.rb
   \- green.rb
</code></pre>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="c1"># widget.rb</span>
<span class="lineno">2</span> <span class="nb">require</span> <span class="s1">&#39;widget/red&#39;</span>
<span class="lineno">3</span> <span class="nb">require</span> <span class="s1">&#39;widget/blue&#39;</span>
<span class="lineno">4</span> <span class="nb">require</span> <span class="s1">&#39;widget/green&#39;</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="c1"># widget/red.rb</span>
<span class="lineno">2</span> <span class="nb">puts</span> <span class="s2">&quot;I am red&quot;</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="c1"># widget/blue.rb</span>
<span class="lineno">2</span> <span class="nb">puts</span> <span class="s2">&quot;I am blue&quot;</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="ruby"><span class="lineno">1</span> <span class="c1"># widget/green.rb</span>
<span class="lineno">2</span> <span class="nb">puts</span> <span class="s2">&quot;I am green&quot;</span>
</code></pre>
</div>

<h3 id="compiling-ruby-files">Compiling Ruby Files</h3>

<p>The Rubinius bytecode compiler is accessible through a command-line script.
See <code>rbx compile -h</code> for all options. We will only need one simple option in
our case to easily create a separate tree containing one compiled file for
every Ruby source file in our source tree.</p>

<pre><code>rbx compile -s '^widget:widget-compiled' widget/
</code></pre>

<p>Let&rsquo;s dissect this command. The <code>-s</code> option defines a transformation to apply
to every filename. The transformation has the form <code>&lt;source&gt;:&lt;destination&gt;</code>
where <code>&lt;source&gt;</code> can be a Regexp. In our case, we would like to change any
path starting with <code>widget</code> to start with <code>widget-compiled</code>. This way, we
create a separate tree of our compiled files. The final option is the
<code>widget/</code> directory. The <code>rbx compile</code> command will happily compile a single
file or a directory of files. Note that if we did not pass the <code>-s</code> option,
<code>rbx compile</code> would have created the compiled files alongside the source
files.</p>

<p>If we now look at <code>widget-compiled</code>, we should see the following:</p>

<pre><code>widget-compiled
|- lib
|- widget.rbc
\- widget
   |- red.rbc
   |- blue.rbc
   \- green.rbc
</code></pre>

<h3 id="loading-pre-compiled-files">Loading Pre-compiled Files</h3>

<p>Now that we have a separate tree of only compiled files, how do we load them?
Well, first, let&rsquo;s load our source files so we know what to expect. Note that
the technique used in this post should not substitute for a robust test suite.</p>

<pre><code>$ rbx -Iwidget/lib -e "require 'widget/lib/widget'"
I am red
I am blue
I am green
</code></pre>

<p>Ok, that is what I would expect. Now, to load the compiled files:</p>

<pre><code>$ rbx -Iwidget-compiled/lib -e "Rubinius::CodeLoader.require_compiled 'widget/lib/widget'"
I am red
I am blue
I am green
</code></pre>

<p><em>The crowed erupts with applause and hooting</em>.</p>

<p>Golly gee, you guys&hellip; <em>Blush</em></p>

<p>Let&rsquo;s review. Our goal is to take a tree of Ruby source files and create a
tree of compiled files that can be sent to a customer and loaded to perform
exactly as the Ruby source would if loaded directly. The most direct and
simple way to accomplish this is to use the Rubinius compiler command-line
script to compile the tree of Ruby source files to a separate tree. Then, load
the root of that tree with <code>Rubinius::CodeLoader.require_compiled "root"</code>.</p>

<h3 id="caveats">Caveats</h3>

<p>I will admit, I have resisted fiercely against encouraging or even permitting
Rubinius users from using what I showed above in their code. Not because I am
an ogre who is trying to steal your fun, but because there are serious issues
with allowing this. So, please read the following carefully.</p>

<ol>
  <li>We, Rubinius, absolutely reserve the right to change any part of the
underlying compiled file mechanism. Since we are publishing the
<code>Rubinius::CodeLoader.require_compiled(name)</code> method, we will respect that
contract. What it says is, given a name, we will load a representation of
that name. <em>DO NOT assume that <code>"some_file"</code> is actually referencing
<code>"some_file.rbc"</code></em>. We may change the way compiled files are stored and may
change the format of the compiled output.</li>
  <li>We have created this facility to meet a need we had in Rubinius. Since our
compiler is written in Ruby, we have to run Ruby to run the compiler. But
since we need to compile Ruby to run it, we need to compile the compiler.
But since&hellip; To handle this, we build the compiler using a bootstrapping
version of Ruby.  Then we load the pre-compiled compiler files as shown
above. The approach is quite general, as demonstrated. However, a better
approach may be appropriate for a particular application. In that case,
talk to us about how you think it should work and we can point you in a
direction to try implementing what you need.</li>
  <li><strong>We assume no responsibility for any security breaches resulting from your
incorrect assumption that .rbc files provides any meaningful security
mechanism.</strong> I cannot stress this enough. The compiled file mechanism is a
cache. It is a way to avoid recompiling Ruby source code that has not
changed. The compiled format is simple. We reserve the right to provide
disassemblers for our compiled code. We are happy to assist you with
direction for implementing a more secure system for your needs.</li>
  <li>There is no mechanism that is completely safe from cracking when it comes
to software access control. Witness how often Microsoft&rsquo;s products have
their security features defeated. Also witness how often attempts at DRM
are circumvented. The most secure system I have seen uses a special
compiler and a hardware dongle. The compiler takes critical parts of the
application logic and breaks them up so that part of the computation is
performed on the dongle. This is significantly harder to defeat than binary
editing an executable to turn a license key check into a no-op. The folks
you most want to keep from accessing your information are the ones most
capable of doing so. Security and access control are very hard problems.</li>
</ol>

<h3 id="conclusion">Conclusion</h3>

<p>Rubinius compiles Ruby code to bytecode before running it. It is possible to
save the bytecode representation and reload it later. Using this mechanism, it
is possible to avoid providing the Ruby source code and run an application
directly from the compiled bytecode. The mechanism we use to do this was
created to solve our problem of bootstrapping the Rubinius bytecode compiler,
which is written in Ruby. The mechanism is not intended to be used for
security.</p>

<p>It is possible to extend the Rubinius code loading mechanism to support custom
formats for on-disk compiled bytecode and to load those formats. This can be
done entirely in Ruby code. If this interests you, please talk with us about
it.</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/03/11/making-rubinius-rbc-files-disappear/" title="Making Rubinius .rbc Files Disappear" class="post_title">
        Making Rubinius .rbc Files Disappear
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Brian Ford</span>
          <span class="date">11 March 2011</span>
          
                      <a href="http://rubini.us/2011/03/11/making-rubinius-rbc-files-disappear/#disqus_thread"
            data-disqus-identifier="/2011/03/11/making-rubinius-rbc-files-disappear/"></a>

          
        </p>
      </div>

      <p>Rubinius is rather unusual as a Ruby implementation. It both compiles Ruby
source code to bytecode <em>and</em> saves the compiled code to a cache so it does
not need to recompile unless the source code changes. This can be great for
utilities that are run often from the command line (including IRB). Rubinius
merely reloads the cached file and runs the bytecode directly rather than
needing to parse and compile the file. Sounds like a real win!</p>

<p>Unfortunately, it is not that simple. We need some place to store that cache
and this is where the thorns on that pretty rose start poking us in the
thumbs. The solution we have been using since forever is to store the cached
file alongside the source file in the same directory, like so:</p>

<pre><code>$ echo 'puts "hello!"' &gt; hello.rb
$ ls hello.*
hello.rb
$ rbx hello.rb
hello!
$ ls hello.*
hello.rb	hello.rbc
</code></pre>

<p>That doesn&rsquo;t look too crazy, but it can get more complicated:</p>

<pre><code>$ mv hello.rb hello
$ rbx hello
$ ls hello.*
hello.compiled.rbc	hello.rbc
</code></pre>

<p>Whoa, what is <code>hello.compiled.rbc</code>? Since <code>hello</code> did not have an extension,
we add that longer <code>compiled.rbc</code> to make it clear which file the cache is
for. Also, note that we have that <code>hello.rbc</code> hanging about even though the
original <code>hello.rb</code> is gone.</p>

<p>To summarize the issues with our caching scheme:</p>

<ol>
  <li>It requires an additional file for every Ruby source file.</li>
  <li>It requires some potentially complicated naming scheme to associate the
cache file with the source and not clash with other names.</li>
  <li>Removing or renaming the Ruby source file leaves the cache file behind.</li>
</ol>

<p>Again, the advantage of the cache file is that you do not have to wait for
Rubinius to recompile the file if you have not changed the source. Let&rsquo;s see
if we can get all the advantages with none of the disadvantages. That old
saying comes to mind, <em>Having your cake and eating it, too</em>, so we may not
be successful, but it is worth a shot.</p>

<p>First, let&rsquo;s take a step back. This issue is not unique to Rubinius. Python
has <code>.pyc</code> and <code>.pyo</code> files. Java has <code>.class</code> files. C/C++ has <code>.o</code> files.
Lots of things need a place to store a compiled or cached representation of
some data. Every SCM worth mention has some mechanism to ignore the files you
don&rsquo;t want to track. The same is generally true of editors. So in some sense,
this is a solved problem. However, we have always received complaints about
the <code>.rbc</code> files, so we thought we would try to make other, hopefully better,
solutions available.</p>

<h3 id="solution-1-no-cache">Solution 1: No Cache</h3>

<p>One simple solution is just to never ever ever create the compiled cache files
in any form anywhere. We have an option for that:</p>

<pre><code>$ ls hello.*
hello.rb
$ rbx -Xcompiler.no_rbc hello.rb
hello!
$ ls hello.*
hello.rb
</code></pre>

<p>Win! Not one lousy <code>.rbc</code> file in sight. Although, that&rsquo;s quite the option to
type. Never fear, we have a solution to that below.</p>

<p>Here is our scorecard for solution 1:</p>

<p><strong>Use Case:</strong> Use when you never want any compiler cache files created. For
example, on a server where startup time is not really a concern.</p>

<p><strong>Pros:</strong> No <code>.rbc</code> files at all.</p>

<p><strong>Cons:</strong> Startup will be slightly slower depending on what Ruby code you are
running. It will be more noticeable in a Rails application, for example.
However, the Rubinius bytecode compiler is several times faster than it was a
couple years ago so it may not be an issue for you.</p>

<h3 id="solution-2-cache-database">Solution 2: Cache Database</h3>

<p>What if we could put all the compilation data in a single cache location,
something like a database? We have an option for that.</p>

<p>This option is a little more complex, so let&rsquo;s take it in two steps.</p>

<pre><code>$ ls hello.*
hello.rb
$ rbx -Xrbc.db hello.rb
hello!
$ ls hello.*
hello.rb
$ ls -R .rbx
60

.rbx/60:
60c091c3ed34c1b93ffbb33d82d810772902d3f9
</code></pre>

<p>Success! No <code>.rbc</code> files here. But what&rsquo;s with all the numbers in the <code>.rbx</code>
directory and how did that directory get there?</p>

<p>The <code>-Xrbc.db</code> option without any argument will store the compilation cache in
the <code>.rbx</code> directory in the current working directory. The cache files
themselves are split into subdirectories to avoid creating too many entries
for the file system to handle in one directory.</p>

<p>What if you have a special location where you would prefer all compilation
cache files be saved? No problem, just give <code>-Xrbc.db</code> a path as follows:</p>

<pre><code>$ ls hello.*
hello.rb
$ rbx -Xrbc.db=$HOME/.my_special_place hello.rb
hello!
$ ls hello.*
hello.rb
$ ls -R $HOME/.my_special_place
60

/Users/brian/.my_special_place/60:
60c091c3ed34c1b93ffbb33d82d810772902d3f9
</code></pre>

<p>If you primarily work with projects, putting the <code>.rbx</code> directory in the
current working directory may be the best solution because it keeps the
compilation cache with the project. It is easy to add an SCM ignore for the
directory and easy to remove the directory to clear the cache (e.g. in a clean
task).</p>

<p>However, if you are frequently running scripts in many directories, you may
not want to litter <code>.rbx</code> directories everywhere. In this case, putting the
directory in your <code>$HOME</code> dir or <code>/tmp</code> may be preferable. Additionally,
<code>/tmp</code> may be cleared on every reboot so you will not accumulate many stale
cache files.</p>

<p>Note that, right now, Rubinius does not clear the cache directory. It will
happily continue adding to it indefinitely. However, this may not be an issue
unless you are cycling through a bunch of Ruby files, for example, working on
a number of Ruby projects in series. In that case, using a per-project (per
current working directory) cache is probably the best option.</p>

<p>Here is how solution 2 shakes out:</p>

<p><strong>Use Case:</strong> You want to combine all compilation cache files in one location.</p>

<p><strong>Pros:</strong> No <code>.rbc</code> files mixed in with the rest of your files.</p>

<p><strong>Cons:</strong> You may still need a per-project or per-working-directory cache
directory. However, you can easily specify where to put that directory.</p>

<h3 id="using-rbxopt-for-options">Using RBXOPT for Options</h3>

<p>As mentioned above, the <code>-X</code> options can get a little long and you certainly
don&rsquo;t want to retype them constantly. We have added support for the <code>RBXOPT</code>
environment variable, which is an analog of the <code>RUBYOPT</code> environment variable
that we already support.</p>

<p>Use <code>RBXOPT</code> to specify <code>-X</code> options that Rubinius should use. For example:</p>

<pre><code>export RBXOPT=-Xrbc.db=/path/to/dir
</code></pre>

<p>You can check out all the <code>-X</code> options with <code>rbx -Xconfig.print</code> or <code>rbx
-Xconfig.print=2</code> for more verbose output. If you want to use multiple <code>-X</code>
options in <code>RBXOPT</code>, use quotes and separate the options with a space:</p>

<pre><code>export RBXOPT='-Xrbc.db -Xagent.start'
</code></pre>

<h3 id="conclusion">Conclusion</h3>

<p>Rubinius saves a compilation cache for compiled Ruby code to avoid wasting
time and resources recompiling source that has not changed. However, we need
some place to store the cache. Rubinius provides options for omitting the
cache altogether or for storing it in a directory of your choosing. Note that
the format of the compilation cache is an implementation detail and we reserve
the right to change it at any time, so please don&rsquo;t rely on it being in any
particular format.</p>

<p>We have not turned on <code>-Xrbc.db</code> by default yet because we don&rsquo;t know what a
good default is. So give us feedback on your use cases and what you would find
most useful.</p>

<p>Finally, whenever we discuss the compilation cache we are inevitably asked if
you can run directly from the cache and not use the Ruby source at all after
it has been compiled. The short answer is &ldquo;Yes&rdquo;, the long answer is &ldquo;It
depends&rdquo;. I will be writing a post exploring this question in detail shortly.
For now, get out there and write more Ruby code!</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/02/25/why-use-rubinius/" title="Why Use Rubinius" class="post_title">
        Why Use Rubinius
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Brian Ford</span>
          <span class="date">25 February 2011</span>
          
                      <a href="http://rubini.us/2011/02/25/why-use-rubinius/#disqus_thread"
            data-disqus-identifier="/2011/02/25/why-use-rubinius/"></a>

          
        </p>
      </div>

      <p><em>Why should I use Rubinius?</em> We have been asked that question many, many times
over the past four years. It is a great question. It is an important question.
It&rsquo;s a <em>hard</em> question. I&rsquo;m not holding out on you. I want to give you an
answer that sates your curiosity, helps you make informed decisions, and
empowers you to speak eloquently when <em>you</em> are inevitably asked, &ldquo;Why do you
use Rubinius?&rdquo;</p>

<p>The trouble is, there are many different situations in which people use Ruby
and there is simply no answer, however comprehensive, that really speaks to
everyone&rsquo;s concerns. So rather that boring you at length, I thought a <em>Choose
your own adventure</em> style would be a better approach.</p>

<p>From the list below, select the persona that best describes you. Don&rsquo;t worry,
if the one you select doesn&rsquo;t sound right, you can easily backtrack here. Read
as many as interest you. After all, none of us fit easily into any one box.
When you are done exploring all the fascinating reasons to use Rubinius, let&rsquo;s
meet up at the <a href="#wur-conclusion">Conclusion</a> for some parting
words.</p>

<p><em>Enjoy!</em></p>

<h3><a class="anchor_title" name="wur-personas">Choose Your Persona</a></h3>

<ul>
  <li><a href="#wur-newby">Rails or Ruby Newby</a></li>
  <li><a href="#wur-creative">The Creative</a></li>
  <li><a href="#wur-experienced">Experienced Programmer</a></li>
  <li><a href="#wur-seasoned">Seasoned Programmer</a></li>
  <li><a href="#wur-academic">Academic Researcher</a></li>
  <li><a href="#wur-uber">Über Programmer</a></li>
  <li><a href="#wur-philosophical">Philosophy Student Seeking the Meaning of Ruby</a></li>
  <li><a href="#wur-manager">Manager</a></li>
  <li><a href="#wur-knowledge">Knowledge Seeker</a></li>
  <li><a href="#wur-enthusiast">Language Enthusiast</a></li>
</ul>

<h4><a class="anchor_title" name="wur-newby">Rails or Ruby Newby</a></h4>

<p>You are pretty new to programming and after hearing about Ruby on Rails you
watched a screencast and made a website. You are curious and enthusiastic.</p>

<p>You are the empty teacup of the Zen proverb. You are a fresh-faced flower
glistening with the morning dew. The sun smiles on you and you smile back.
You seem to like this Ruby language that makes programmers happy and you&rsquo;ve
come to lend your cheery spirit&hellip;</p>

<p>Welcome!</p>

<p>So, you have heard of this thing called Rubinius or rbx or whatever and some
folks you respect or admire seem to like it and naturally you want to know
what the big deal is and you&rsquo;re like, &ldquo;Yo, why would I use Rubinius?&rdquo;.</p>

<p>Cool.</p>

<p>Well, you should use Rubinius because I said so. Try your code on it. Tell us
what worked for you. Tell us if something didn&rsquo;t work by opening an
<a href="https://github.com/evanphx/rubinius/issues/">issue</a>.
Set your imagination loose and tell us what tool you would use if you could.</p>

<p>Spend some time reading the Rubinius source code. Start at the <code>kernel/</code>
directory. It&rsquo;s full of Ruby code! As you read through how Ruby is
implemented, how it actually works, it will give you a level of understanding
of your code that many programmers don&rsquo;t have in <em>any</em> language.</p>

<p>Most of all, hang on to your curiosity and enthusiasm. Those were vital to the
creation of the Rubinius project in the beginning and have sustained us
through many challenges. We <em>can</em> make our Ruby experience better, freeing us
from the shackles of other languages and foreign libraries. We <em>can</em> have fast
and reliable web servers, games, editors, websites and applications written in
Ruby. We <em>can</em> have first class tools written for and with Ruby. The world
<em>can</em> be rosy red without our glasses.</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h4><a class="anchor_title" name="wur-creative">The Creative</a></h4>

<p>Ruby is groovy. No, not that Groovy, eww, no. I mean:</p>

<blockquote>
<p>groovy |ˈgroōvē| adj.</p>

<ul>
  <li>fashionable and exciting : <em>sporting a groovy new haircut</em></li>
  <li>enjoyable and excellent : <em>he played all the remarkably groovy guitar parts
himself</em></li>
</ul>

<p>(Apple's dashboard dictionary widget.)</p>
</blockquote>

<p>Ruby respects creativity. It has an <em>aesthetic</em>. You don&rsquo;t just write Ruby
code, you write <em>beautiful</em> Ruby code.  It would be unthinkable to do
otherwise. Sure, there is more than one way to do many things. This is not
some sterile laboratory. We are not automatons; we are people. Of course,
being utilitarian is not bad. But other languages have that angle pretty
well covered. There is probably only one right way to implement Python.</p>

<p>Rubinius has an aesthetic, too: excellence, utility, simplicity, beauty, joy.
Mostly in that order. Useful code that isn&rsquo;t of very good quality is a drag.
It slows you down. It gives you a headache. It drives you away. We strive to
keep it out of Rubinius. On the other hand, we are not just writing sonnets
here. This is Serious Business™. We have some hard-core problems to solve. So
we strive for excellent, useful, beautiful code that is a joy to work with.</p>

<p>Of course, this is an ongoing process. It is a journey, not a destination.
There are areas of Rubinius that could use a thorough cleaning or a new
perspective on making the implementation of this beautiful object-oriented
language more beautiful and object-oriented.</p>

<p>We welcome your artistic perspective. Help us improve the dialog between
Rubinius and the person using it. The command line doesn&rsquo;t have to be a
desolate place of obscure, condescending error messages. Web interfaces to the
diagnostic tools deserve a good dose of user-experience and interaction
design. You know that feeling you get when looking at an Enterprise web
application? That weird plastic-masquerading-as-quality-material feeling?
The too much 1996-Enterprise-faux-rounded-corner-wanabe-2006-hip gloss?
Gives me the willies whenever I have to use an app like that. Yeah, we don&rsquo;t
want that.</p>

<p>We want to create tools that are powerful, graceful, easy to use, and
beautiful to look at. Beautiful tools are easier to use. (Yehuda Katz provided
a couple links related to this: <a href="https://www.westga.edu/~distance/ojdla/winter134/david_glore134.html">The Impact of Design and Aesthetics on
Usability, Credibility, and Learning in an Online Environment
</a> and
<a href="http://www.alistapart.com/articles/indefenseofeyecandy">In Defense of Eye
Candy</a>. If you know of
other research, leave us a comment.) So if you have a creative bent but enjoy
writing code also, try out Rubinius and let us know where it could use some
polish.</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h4><a class="anchor_title" name="wur-experienced">Experienced programmer</a></h4>

<p>That saying, <em>Time is Money</em>, you live by it. You have applications to deliver
and you choose the best tool for the job. You are professional, conscientious,
duly cautious, and not inclined to episodes of emotional exuberance about the
latest fad. You accept compromises. There are always trade-offs. The correct
approach is cost-benefit analysis. The numbers tell the story and level-headed
decision making follows the numbers.</p>

<p>You have heard about Rubinius and you are curious whether it may be
appropriate for your current project. As usual, rather than speculating or
paying too much heed to the buzz, you look into it yourself. After some
investigation, you discover that:</p>

<ol>
  <li>Much of Rubinius is implemented in Ruby itself. This may be a big help when
tracking down troublesome bugs.</li>
  <li>Rubinius has a very fast bytecode virtual machine, as well as a modern
generational garbage collector so memory profiles should be more
predictable and consistent in deployed applications.</li>
  <li>It has a profile-driven JIT compiler that uses type-feedback to
aggressively inline methods resulting in significant performance
improvements.</li>
  <li>It has a built-in debugger and precise method profiler, both of which are
fast due to being well integrated.</li>
  <li>It has a built-in API for monitoring a VM out-of-process, even on a remote
machine. We are building a variety of diagnostic tools atop this API.</li>
</ol>

<p>Of course, even if the technology in Rubinius sounds terrific in theory, how
suitable is Rubinius for your application? How does it perform under your
specific constraints? Again, you do some investigating. You have a solid test
suite for your application, so you start by running that. If you hit any
problems, please open an <a href="https://github.com/evanphx/rubinius/issues/">issue</a>
to let us know.</p>

<p>If everything goes well with the tests, you start running some of the
benchmarks that you have accumulated while doing performance tuning. Of
course, no sensible person asks for benchmark results from <em>other</em> people&rsquo;s
code. That defies logic. It&rsquo;s like asking if your program will run because
your Aunt Mabeline likes decaf coffee. It&rsquo;s contrary to the very point of
benchmarking, where you are trying to correlate two values that are connected.</p>

<p>Again, if you note an significant issues, please let us know. Sometimes
Rubinius exposes issues in existing code. Performance characteristics of real
applications are vital to making Rubinius faster. Also, if you have
suggestions for tools you would like to use, tell us. If you just want to
chat about the technology, that&rsquo;s fine, too. We&rsquo;re hanging out in the
#rubinius channel on freenode.net.</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h4><a class="anchor_title" name="wur-seasoned">Seasoned programmer</a></h4>

<p>Well, I am being kind by saying <em>seasoned</em>. You know when you look in the
mirror that <em>jaded</em> and <em>cynical</em> are much more apt. You&rsquo;ve seen it all and it
has worn you down. You&rsquo;ve been fighting the good fight, carefully guarding
that last flicker of optimism that burns in the secret place deep in your
heart. You&rsquo;ve programmed Java/.NET/C++ professionally. You&rsquo;ve even sucked it
up and written some PHP and Python when asked; you are a professional, they
ask and you deliver. You&rsquo;ve seen attacked servers on fire off the shoulder of
Rackspace&hellip;</p>

<p>Rubinius has a lot to offer you. Remember that little flicker of optimism?  It
is only the idealists that get ground down by the complete indifference to
pursuit of an ideal in so much of the world. Deep down, you are an idealist
and you will find plenty to refresh you here.</p>

<p>Rubinius aims to be the best possible implementation of Ruby by putting Ruby
itself front and center. We are using modern technology and always improving.
We change when there is a better way to do things. We judiciously rewrite and
are not too attached to any code or algorithm. The legacy Enterprise isn&rsquo;t on
the steering committee. Our work will be done when you can use Ruby, just
Ruby, to solve your thorny problems.</p>

<p>Sure, that sounds idealistic. But never mind the pessimists that tell you that
you have to compromise. If you are not idealistic, you will not be unsatisfied
with things that are not as good as they could be; you will not try to change
the world. So give Rubinius a try, you may be surprised. And if you are, put
all that hard-earned wisdom you have gained to use for the betterment of Ruby.</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h4><a class="anchor_title" name="wur-academic">Academic Researcher</a></h4>

<p>Forgive me for staring, I know it is impolite. I&rsquo;m just&hellip; intrigued. Of
course, you know Ruby is a late bound language, every message sent could
conceivably fail to find a target, potentially resulting in an uncaught
exception and program termination. There&rsquo;s shared state, wild orgies of
mutation that disallow any reasonable attempt at automated parallelization.
Program proof is as oxymoronic a concept as military intelligence. It&rsquo;s a very
messy affair of programming and meta-programming and meta-meta-programming,
which, for the love of Lisp, could be done so simply with macros. There&rsquo;s all
this eager evaluation and complete disregard for purity. Despite vast odds,
somehow programs are written that actually run. You have noted all this with
great objectivity but you are nonetheless interested.</p>

<p>Excellent, we are pleased. We have much to learn and welcome the opportunity
for lively discussions about bringing formal methods to bear on the problems
of making Ruby as fast as possible.</p>

<p>Java benefited tremendously from the amount of attention it received by
academic researchers. Ruby can benefit from some of this research as well, not
to mention the research into Smalltalk and Self that preceded it. But Ruby has
its own set of problems to solve and deserves specific attention. The problems
are hard but not insurmountable. Rubinius is already demonstrating that.  The
suggestion that we need to add more keywords, restrict Ruby dynamism, or write
<code>public static final int</code> all over are simply nonsense.</p>

<p>Rubinius already leverages research for fast virtual machines, garbage
collection (e.g. the generational approach and the Immix <em>mark-region</em>
algorithm), and JIT compilers (based on pioneering research done in Self and
used in the JVM Hotspot VM). Rubinius uses the exceptional
<a href="http://llvm.org">LLVM</a> project for optimization and code generation in the
JIT compiler. We are also working on better infrastructure for the JIT to
address Ruby complexities head-on.</p>

<p>Rubinius would be excellent to use in teaching. A compiler construction class
could study the architecture of the bytecode compiler written in Ruby and
experiment with exploratory changes to the compiler using IRB without having
to recompile anything! A 30-minute introduction to Rubinius could proceed
immediately to simple AST generation and have students experimenting with
their own syntax immediately. While it is easy to get started, there is plenty
of depth for exploring complex topics in virtual-machine construction and
garbage collection.</p>

<p>Whether you are interested in language research or language pedagogy, Rubinius
is an great project to consider. We look forward to hearing from you.</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h4><a class="anchor_title" name="wur-uber">Über programmer</a></h4>

<p>You learned the untyped lambda calculus sitting on your mother&rsquo;s knee while
she worked on her doctorate in computer science. You were substituting terms
before you even uttered the word, &ldquo;dada&rdquo;. You wrote three different Lisp
implementations in Commodore Basic before you were seven. You can write
multi-threaded web servers in one pass with no tests and never hit a deadlock
or critical data race. You write parsers and compilers for odd languages on a
Friday night for the heck of it while waiting for the pizza to arrive before a
night out at the karaoke bar where you give an inspiring performance of Laga
Gaga&rsquo;s <em>Poker Face</em>.</p>

<p>(<em>Loooong pause</em>. You&rsquo;re not reading this. You&rsquo;ve already written one or a few
languages on Rubinius and posted them to our
<a href="http://rubini.us/projects/">Projects</a> page. But anyway, I&rsquo;ll continue&hellip;)</p>

<p>You are the Luke Skywalker of Ruby; Yoda has nothing more to teach you. Only
your fate confronts you now. Use the Source Luke and save the Federation of
Ruby loyalists from the Evil Oracle and its Java the Hurt.</p>

<p>There are a number of domains in which Ruby could benefit tremendously from
excellent libraries:</p>

<ol>
  <li><strong>Servers and web servers</strong>: the web is here to stay but the argument that all
applications are going to be in Javascript on the client is not valid. A variety
of hybrid client-server architectures will continue to be the norm. We need
software that enables application authors to build a suitable solution to
their particular problems rather than trying to stuff their apps into
someone else&rsquo;s solution with layers of wrapping.</li>
  <li><strong>Concurrency</strong>: multi-core is here to stay but it is not only functional
programming that is suitable for high-concurrency applications.</li>
  <li><strong>Graphical user interface</strong>: the web browser is also here to stay but it is
not the last word in applications. There are many cases where GUI apps are
the best option and Ruby needs a mature library or set of libraries to
build these apps on any major platform. I know some of these libraries
exist, but they seem to be collecting dust lately.</li>
  <li><strong>Big data and data analysis libraries</strong>: our industry repeatedly witnesses
the same pattern: domain X starts with huge applications running on huge
horsepower servers for huge businesses and then it starts appearing in small
applications on small computers for small businesses. Accounting and
geographic information systems (GIS) are two examples. Data analysis is
coming to a laptop near you.</li>
</ol>

<p>These are general areas in which Ruby can be an excellent solution. So how
does Rubinius fit in? Rubinius is dedicatedly pushing more and more into Ruby
itself. Each of these domain is typically handled in Ruby right now by going
to find a library in a foreign language to wrap in a fuzzy Ruby embrace.
Rubinius is calling on the über-programmers of the world to implement
solutions in Ruby to help us identify performance challenges and address them.</p>

<p>Rubinius is also being used in some fascinating language experiments. Two of
these are Atomo (<a href="http://atomo-lang.org">http://atomo-lang.org</a> which is
implemented in Haskell, with a Rubinius implementation code-named
<a href="https://github.com/vito/quanto/">quanto</a>) and Fancy
(<a href="http://fancy-lang.org">http://fancy-lang.org</a>). So, if language design is
your cup of tea, Rubinius offers an excellent platform for experimentation.</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h4><a class="anchor_title" name="wur-philosophical">Philosophy Student Seeking the Meaning of Ruby</a></h4>

<p>Like your persona description, you tend to be long winded. You find most
descriptions too brief, almost dismissive. There are words and words should be
used to delve into the minutiae of minutiae. You, more than anyone, want to
know &ldquo;Why?&rdquo; with every fiber of your being. You will continue asking long
after the supply of hallucinogens has been exhausted and everyone else is
drooling in their sleep.</p>

<p>For you, Rubinius is an existential dilemma crying out for justification. If
we already have MRI, why build Rubinius?</p>

<p>It would be accurate to say that Rubinius has a philosophy. That philosophy is
simply this: <em>Ruby should be a first class language</em>. What does that mean?
Simply that it should be possible to solve problems writing Ruby code.</p>

<p>Let&rsquo;s consider libraries: Being first class means not having to wrap a Java
library or build a C extension. If wrapping the library were the end of the
story, it wouldn&rsquo;t be so bad. But that is <em>never</em> the case. Libraries have
bugs, weird APIs, incompatibility with other libraries, threading issues, and
disappearing maintainers. They may even be incompatible with newer versions of
the language in which they are written.</p>

<p>This list goes on. To address any one of these issues requires delving into a
different language with weird and incompatible semantics. If the library is
your core competency, that&rsquo;s not such a big deal. But I will wager that it is
not, which is why you are using the library in the first place. Also, the
language in which you are wrapping the library (Ruby here) is not likely the
core competency of the library author, or you probably wouldn&rsquo;t need to be
wrapping it. So Ruby wrapping one of these libraries will always be a
second-class citizen. Decisions will be made about the library&rsquo;s API that do
not give one thought to the Ruby programs using it. Furthermore, the code
written in that foreign language does nothing to support the ecosystem of
Ruby. The knowledge gained in writing the library and the improved skills of
the library author do not benefit Ruby. Ruby deserves better.</p>

<p>Ruby has gotten a big boost recently with the production release of MRI 1.9.2.
There are significant speed improvements and welcomed additions to the core
libraries, like powerful handling of String encodings. At the same time, the
Complex and Rational libraries were added to the core library and rewritten
from Ruby to C code. This is disappointing. We should be able to solve these
problems more effectively in Ruby itself.</p>

<p>The philosophy of Rubinius is to make Ruby a first-class citizen. Ruby plays
second fiddle to no one. There is no other language whose history, semantics,
or vested interests compete with Ruby&rsquo;s. It is true that there are difficult
problems to solve in making Ruby fast. But much of the technology already
exists and we will build what does not. Evan often quips that if we can get
Rubinius caught up to the dynamic language technology of ten years ago, Ruby
will be light-years ahead.  That may be overstating how far behind Ruby is,
but it illustrates the focus of Rubinius.</p>

<p>There&rsquo;s the saying, <em>In theory, there is no difference between theory and
practice. In practice, there is</em>. In Rubinius, theory and practice are
merging. We are motivated by the desire for Ruby to be a first-class language.
But we are also showing real progress in making that a reality. The Rubinius
VM executes Ruby code blazingly fast. The JIT compiler, while still being
quite young, is showing great promise. Compatibility with MRI is quite good
and speed is constantly improving.</p>

<p>Is the Rubinius philosophy valid? We think the proof is in the pudding.</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h4><a class="anchor_title" name="wur-manager">Manager</a></h4>

<p>No, it did not cross my mind to describe this persona as Pointy-haired Boss.
Not only would that be unfair to Dilbert, but that persona would be reading an
article on Web Scale. No, you are someone who has fought hard battles in the
trenches and learned valuable lessons: it&rsquo;s about execution and execution
depends on good technology.</p>

<p>Rubinius is building solid technology. We started the RubySpec project and
have contributed tens of thousands of lines of code to it. With the support of
Rubyspec, in just over four years as a public project, we have basically
caught up with MRI 1.8.7 in compatibility and performance. For some code, our
performance is much better, for other code, it is not as good. However,
Rubinius is built on solid, modern technology and the project&rsquo;s trajectory and
velocity are outstanding.</p>

<p>Rubinius is a completely new implementation of core Ruby. Rubinius did not
start as a port of existing code. Furthermore, Rubinius implements its own
virtual machine and garbage collector in C++. The bytecode compiler that
targets the virtual machine is pure Ruby. The core Ruby library is mostly Ruby
with some primitive operations in C++. The JIT compiler uses the
<a href="http://llvm.org">LLVM</a> project. Given the amount of work being done in the
project, Rubinius is pacing extremely well relative to other implementations.</p>

<p>Currently, we are working on support for Ruby 1.9 features, Windows support,
and full concurrency with no global interpreter lock (GIL).</p>

<p>If you are looking at Ruby to implement your next project, rest assured that
Ruby will have the support of excellent technology. If you are already using
Ruby, consider investigating how your application runs on Rubinius. We welcome
the feedback and look forward to solving challenging engineering problems.</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h4><a class="anchor_title" name="wur-knowledge">Knowledge Seeker</a></h4>

<p>You thirst for Knowledge. You follow it wherever it leads you. You&rsquo;ll happily
walk Haskell&rsquo;s hallowed halls of pure laziness or sit at the feet of the
meta-program gazing raptly at class transmorgrification. You don&rsquo;t judge. You
have more than enough knowledge to be dangerous, enough to know that the
universe is amoral and knowledge is the only Truth there is. Nor does any mere
mortal language bind you. All languages are finite. You&rsquo;ll be here today and
gone tomorrow; there is no permanence for the knowledge seeker.</p>

<p>Rubinius is merely a step along the path you journey. Take what you want, it
is all free. As a Ruby implementation, it has much to offer your quest for
knowledge. The Ruby code in the core library is accessible and easy to follow.
The interface between Ruby and the C++ primitives is consistent. The C++ code
itself is restrained. You won&rsquo;t need a PhD in Turing-complete template
languages to understand it.</p>

<p>Rubinius offers extensive opportunities to learn about programming languages
in general and Ruby in particular. When I first started working with Rubinius,
I knew a little bit about garbage collection and virtual machines. I would
call what I knew, toy knowledge. As I struggled to learn more, it seemed
helpful to consider layers of understanding:</p>

<ol>
  <li><strong>General programming language semantics</strong>: the procedure abstraction,
looping and iteration, recursion, references and values, etc.</li>
  <li><strong>Ruby semantics</strong>: modules and classes, access restrictions, blocks and
lambdas, etc. Even with fundamental programming knowledge, a particular
language can be confusing. When I was learning C, a friend was also
studying it. One day he walked over and threw <em>The C Programming Language</em>
book down on my desk and said, &ldquo;This <code>for</code> loop makes no sense!&rdquo; He was
quite upset. &ldquo;Look,&rdquo; he said, &ldquo;in this example <code>for (i=0; i &lt; n; i++)</code> how
can <code>i &lt; n</code> get executed <em>after</em> the code in the body?!&rdquo; It&rsquo;s easy to laugh
at that confusion, but coming from BASIC, that really threw him. Deepening
our understanding to this second level requires confronting some
&ldquo;counter-intuitive&rdquo; notions.</li>
  <li><strong>Hypothetical implementation</strong>: knowing how Ruby works, how might one
implement it. I think this is an important layer of understanding and it is
easy to miss or gloss over it. By pausing at this layer and thinking how
you might implement something, you test whether or not you are really
understanding it.</li>
  <li><strong>The MRI implementation</strong>: Reading the MRI source code is an excellent way
to investigate Ruby. For one thing, it will inform you how Ruby <em>actually</em>
works, and you may be surprised.</li>
  <li><strong>The Rubinius implementation</strong>: here you are exposed to the philosophy of
Rubinius and the challenges to implementing Ruby. We are attempting to
bring the beauty of Ruby as an object-oriented language deep into the core
of Ruby itself.</li>
</ol>

<p>While the Rubinius code itself offers many opportunities for learning, don&rsquo;t
hesitate to drop by the #rubinius channel on freenode.net and ask us
questions. Perhaps you already know a lot about another language and are
interested in how Rubinius implements some feature. Or you may be relatively
new to programming languages and have some basic questions. We enjoy talking
about these concepts. If you are quite new to Rubinius, you may find these
posts informative:</p>

<ul>
  <li><a href="http://www.engineyard.com/blog/2010/making-ruby-fast-the-rubinius-jit/">Making Ruby Fast: The Rubinius JIT</a></li>
  <li><a href="http://www.engineyard.com/blog/2009/improving-the-rubinius-bytecode-compiler/">Improving the Rubinius Bytecode Compiler</a></li>
  <li><a href="http://www.engineyard.com/blog/2009/the-anatomy-of-a-ruby-jit-compile/">Compiling Ruby: From Text to Bytecode</a></li>
</ul>

<p>Finally, consider helping other knowledge seekers by writing blog posts on
what you learn about Rubinius. Or, help us <a href="http://rubini.us/doc/en/how-to/write-documentation/">write documentation</a>!</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h4><a class="anchor_title" name="wur-enthusiast">Language Enthusiast</a></h4>

<p>You like languages for their intrinsic value. Of course the world comes in
many shapes and sizes. You wouldn&rsquo;t have it any other way. That&rsquo;s the fun and
spice, joie de vivre, raison d&rsquo;etre, supermarché&hellip; Sometimes you get carried
away writing a program in another language just because you like how the
letters arrange down the screen. Ruby is definitely one of the impressive
languages and sometimes you almost notice a tiny bit of favoritism in your
normally egalitarian attitude.</p>

<p>As with any enthusiast, you like to experiment. Your interest is not mere
curiosity or sterile investigation. You want to get your feet wet and your
hands dirty. Rubinius is an excellent opportunity to delve into a number of
fascinating subjects. We can merely suggest a path; your experiences along the
way will tell you whether or not Rubinius has value to you.</p>

<p>If you are most interested in languages themselves, the syntax and arrangement
of features, Rubinius offers you immediate gratification. Look for Evan&rsquo;s
upcoming post on his Language Toolkit or check out the code to
<a href="https://github.com/evanphx/prattle">prattle</a>, a Smalltalk dialect used to
illustrate the ease of building a language on Rubinius. Also look at some of
the existing languages <a href="http://rubini.us/projects/">projects</a> targeting
Rubinius.</p>

<p>If it is the machinery under the covers that is more interesting, start
reading some code. The bytecode compiler lives in <code>lib/compiler/</code>. The virtual
machine is in <code>vm/</code>, and the garbage collector is in <code>vm/gc</code>. As you are
reading through, consider helping us write better documentation. There are
already sections for the <a href="http://rubini.us/doc/en/virtual-machine/">virtual
machine</a>,
<a href="http://rubini.us/doc/en/garbage-collector/">garbage-collector</a>, <a href="http://rubini.us/doc/en/jit/">JIT
compiler</a> and <a href="http://rubini.us/doc/en/bytecode-compiler/">bytecode
compiler</a> in the documentation, so
adding content is easy.</p>

<p>You may also be interested in these previous posts about Rubinius:</p>

<ul>
  <li><a href="http://www.engineyard.com/blog/2010/rubinius-wants-to-help-you-make-ruby-better/">Rubinius wants to help YOU make Ruby better</a></li>
  <li><a href="http://www.engineyard.com/blog/2009/5-things-youll-love-about-rubinius/">5 Things You&rsquo;ll Love About Rubinius</a></li>
  <li><a href="http://www.engineyard.com/blog/2009/rubinius-the-book-tour/">Rubinius: The Book Tour</a></li>
</ul>

<p>Most of all, experiment. Rubinius is easy to hack on. Are you curious about a
particular feature needed in your language? Try adding it to Rubinius. Think
Lua is all the rage because it uses a register VM? You could probably write a
register-based bytecode interpreter for Rubinius in an afternoon. That&rsquo;s just
an example, of course. The point is to play around with your ideas and have
fun doing it. I think you&rsquo;ll find Rubinius to be an adventuresome companion.</p>

<p>Be sure to let us know what you&rsquo;re working on. We like to be inspired, too!
Consider writing a blog post about things that you find interesing, like this
<a href="http://yehudakatz.com/2011/02/18/getting-comfortable-with-rubinius-pure-ruby-internals/">recent post</a> by Yehuda Katz.</p>

<p><a href="#wur-personas"><strong>Back to personas</strong></a></p>

<h3><a class="anchor_title" name="wur-conclusion">Conclusion</a></h3>

<p>So there you have it. Just like there are many different viewpoints, there are
many different reasons to use Rubinius. Not all those reasons make sense to
everyone. We believe, however, that Rubinius has something to offer to just
about everyone interested in Ruby. Most importantly, try it!</p>

<p>If we didn&rsquo;t answer your question here, leave us a comment. If you have a
reason for using Rubinius that we didn&rsquo;t mention, let us know. As always, we
appreciate your feedback. Chat with us in the #rubinius channel on
freenode.net, <a href="https://github.com/evanphx/rubinius">watch our Github project</a>,
and <a href="http://twitter.com/rubinius">follow us on Twitter</a>.</p>

<p>P.S. Thanks to David Waite for suggesting the Academic Researcher and Language
Enthusiast personas, I always forget those!</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/02/23/introduction-to-fancy/" title="Introduction to Fancy" class="post_title">
        Introduction to Fancy
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Christopher Bertels</span>
          <span class="date">23 February 2011</span>
          
                      <a href="http://rubini.us/2011/02/23/introduction-to-fancy/#disqus_thread"
            data-disqus-identifier="/2011/02/23/introduction-to-fancy/"></a>

          
        </p>
      </div>

      <p>Fancy is a new general-purpose programming language targetting the
Rubinius VM.</p>

<p>This blog post will give a short introduction to the language, what
kind of problems it&rsquo;s trying to solve and why I chose Rubinius as the
VM to run Fancy on.</p>

<h3 id="what-is-fancy">What is Fancy?</h3>

<p>Fancy is a new general-purpose, dynamic, pure object-oriented
programming language heavily inspired by Ruby, Smalltalk and Erlang
that runs on the Rubinius VM. It&rsquo;s the first fully bootstrapped
language, aside from Ruby, running on Rubinius. This means that the
compiler that generates bytecode for Rubinius is written in Fancy
itself.</p>

<p>You can think of Fancy as a mix of features from the mentioned
languages above, taking each of their strengths and improving upon
their weaknesses.
Fancy has a very small core and is largely based on the concept of
message passing, just like Smalltalk. It tries to have as many
language concepts being first-class values in the language.</p>

<p>Just like Ruby, Fancy is a dynamic object-oriented language that
allows changing code at runtime, everything being an expression and
generally embracing more then one way to do things. Fancy also has all
the literal support that Ruby has, plus literal syntax for Tuples and
Patterns (more on that below).</p>

<p>In contrast to Ruby and just like Smalltalk, Fancy has a very small
amount of built-in keywords and all of the control structures are
implemented in terms of message sends to objects using closures.</p>

<p>The third language that served as an inspiration is Erlang, from which
Fancy takes the idea that concurrent programming should be easy by
having the Actor Model built into the language. This part is still a
work in progress, but should come together soon. The fact that
Rubinius has a built-in Channel type, inter-VM communication
capabilities and even an actor library makes implementing this easier
than in traditional systems.</p>

<h3 id="why-fancy">Why Fancy?</h3>

<p>I believe there is real value in having a language that supports
certain things out of the box. Especially when it comes to things like
asynchronous and concurrent programming, having proper semantics built
into the language can often help developers more than a library can.
Very often it&rsquo;s not just about the functionality itself but also about
the semantics you want that functionality to have. This can cause
problems particularly if the language&rsquo;s semantics differ from what
your library is trying to solve. A good example is the callback-based
approach to asynchronous progamming which leads to code that differs
both in semantics as well as how code is structured, compared to
synchronous code. Ideally you&rsquo;d still want to write code in a
synchronous fashion, where exceptions pop up naturally while still
being highly asynchronous.</p>

<p>In that sense Fancy is more flexible than Ruby as there&rsquo;s not many
special case semantics built in to the core language. Everything&rsquo;s
done via message passing, which fits nicely the actor model approach
to concurrency. Fancy&rsquo;s syntax is a lot simpler, too.</p>

<p>Since all the core control structures are just implemented in Fancy
itself and adhere to the message passing protocol, you can easily
override them for your personal needs. This is especially interesting
when implementing domain specific languages.
Say, you&rsquo;d want to add some logging to conditional or looping
constructs - it&rsquo;s as easy as overriding a method in your DSL&rsquo;s
classes. Fancy also has class-based mixins, so it makes it easy to
share functionality across class hierarchy boundaries.</p>

<p>Finally, I created Fancy because I wanted a language implementation
that was well documented, easy to understand and very flexible to
extend. Ruby is a nice language, but it has some inconsistencies and
there&rsquo;s only so much you can do when you&rsquo;re bound by backwards
compatibility. By starting fresh, Fancy has a clean, simple and easy
to extend core which allows further exploration of features and
abstractions.</p>

<h3 id="why-target-rubinius">Why target Rubinius?</h3>

<p>The initial implementation of Fancy was a simple interpreter written
in C++, similar to how Ruby 1.8 (MRI) works. It was a simple AST
walker. After moving to Rubinius and writing an initial bootstrap
compiler in Ruby, the codebase shrank to about 20% of the original
implementation while actually being more performant. This of course is
mostly due to Rubinius&rsquo; architecture and JIT compiler but it was a
great experience nontheless.</p>

<p>The nice part about having a common virtual machine and runtime is
that you&rsquo;re not forced to a completely different platform to get the
job done. Fancy and Ruby can coexist in the same application nicely
and calling code from one another is dead simple. In fact, as of now,
Rubinius doesn&rsquo;t know anything about Fancy. And it shouldn&rsquo;t. As long
as all languages running on top of it adhere to the same interface
(in this case the bytecode), it should just work fine.</p>

<p>Choosing Rubinius as a successor platform for Fancy was easy. It&rsquo;s
built for Ruby, a language that&rsquo;s closely related to Fancy. Rubinius,
while having been developed as a VM for running Ruby code, is very
flexible and there are many features that abstract over Ruby&rsquo;s
external semantics. It was just a natural choice given the fact that
Rubinius&rsquo; architecture and design was heavily influenced by Smalltalk
VMs. Also, it&rsquo;s a very nice dynamic bytecode virtual machine. The
community is very responsive and helpful. Bugs get fixed instantly,
there&rsquo;s always someone to help out and overall it&rsquo;s been a great
experience.</p>

<h3 id="lets-look-at-some-code">Let&rsquo;s look at some code!</h3>

<p>OK, enough talking. Let&rsquo;s have a look on how to get some Fancy code up
and running. Our little sample application will be a simple IRC bot
that connects to Fancy&rsquo;s irc channel on Freenode and says hello to
everyone that greets it. To make life easier, there&rsquo;s already a Fancy
package out there that helps with exactly this task:
<a href="https://github.com/bakkdoor/fancy_irc">FancyIRC</a>.</p>

<p>FancyIRC is a simple IRC client library inspired by Ruby&rsquo;s IRC bot
framework <a href="https://github.com/cinchrb/cinch">Cinch</a>. It&rsquo;s much simpler
and the code is fairly easy to read, but it gives you a similar
interface for writing IRC clients or bots.</p>

<p>So let&rsquo;s get going by installing Fancy. You can either use the Fancy
Rubygem and install it with Rubinius or get the code from GitHub and
run <code>rake</code> in the directory. You&rsquo;ll also then have to add the <code>bin</code>
directory to your <code>$PATH</code>. If you want the latest and greatest version
of Fancy I recommend building directly from source, as the Gem might
not be up to date all the time. For demonstration purposes, let&rsquo;s
install the Rubygem.</p>

<pre><code>$ rbx -S gem install fancy
</code></pre>

<p>To get the FancyIRC package we use Fancy&rsquo;s built-in package manager,
which knows how to find the code on GitHub and install it locally:</p>

<pre><code>$ fancy install bakkdoor/fancy_irc
</code></pre>

<h4 id="writing-the-code">Writing the code</h4>

<div class="highlight"><pre><code class="fancy"><span class="lineno"> 1</span> <span class="nf">require:</span> <span class="s">&quot;fancy_irc&quot;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="n">greeter_bot</span> <span class="o">=</span> <span class="no">FancyIRC</span> <span class="no">Client</span> <span class="nf">new:</span> <span class="p">{</span>
<span class="lineno"> 4</span>   <span class="nf">configuration:</span> <span class="p">{</span>
<span class="lineno"> 5</span>     <span class="nf">nickname:</span> <span class="s">&quot;greeter_bot&quot;</span>
<span class="lineno"> 6</span>     <span class="nf">server:</span> <span class="s">&quot;irc.freenode.net&quot;</span>
<span class="lineno"> 7</span>     <span class="nf">port:</span> <span class="mi">6667</span>
<span class="lineno"> 8</span>     <span class="nf">channels:</span> <span class="o">[</span><span class="s">&quot;#fancy&quot;</span><span class="o">]</span>
<span class="lineno"> 9</span>   <span class="p">}</span>
<span class="lineno">10</span> 
<span class="lineno">11</span>   <span class="c1"># greet person back</span>
<span class="lineno">12</span>   <span class="nf">on:</span> <span class="ss">&#39;channel</span> <span class="nf">pattern:</span> <span class="sr">/^[hH]ello greeter_bot/</span> <span class="nf">do:</span> <span class="p">|</span><span class="n">msg</span><span class="p">|</span> <span class="p">{</span>
<span class="lineno">13</span>     <span class="n">msg</span> <span class="nf">reply:</span> <span class="s">&quot;Hello to you too, #{msg author}!&quot;</span>
<span class="lineno">14</span>   <span class="p">}</span>
<span class="lineno">15</span> 
<span class="lineno">16</span>   <span class="c1"># &quot;echo&quot; command</span>
<span class="lineno">17</span>   <span class="c1"># invoke with: !echo &lt;text&gt;</span>
<span class="lineno">18</span>   <span class="nf">on:</span> <span class="ss">&#39;channel</span> <span class="nf">pattern:</span> <span class="sr">/^!echo (.*)$/</span> <span class="nf">do:</span> <span class="p">|</span><span class="n">msg</span><span class="p">,</span> <span class="n">text</span><span class="p">|</span> <span class="p">{</span>
<span class="lineno">19</span>     <span class="n">msg</span> <span class="nf">reply:</span> <span class="s">&quot;#{msg author} said: #{text}&quot;</span>
<span class="lineno">20</span>   <span class="p">}</span>
<span class="lineno">21</span> 
<span class="lineno">22</span>   <span class="c1"># tell bot to shutdown via !shutdown command</span>
<span class="lineno">23</span>   <span class="nf">on:</span> <span class="ss">&#39;channel</span> <span class="nf">pattern:</span> <span class="sr">/^!shutdown/</span> <span class="nf">do:</span> <span class="p">|</span><span class="n">msg</span><span class="p">|</span> <span class="p">{</span>
<span class="lineno">24</span>     <span class="n">msg</span> <span class="nf">reply:</span> <span class="s">&quot;OK, shutting down&quot;</span>
<span class="lineno">25</span>     <span class="no">System</span> <span class="n">exit</span>
<span class="lineno">26</span>   <span class="p">}</span>
<span class="lineno">27</span> <span class="p">}</span>
<span class="lineno">28</span> 
<span class="lineno">29</span> <span class="n">greeter_bot</span> <span class="n">connect</span>
<span class="lineno">30</span> <span class="n">greeter_bot</span> <span class="n">run</span>
</code></pre>
</div>

<p>I think the code is pretty straight forward. This should give you a
feeling for what Fancy looks and feels like. There is of course lots
more to Fancy than what was shown here. It would not fit into a single
blog post.</p>

<p>A quick list of what&rsquo;s currently being worked on:</p>

<ul>
  <li>New pattern matching system: Message passing based pattern matching
that preserves encapsulation and is very extensible including
pattern literals that allow custom pattern types to be defined by
anyone. There&rsquo;s an experimental branch for that. I&rsquo;m happy
to answer questions.</li>
  <li>Async support using coroutines (Fibers) - Write async code in a more
natural way where exceptions propagate naturally and you don&rsquo;t have
to think about callbacks all the time.</li>
  <li>First-class support for actors - Asynchronous message sends, Futures
and multi-vm messaging built-in.</li>
  <li>And much more&hellip;</li>
</ul>

<h3 id="interested">Interested?</h3>

<p>If you got interested in Fancy and want to know where to go next,
here&rsquo;s a short list of things to check out:</p>

<ul>
  <li><a href="https://github.com/bakkdoor/fancy">Fancy&rsquo;s GitHub repository</a>.
The standard library is completely written in Fancy and most classes
and methods have docstrings. It should be fairly easy to understand.</li>
  <li><a href="https://github.com/fancy-lang/infancy">Programming InFancy</a>
An open source tutorial on learning Fancy. Work in progress.</li>
  <li><a href="http://api.fancy-lang.org">http://api.fancy-lang.org</a>
A work in progress page containing Fancy&rsquo;s standard library class
and method documentation.</li>
  <li><a href="https://groups.google.com/forum/#!forum/fancy-lang">Fancy&rsquo;s Google Group mailinglist</a></li>
  <li>IRC Channel: #fancy @ irc.freenode.net</li>
  <li>Website: <a href="http://www.fancy-lang.org">http://www.fancy-lang.org</a></li>
</ul>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/02/22/rubinius-multiple-branches-with-rvm/" title="Running Multiple Rubinius Branches Simultaneously with RVM." class="post_title">
        Running Multiple Rubinius Branches Simultaneously with RVM.
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Wayne E. Seguin</span>
          <span class="date">22 February 2011</span>
          
                      <a href="http://rubini.us/2011/02/22/rubinius-multiple-branches-with-rvm/#disqus_thread"
            data-disqus-identifier="/2011/02/22/rubinius-multiple-branches-with-rvm/"></a>

          
        </p>
      </div>

      <p>This article is written with the assumption that you have RVM installed
already. If you do not, follow the
<a href="http://rvm.beginrescueend.com/rvm/install/">Installation Instructions</a>
followed by the
<a href="http://rvm.beginrescueend.com/rvm/basics/">Basics</a>
closely first.</p>

<h3 id="named-ruby-installs">Named Ruby Installs</h3>

<p>Everyone familiar with RVM knows that it allows you to quickly and
easily install a particular Ruby interpreter by simply running, for
example,</p>

<pre><code>rvm install rbx
</code></pre>

<p>What is not widely known (yet) is that there is a &ldquo;Named Rubies&rdquo; feature
that allows you to install altered versions of the same Ruby
installation along side the original.</p>

<p>In the case of Rubinius there is this facinating branch called &lsquo;hydra&rsquo;.
So let us see how we can have the Rubinius master branch installed as
the main rbx with the hydra branch installed along side as well.</p>

<p>As above you first install rbx which is currently defaulted to -head
version so</p>

<pre><code>rvm install rbx
</code></pre>

<p>is currently equivalent to</p>

<pre><code>rvm install rbx-head
</code></pre>

<p>After we have the mainline head Rubinus branch installed, we now want to
use the named rubies feature. This is done using the -n specifier in the
Ruby identifier string. So for example to install our hydra branch as an
RVM ruby with the name &lsquo;hydra&rsquo; in it we do the following:</p>

<pre><code>rvm install --branch hydra rbx-nhydra
</code></pre>

<p>Now we can see that they can be used together! Using the Rubinius master
environment,</p>

<pre><code>$ rvm rbx ; ruby -v
rubinius 1.2.1 (1.8.7 6feb585f 2011-02-15 JI) [x86_64-apple-darwin10.6.0]
</code></pre>

<p>Whereas using the Rubinius hydra environment,</p>

<pre><code>$ rvm rbx-nhydra ; ruby -v
rubinius 1.3.0dev (1.8.7 6feb585f xxxx-xx-xx JI) [x86_64-apple-darwin10.6.0]
</code></pre>

<p>We see that the next release of Rubinius (hydra branch) is indeed
version 1.3.0 whereas the master branch is version 1.2.1.</p>

<p>Also please note that RVM creates wrapper scripts, so you do not need to
switch out the entire environment just to run the differen versions
either:</p>

<p>For Rubinius master,</p>

<pre><code>$ rbx-head -v
rubinius 1.2.1 (1.8.7 6feb585f 2011-02-15 JI) [x86_64-apple-darwin10.6.0]
</code></pre>

<p>For Rubinius hydra,</p>

<pre><code>$ rbx-head-nhydra -v
rubinius 1.3.0dev (1.8.7 6feb585f xxxx-xx-xx JI) [x86_64-apple-darwin10.6.0]
</code></pre>

<p>There is a lot more available to you than this, for more information on
RVM capabilities please visit the <a href="http://rvm.beginrescueend.com/">RVM
Website</a> and also come talk to us in #rvm on
irc.freenode.net during the daytime EDT.</p>

<p>I hope that this is helpful and informative to you!</p>

<p>~Wayne</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2011/02/17/rubinius-what-s-next/" title="Rubinius, What's Next?" class="post_title">
        Rubinius, What's Next?
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Brian Ford</span>
          <span class="date">17 February 2011</span>
          
                      <a href="http://rubini.us/2011/02/17/rubinius-what-s-next/#disqus_thread"
            data-disqus-identifier="/2011/02/17/rubinius-what-s-next/"></a>

          
        </p>
      </div>

      <p>On Tuesday, we released version 1.2.1 (see the <a href="http://rubini.us/releases/1.2.1/">Release
notes</a>). This release weighs in at 256
commits and 21 tickets closed in the 56 calendar days since the release of
1.2.0. Many thanks to those who contributed patches and to everyone who helped
us test it.</p>

<p>While we were working on 1.2.1, we were also working on a Top Secret project
that we&rsquo;ve craftily <a href="https://github.com/evanphx/rubinius/tree/hydra">hidden in plain
sight</a>. I&rsquo;d like to introduce
the work we are doing on the hydra branch and the features you can expect to
see in Rubinius soon.</p>

<h3 id="daedalus---a-new-build-system">Daedalus - A new build system</h3>

<p>Rubinius is a fairly complex project. It combines multiple components into a
single system. We have worked hard to contain this complexity and from the
beginning we insisted that building Rubinius be as simple as possible. For
example, Rubinius can be run from the source directory, there is no need to
install it first. Typically, building requires:</p>

<pre><code>./configure
rake
</code></pre>

<p>The Rubinius system combines:</p>

<ol>
  <li>External libraries written in C/C++, sometimes built with just Makefiles
and sometimes using autotools.</li>
  <li>The virtual machine, garbage collector, and JIT compiler written in C++.</li>
  <li>The virtual machine interpreter instructions, including support code for
the JIT, and instruction documentation all generated at build time from an
instruction template.</li>
  <li>The core library and bytecode compiler written in Ruby.</li>
  <li>Various C extensions like the Melbourne parser, BigDecimal, Digest, and
OpenSSL libraries. In the case of the parser, we have to build <em>two</em>
versions, one for the bootstrapping system and one for the Rubinius system
being built.</li>
</ol>

<p>It has not been easy to make this work and over the years we have compiled a
list of exactly what we need in a build system. Evan, in typical form, started
hacking out a first pass and created <em>daedalus</em>, our new build system. It
features such exotic (and extremely useful) features as SHA-based change
detection, parallel builds, single-process execution, and use-aware
configuration options. Allow me to elaborate.</p>

<ul>
  <li>A typical build system decides to rebuild a file if the source is newer than
the build artifact. This can result is unnecessarily building files that
have been touched by some process (like updating from the source repository)
but whose contents have not changed.  By basing rebuild decisions on the SHA
digest of the source, only files that have actually been changed need to be
built. Since compiling C++ with optimizations is <em>not</em> a fast process,
eliminating unnecessary building is great for productivity, not to mention
global warming.</li>
  <li>With a multi-core system, builds can be done faster if they are done in
parallel. If the build system can accurately determine dependencies, it can
execute build sub-steps in parallel. Of course, this can cut into YouTube
and Twitter browsing time, but that&rsquo;s a risk we are willing to take.</li>
  <li>While parallel sub-processes during the build are excellent, the supervising
process benefits from running as a single process from start to finish.
Otherwise, configuration data needs to be re-parsed. To support a single
build process, we need multiple, independent dependency graphs for the
components. As noted above, we need to build two versions of the parser,
which requires two dependency graphs <em>for the same component</em>! This is
simply impossible in Rake.</li>
  <li>Use-aware configuration values know that the user has set the value and can
intelligently merge with newer configuration variables that we create
without requiring the user to reconfigure. Ultimately, we are aiming for a
<em>single</em> command build. Just run &lsquo;daedalus&rsquo; and done. There is no step 2.</li>
</ul>

<h3 id="full-on-concurrency">Full-on Concurrency</h3>

<p>Nobody likes waiting in line. In fact, the more desirable a thing is, the less
we want to stand idly waiting in a line for it, tapping our foot, twiddling
our thumbs. The same could be said about our programs.</p>

<p>Threads give us the ability to add concurrency to our programs. However,
unless the hardware either has multiple CPUs or multiple cores per CPU (or
both), the apparent concurrency will still be executing serially. Since there
are so many multi-core CPUs around these days, our programs should be getting
stuff done in parallel.</p>

<p>Unfortunately, there&rsquo;s a twist. Even with native threads on a multi-core CPU,
the amount of parallelism you get depends on how well you manage locks around
shared data and resources. Sometimes managing these locks is complex and you
opt for one big lock, essentially only allowing one thread at a time to run.
That big lock is usually called a global interpreter lock (GIL) or global VM
lock (GVL).</p>

<p>The Rubinius VM originally had green (user-space) threads, but it has had
native threads with a GIL for a while now. In the hydra branch, Evan and
contributors like Dirkjan Bussink have been working on replacing the GIL with
fine-grained locks so that threads truly execute in parallel. This work has
been going very well, owing in part to the fact that so much code in Rubinius
is actually written in Ruby. Contributors like Chuck Remes have been running
hydra under heavy concurrency loads and Rubinius is performing well.</p>

<p>Rubinius also has experimental support for Fibers and a built-in Actor
library. There is more work to be done but Rubinius is quickly becoming an
excellent platform for concurrency, with a variety of approaches available to
the programmer. Evan has also suggested rewriting the Rubinius IO subsystem to
enable even better APIs for concurrency, all from Ruby.</p>

<h3 id="performance">Performance</h3>

<p>Forget everything anyone has ever told you about Ruby being slow. There are
two things that make Ruby, as implemented, slow: 1) inexperience; 2)
inadequate tools. These two result in one big thing: <em>doing too much</em>. Or, as
they say: <em>No code runs faster than no code</em>. We have been working for 4+
years to build adequate tools in Rubinius, and there is plenty of experience
in Smalltalk, Self, and other languages for making dynamic languages fast.</p>

<p>Presently, Rubinius typically runs pure Ruby code almost 2 times faster than
MRI 1.9. However, there are also cases where Rubinius is slower. These mostly
involve core libraries that are implemented in C in MRI. There are three main
fronts on which we are attacking performance issues: 1) improving the
algorithms in the Ruby code that implements the core library; 2) continuing to
tune the VM and garbage collector; and 3) improving the JIT compiler. Which
leads me to one of the most exciting things we are working on&hellip;</p>

<h3 id="jit-intermediate-representation-ir">JIT Intermediate Representation (IR)</h3>

<p>The just-in-time (JIT) compiler is the key to making Ruby fast. One of the
biggest challenges with a dynamic language like Ruby is knowing what method is
actually being invoked when a message is sent to an object. Consider the
following code:</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">A</span>
<span class="lineno"> 2</span>   <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="lineno"> 3</span>     <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="lineno"> 4</span>   <span class="k">end</span>
<span class="lineno"> 5</span> <span class="k">end</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="k">class</span> <span class="nc">B</span>
<span class="lineno"> 8</span>   <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="lineno"> 9</span>     <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="lineno">10</span>   <span class="k">end</span>
<span class="lineno">11</span> <span class="k">end</span>
<span class="lineno">12</span> 
<span class="lineno">13</span> <span class="k">class</span> <span class="nc">C</span>
<span class="lineno">14</span>   <span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="lineno">15</span>     <span class="n">obj</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="lineno">16</span>   <span class="k">end</span>
<span class="lineno">17</span> <span class="k">end</span>
</code></pre>
</div>

<p>What method is being invoked by <code>obj.m(y)</code>? There is no way to definitively
know this by looking at the source code. However, when the program is actually
running, we can know precisely what <code>obj</code> is and precisely which method <code>m</code>
was invoked. This is called type profiling and that is exactly what the Rubinius
VM does. Then the JIT uses the type information to make decisions like whether
to inline a method into another method. When methods are inlined, it gives the
optimizer more data and more possibilities to remove redundant code. The less
code we can run, the faster Ruby will be.</p>

<p>Presently, the JIT compiler converts Rubinius bytecode into LLVM IR and LLVM
handles the thorny task of generating machine code. However, Rubinius bytecode
is designed for fast execution by the virtual machine rather than as a rich
intermediate representation. So Evan has started work on a new JIT IR.</p>

<p>This new IR will help us to express Ruby semantics in a way that enables many
powerful optimizations and will ultimately allow LLVM to generate even better
machine code. Put another way, <em>Rubinius loves Ruby code!</em> Right down to the
metal. There&rsquo;s no fighting a foreign type system or the semantics of a
language at odds with Ruby&rsquo;s rosy view of the world.</p>

<h3 id="ruby-19">Ruby 1.9</h3>

<p>MRI 1.9 introduced two completely different changes to Ruby. The first was a
new implementation based on a bytecode virtual machine. While the virtual
machine replaced the AST-walking interpreter, little else changed
architecturally. Mostly the same core library and garbage collector code
exists in MRI 1.9 as was in MRI 1.8. The second change introduced some new
syntax (minor) and encodings (major). Many of the other changes, for example,
returning Enumerator objects from methods that take blocks, have been
back-ported to Ruby 1.8.7 and are already available in Rubinius.</p>

<p>So, the key to supporting Ruby 1.9 in Rubinius essentially involves supporting
the 1.9 syntax changes and encodings. We have begun implementing the parser
changes and introduced the foundation for Encoding-aware Strings. A good
amount of work remains to be done, but over the next month we expect that
we will be starting to run Ruby 1.9-specific code in Rubinius.</p>

<h3 id="tools-of-information">Tools of Information</h3>

<p>It has been said that <code>printf</code> is the mother of all debuggers. That
illustrates two points: 1) data is often buried in our program code; and 2) we
should have tools (e.g. a debugger) that enables us to access the data without
manually instrumenting our code.</p>

<p>Presently, Rubinius has a built-in debugger, precise method profiler, memory
analysis tool, and Agent interface that permits querying a running Rubinius
VM&ndash;even one running on a remote machine&ndash;for a variety of information.</p>

<p>We will be adding the ability to track the location where objects are
allocated to assist finding object leaks or code that is creating unusually
large numbers of objects. We are also working on a tool to graphically display
information like number of running threads, amount of CPU usage, and amount of
memory used while actively monitoring a VM.</p>

<p>I am also curious about correlating this VM information with external data to
enable play-back review.  For example, I would like to monitor RubySpec runs
and correlate which spec is running with the VM data. I imagine a simple
monotonic reference ID provided by the VM would be useful in correlating these
two otherwise unrelated pieces of data. The RubySpec runner would request the
ID before running each spec and the Agent monitor would request the ID when
gathering VM data. Later the two data sets could easily be merged.</p>

<p>When you find yourself manually instrumenting some code, consider what data
you are trying to get your hands on and let us know the scenario.  We&rsquo;ll
likely be able to build a tool that will open up new vistas into the behavior
of your Ruby programs.</p>

<h3 id="windowssupregsup">Windows<sup>&reg;</sup></h3>

<p>However one may feel about Windows as an operating system, it is undeniable
that the vast majority of people in the world use Windows. We believe those
people have an inalienable right to use Rubinius, too.</p>

<p>Thanks to the wonderful, hard-working
<a href="http://mingw-w64.sourceforge.net/">MinGW-w64</a> folks, we are able to compile
the Rubinius VM into a native Windows executable. Presently, the VM will
compile, link, and attempt to load the Ruby core library. More
platform-specific work is needed to load the library. The next step after that
will be getting the RubySpecs to run and start fixing issues.</p>

<p>Since the Windows work is being done on the hydra branch, the other features
discussed above will be available on Windows as soon as we complete them.</p>

<h3 id="multi-language-ualization">Multi-language-ualization</h3>

<p>The Rubinius VM began as an effort to create a modern, first-class environment
for running programs written in Ruby. However, it turns out that Ruby is a
terrific language for writing subsystems for other programming languages.
Actually, this should come as no surprise; Ruby is a fabulous general purpose
programming language.</p>

<p>To support experimenting with writing other languages that run on the Rubinius
VM, Evan has started to put together a Language Toolkit. This includes things
like a built-in PEG parser, convenient ways to create methods from Rubinius
bytecode, and decoupling method dispatch from Ruby semantics.</p>

<p>Hopefully, Evan will introduce us to all this in a future blog post, but
here is a taste of what you can do:</p>

<div class="highlight"><pre><code class="ruby"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">Hello</span>
<span class="lineno"> 2</span>   <span class="n">dynamic_method</span> <span class="ss">:world</span> <span class="k">do</span> <span class="o">|</span><span class="n">g</span><span class="o">|</span>
<span class="lineno"> 3</span>     <span class="n">g</span><span class="o">.</span><span class="n">push</span> <span class="ss">:self</span>
<span class="lineno"> 4</span>     <span class="n">g</span><span class="o">.</span><span class="n">push_literal</span> <span class="s2">&quot;Hello, world&quot;</span>
<span class="lineno"> 5</span>     <span class="n">g</span><span class="o">.</span><span class="n">send</span> <span class="ss">:puts</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kp">true</span>
<span class="lineno"> 6</span>     <span class="n">g</span><span class="o">.</span><span class="n">ret</span>
<span class="lineno"> 7</span>   <span class="k">end</span>
<span class="lineno"> 8</span> <span class="k">end</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="no">Hello</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">world</span>
</code></pre>
</div>

<p>Of course, that is much more concisely written in Ruby, but combine this
ability with a built-in PEG parser and you can be experimenting with your own
fascinating syntax in a matter of minutes.</p>

<p>Check out the Rubinius <a href="http://rubini.us/projects/">Projects page</a> for some of
these language experiments. One language in particular is
<a href="https://github.com/bakkdoor/fancy">Fancy</a>, which is fully bootstrapped (i.e.
the Fancy compiler is now written in Fancy) on Rubinius.</p>

<h3 id="documentation">Documentation</h3>

<p>One the one hand, Rubinius just runs Ruby code, and you shouldn&rsquo;t need any
special knowledge to run your application on Rubinius. On the other hand, as
I&rsquo;ve discussed above, there are some specific Rubinius features that may be
very helpful to you. However, they can only be as helpful as the documentation
we have for them.</p>

<p>Before we released 1.2.0 in December last year, I spent quite a bit of time
getting a new documentation system in place. Since then, we&rsquo;ve had
contributors help with translations to Russian, Polish, Spanish, and German.
Adam Gardiner started documenting the garbage collector algorithms. Yehuda
Katz (you may have heard the name) has contributed documentation for <a href="http://rubini.us/doc/en/bytecode-compiler/">the
bytecode compiler</a> complete with
diagrams!. Chuck Remes wrote up a great piece on the <a href="http://rubini.us/doc/en/tools/memory-analysis/">memory
analysis</a> tool.</p>

<p>We really appreciate these contributions. We understand the need for great
documentation and we have been creating better support for it. In many cases,
all that is needed is to just open a file and start writing. Of course, one
cannot expect to understand much about Rubinius without digging into the code.
If there is a particular part of Rubinius that you are curious about, jump in
the #rubinius channel on freenode.net and ask us questions. We can point you
in the right direction and help clarify things. If nothing else, let us know
which part of the missing documentation is most important to you and we can
start filling that in.</p>

<h3 id="how-you-can-help">How you can help</h3>

<p>There you have it, some super exciting things coming very soon for Rubinius
and for Ruby! We would love to have your help making Rubinius even better. The
most important thing you can do is try running your Ruby code. Give us
feedback. Let us know what features or tools would make your life easier. Help
us to build them.</p>

<p>Rubinius adopts Ruby&rsquo;s rosy view of the world. We want to empower you to solve
your hardest problems with Ruby, and have fun doing it.</p>

    </div>
  
    <div class="post">
      <h2 class="post_title">
        <a href="/2010/12/15/rubinius-has-a-blog/" title="Rubinius Has a Blog!" class="post_title">
        Rubinius Has a Blog!
        </a>
      </h2>
            <div class="by_line">
        <p><span class="author">Brian Ford</span>
          <span class="date">15 December 2010</span>
          
                      <a href="http://rubini.us/2010/12/15/rubinius-has-a-blog/#disqus_thread"
            data-disqus-identifier="/2010/12/15/rubinius-has-a-blog/"></a>

          
        </p>
      </div>

      <p>Many thought the day would never come, but Rubinius finally has a blog. That&rsquo;s
not all, though: We have integrated the website, blog, and documentation using
Jekyll. The source code for it all is in the main <a href="http://github.com/evanphx/rubinius">Rubinius
repository</a>.</p>

<p>People have often requested that we write more about the <em>awesome</em> features in
Rubinius. We hear you and we&rsquo;d love to do this. However, there is always a
trade-off between working on those awesome features and writing about them.
Until now, it&rsquo;s been rather painful to write docs or blog posts because we did
not have good infrastructure in place. Now, I think we do. I&rsquo;m sure there are
still a lot of improvements we can make, but we have a good place to start.
I&rsquo;d like to give a brief tour of our new system.</p>

<p>The primary goal was to improve collaboration and reduce friction for writing
new documentation and blog posts. That&rsquo;s right, improve collaboration. There
are many people who have experience developing Rubinius and running their
applications on it. We love how people have collaborated with source code
commits. Now anyone has the ability to write a blog post as well. I&rsquo;ve written
a basic <a href="/doc/en/how-to/write-a-blog-post/">How-To - Write a Blog Post</a>
document. If you have an idea for a blog post, just let us know. We will
exercise a bit of editorial control just to ensure the topics are appropriate
for Rubinius, but generally, we are thrilled to have your contributions.</p>

<p>Recently, we added the <code>rbx docs</code> command. This will run a web server on your
machine and open a browser window to display the Rubinius documentation. Now
the documentation will also be available at the <a href="http://rubini.us">rubini.us</a>
website. I have added a basic outline and a bunch of files to further simplify
the task of writing docs. In many cases, merely open a file and start writing
docs in <a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a> format.</p>

<p>We have also begun translating our documentation to other languages. I am
excited about this, being a huge language geek. I wish that I were proficient
in 10 languages so I could polish our documentation for the many people who
are not native English speakers. Alas, I only have a fair ability to write in
Spanish, so we are again depending on your help. I started the translation
effort by passing the existing English docs through Google translate. We have
a beginning guide for <a href="/doc/en/how-to/translate-documentation">How-To - Translate
Documentation</a>. I&rsquo;ve been told by
<em>kronos_vano</em> in our #rubinius IRC channel that he&rsquo;s already working on a
Russian translation. I personally would love to see Japanese and Chinese
translations.</p>

<p>So that&rsquo;s a brief introduction to our new infrastructure for documenting and
explaining Rubinius. It&rsquo;s been such a joy to see so many people contribute to
the Rubinius source code over the years. We hope that the blog, documentation,
and translations will further empower people to contribute and benefit from
the value that Rubinius has to offer the Ruby community.</p>

<p><em>¡Adelante!</em></p>

    </div>
  
  </div>

        <footer>
      <div class='container'>
        <nav>
          <ul>
            <li><a href="http://twitter.com/rubinius">Follow Rubinius on Twitter</a></li>
            <li><a href="http://github.com/evanphx/rubinius">Fork Rubinius on github</a></li>
            <li><a href="http://engineyard.com">An Engine Yard project</a></li>

            <li id='credit'>
              Site design by
              <a href="http://less.thanthree.com">Less Than Three</a>
            </li>
          </ul>
        </nav>
      </div>
    </footer>
        <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script>

        <script type="text/javascript">
        try {
        var pageTracker = _gat._getTracker("UA-12328521-1");
        pageTracker._trackPageview();
        } catch(err) {}</script>


    <script type="text/javascript">
        var disqus_shortname = 'rubinius';

        (function () {
            var s = document.createElement('script'); s.async = true;
            s.type = 'text/javascript';
            s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
  </body>

</html>
