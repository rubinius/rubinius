#!/usr/bin/env ruby

if ENV["RUBYLIB"]
  STDERR.puts "ERROR: Please unset RUBYLIB to configure Rubinius"
  exit 1
end

require './rakelib/configure'
require './rakelib/release'
require 'rbconfig'
require 'tempfile'
require 'fileutils'
require 'stringio'
require 'date'
require 'digest/md5'
require 'net/http'

root = File.expand_path File.dirname(__FILE__)

require File.join(root, "kernel", "delta", "options")

class Configure

  # Default settings only. All code that may depend on user-selected options
  # must run after options are processed.
  def initialize(root)
    @log = Logger.new "configure.log"

    @command_line = ARGV.dup
    @log.log "Command line: #{@command_line.join(" ").inspect}"

    @features = {}
    @defines = []
    @config = File.join(root, "config.rb")

    # Platform settings
    @host = `sh -c ./rakelib/config.guess`.chomp
    @cpu = nil
    @vendor = nil
    @os = nil
    @windows = nil
    @darwin = nil
    @bsd = nil
    @linux = nil
    @little_endian = false
    @sizeof = {}

    # Build tools
    @cc = nil
    @cxx = nil
    @rake = nil
    @tar = nil
    @perl = nil

    # Versions
    @language_version = "19"
    @supported_versions = ["18", "19", "20"]
    @build_ruby = nil

    # LLVM settings
    @use_llvm               = true
    @llvm                   = :no
    @llvm_path              = nil
    @llvm_configure         = nil
    @llvm_skip_system       = false
    @llvm_skip_prebuilt     = false
    @llvm_prebuilt_name     = nil
    @llvm_system_name       = get_system_name
    @llvm_shared            = false

    @llvm_version           = "3.2"
    @llvm_api_version       = 302
    @llvm_source            = "llvm-3.2.tgz"
    @llvm_source_dir        = "llvm-3.2.src"
    @llvm_source_url        = "http://llvm.org/releases/3.2/llvm-3.2.src.tar.gz"
    @llvm_asset_path        = "http://asset.rubini.us/prebuilt"
    @llvm_source_build      = false
    @llvm_generic_prebuilt  = nil
    @need_update_prebuilt   = false

    @llvm_parent_path       = File.join(root, "vendor")
    @llvm_default           = File.join(@llvm_parent_path, "llvm")
    @llvm_prebuilt_path     = File.join(@llvm_parent_path, "prebuilt")
    @llvm_include_path      = File.join(@llvm_default, "include")

    # System settings
    @libc         = nil
    @x86_32       = false
    @x86_64       = false
    @fibers       = false
    @dtrace       = false
    @have_lchmod  = false
    @have_lchown  = false
    @include_dirs = []
    @lib_dirs     = []

    # File system paths
    @sourcedir    = root
    @prefixdir    = nil
    @bindir       = nil
    @appdir       = nil
    @libdir       = nil
    @encdir       = nil
    @runtimedir   = nil
    @kerneldir    = nil
    @sitedir      = nil
    @vendordir    = nil
    @mandir       = nil
    @gemsdir      = nil
    @includedir   = nil

    @vm_release_h = root + "/vm/gen/release.h"
    @vm_version_h = root + "/vm/gen/version.h"

    @preserve_prefix = false

    @program_name = "rbx"
    @bin_links = ["rbx", "ruby", "rake", "gem", "irb", "rdoc", "ri"]
    @use_bin_links = true

    # Vendored library settings
    @vendored_libdir = root + "/vendor"

    # Library configuration
    @rb_readline = false

    # Essential settings (modify these for creating releases)
    @libversion = "2.0"
    @patch_version = "0"
    @release = validate_release_label
    @release_date = validate_release_date
    @config_version = 179
  end

  # Set up system commands to run in cmd.exe on Windows. Either Windows
  # or MRI on Windows has issues with subprocesses where the invocation
  # of the subprocess will return before the subprocess has finished.
  # This manifests in configure when uncompressing LLVM source returns
  # but attempting to move the directory fails sporadically with an access
  # exception. Adding the, essentially no-op, 'sleep 0' resolves this.
  def msys_system(cmd)
    old_system %[cmd.exe /C "#{cmd} && sleep 0"]
  end

  def msys_backquote(cmd)
    old_backquote %[cmd.exe /C "#{cmd}"]
  end

  def expand(path)
    File.expand_path(path)
  end

  def expand_install_dir(dir)
    dir = expand dir
    if !@preserve_prefix and File.directory?(dir) and dir !~ /(rubinius|rbx).*\/?$/
      original = dir
      dir += "/rubinius/#{@libversion}"
      @log.write "The directory #{original} already exists, installing to #{dir}"
    end
    dir
  end

  def set_host
    /([^-]+)-([^-]+)-(.*)/ =~ @host
    @cpu, @vendor, @os = $1, $2, $3

    # TODO: For better cross-compiling support, it may be necessary to
    # use the feature facility to check for a define in the compiler.
    @windows = (@host =~ /mingw|mswin/) != nil
    @darwin  = (@host =~ /darwin/) != nil
    @bsd     = (@host =~ /bsd/) != nil
    @linux   = (@host =~ /linux/) != nil
  end

  def set_system_commands
    # Set up system commands to run in cmd.exe on Windows.
    if @windows
      alias :old_system    :system
      alias :old_backquote :`
      alias :system        :msys_system
      alias :`             :msys_backquote
    end
  end

  def set_filesystem_paths
    @prefixdir = @prefixdir ? expand_install_dir(@prefixdir) : @sourcedir

    if @appdir
      dir = expand_install_dir @appdir

      @libdir     = dir + "/lib"
      @runtimedir = dir + "/runtime"
      @kerneldir  = dir + "/kernel"
      @sitedir    = dir + "/site"
      @vendordir  = dir + "/vendor"
    end

    @bindir       = @prefixdir + "/bin" unless @bindir
    @libdir       = @prefixdir + "/lib" unless @libdir
    @runtimedir   = @prefixdir + "/runtime" unless @runtimedir
    @kerneldir    = @prefixdir + "/kernel" unless @kerneldir
    @sitedir      = @prefixdir + "/site" unless @sitedir
    @vendordir    = @prefixdir + "/vendor" unless @vendordir
    @mandir       = @prefixdir + "/man" unless @mandir
    @gemsdir      = @prefixdir + "/gems" unless @gemsdir

    unless @includedir
      if @prefixdir == @sourcedir
        @includedir   = @prefixdir + "/vm/capi/#{@language_version}/include"
      else
        @includedir   = @prefixdir + "/vm/capi/include"
      end
    end

    if @prefixdir == @sourcedir
      @encdir = @libdir + "/#{@language_version}"
    else
      @encdir = @libdir
    end

    @encdir += "/encoding/converter"

    dirs = [@bindir, @libdir, @runtimedir, @kerneldir, @sitedir, @vendordir,
            @mandir, @gemsdir, @includedir, @encdir]

    parts = dirs.map { |d| d.split "/" }

    i = 0
    total = parts[0].size
    prefix = []

    while i < total
      part = parts[0][i]
      break unless parts.all? { |p| p[i] == part }
      prefix << part
      i += 1
    end

    @prefixdir = prefix.join "/"
    size = @prefixdir.size

    dirs.each { |d| d.replace d[size..-1] }

    unless @prefixdir == @sourcedir
      @stagingdir = "#{@sourcedir}/staging"
      FileUtils.rm_rf @stagingdir
      @stagingdir = File.join @stagingdir, @prefixdir if @preserve_prefix
    end
  end

  def options
    @options = Rubinius::Options.new "Usage: configure [options]", 30
    o = @options
    o.left_align

    o.doc " Configure settings"

    o.on "--log-file", "NAME", "Write log to file NAME" do |name|
      old_log = @log.path
      @log = Logger.new name, false
      @log.replace old_log
    end

    o.on "--rake", "NAME", "Use NAME as 'rake' during build" do |name|
      @rake = name
    end

    o.on "--tar", "NAME", "Use NAME as 'tar'" do |name|
      @tar = name
    end

    o.on "--perl", "NAME", "Use NAME as 'perl' during build" do |name|
      @perl = name
    end

    o.doc "\n Release Settings"

    o.on "--release", "LABEL", "Set release from { nightly, weekly, monthly, rcN, final }" do |label|
      @release = validate_release_label label
    end

    o.on "--release-date", "DATE", "Set release date to DATE in yyyy-mm-dd format" do |date|
      @release_date = validate_release_date date
    end

    o.doc "\n Language version settings"

    o.on "--enable-version", "VERSION", "Enable Ruby VERSION (supported 18, 19, 20)" do |v|
      @language_version = normalize_version v
    end

    o.doc "\n Compiler settings"

    o.on "--cc", "COMPILER", "Compiler to use for C code (eg gcc, clang)" do |cc|
      @cc = cc
    end

    o.on "--cxx", "COMPILER", "Compiler to use for C++ code (eg g++, clang++)" do |cxx|
      @cxx = cxx
    end

    o.doc "\n LLVM settings"

    o.on "--disable-llvm", "Don't build with LLVM" do
      @use_llvm = false
    end

    o.on "--enable-llvm", "Enable llvm (default)" do
      @use_llvm = true
    end

    o.on "--skip-system", "Don't consider a system LLVM installation" do
      @llvm_skip_system = true
    end

    o.on "--skip-prebuilt", "Don't try to use a prebuilt version of LLVM" do
      @llvm_skip_prebuilt = true
    end

    o.on "--system-name", "NAME", "Name of OS (eg fedora-8, ubuntu-10.04)" do |name|
      @llvm_system_name = name
    end

    o.on "--prebuilt-name", "NAME", "Full name of LLVM prebuilt archive" do |name|
      @llvm_prebuilt_name = name
    end

    o.on "--llvm-path", "PATH", "File system path to the directory containing LLVM" do |dir|
      @llvm_path = dir
    end

    o.on "--llvm-config", "PROGRAM", "File system path to the llvm-config program" do |program|
      @llvm_configure = program
    end

    o.on "--llvm-shared", "Link to shared LLVM library" do
      @llvm_shared = true
    end

    o.on "--update-prebuilt", "Update prebuilt LLVM packages from the internet" do
      @need_update_prebuilt = true
    end

    o.doc "\n System settings"

    o.on "--with-include-dir", "DIR", "Add DIR to the default include search paths" do |dir|
      dir.split(File::PATH_SEPARATOR).each do |d|
        @include_dirs << d
      end
    end

    o.on "--with-lib-dir", "DIR", "Add DIR to the default library search paths" do |dir|
      dir.split(File::PATH_SEPARATOR).each do |d|
        @lib_dirs << d
      end
    end

    o.on "--with-opt-dir", "DIR", "Add DIR/include and DIR/lib to include and library search paths" do |dir|
      dir.split(File::PATH_SEPARATOR).each do |d|
        @include_dirs << "#{d}/include"
        @lib_dirs     << "#{d}/lib" << "#{d}/lib64"
      end
    end

    o.on "--libc", "NAME", "Use NAME as the libc for FFI" do |name|
      @libc = name
    end

    o.on "--host", "HOST", "Override guessed platform with HOST specification" do |host|
      @log.write "------------------------------------------------------"
      @log.write "\nChanging the platform specification can cause Rubinius"
      @log.write "to malfunction. The current platform specification is:"
      @log.write "\n#{@host}"
      @log.write "\n------------------------------------------------------"

      @host = host
    end

    o.doc "\n Program names"

    o.on "--program-name", "NAME", "Build Rubinius executable as NAME" do |name|
      @program_name = name
    end

    o.on "--bin-link", "NAME", "Create NAME as binary symlink to program name" do |name|
      @bin_links << name
    end

    o.on "--no-bin-links", "Do not create any symlinks to program name" do
      @use_bin_links = false
    end

    o.doc "\n File system paths for installing Rubinius"

    o.on "-P", "--prefix", "PATH", "Install Rubinius in subdirectories of PATH" do |dir|
      warn_prefix dir
      @prefixdir = dir
    end

    o.on "-B", "--bindir", "PATH", "Install Rubinius executable in PATH" do |dir|
      @bindir = expand dir
    end

    o.on "-I", "--includedir", "PATH", "Install Rubinius C-API include files in PATH" do |dir|
      @includedir = expand dir
    end

    o.on "-A", "--appdir", "PATH", "Install Ruby runtime and libraries in PATH" do |dir|
      @appdir = dir
    end

    o.on "-L", "--libdir", "PATH", "Install Rubinius shared library in PATH" do |dir|
      @libdir = dir
    end

    o.on "-M", "--mandir", "PATH", "Install man pages in PATH" do |dir|
      @mandir = expand dir
    end

    o.on "-G", "--gemsdir", "PATH", "Install gems in PATH" do |dir|
      @gemsdir = expand dir
    end

    o.on "--sitedir", "PATH", "Install site-specific Ruby code in PATH" do |dir|
      @sitedir = expand dir
    end

    o.on "--vendordir", "PATH", "Install vendor-specific Ruby code in PATH" do |dir|
      @vendordir = expand dir
    end

    o.on "--preserve-prefix", "Use the configure prefix for staging Rubinius to install" do
      @preserve_prefix = true
    end

    o.doc "\n Optional features"

    feature "execinfo", true
    feature "C-readline", true
    feature "ruby-readline", false
    feature "vendor-zlib", false
    feature "vendor-yaml", false
    feature "alloc-tracking", false
    feature "fibers", true
    feature "dtrace", false

    o.doc "\n Help!"

    o.on "--show", "Print the current configuration and exit" do
      print_debug
      exit 0
    end

    o.on "-V", "--verbose", "Print additional info" do
      @verbose = true
    end

    o.help

    o.doc ""

  end

  def feature(name, default_value=true)
    @features[name] = ConfigurationToggle.new default_value

    @options.on "--with-#{name}", "Enable #{name}" do
      @features[name].configured = true
    end

    @options.on "--without-#{name}", "Disable #{name}" do
      @features[name].configured = false
    end
  end

  def parse(ary)
    @options.parse ary
  end

  def version
    version = "#{@libversion}.#{@patch_version}"
    version += ".#{@release}" if @release
    version
  end

  def normalize_version(str)
    version = str.gsub(/[^\d]/, "")
    unless @supported_versions.include? version
      failure <<-EOM
Unsupported language version requested: #{version}. Options are #{@supported_versions.join(", ")}
      EOM
    end
    version
  end

  def md5_checksum(md5_path, full_path)
    return Digest::MD5.file(full_path).hexdigest == File.read(md5_path).strip.split(" ").first
  end

  def download(url, full_path)
    begin
      dir = File.dirname full_path
      Dir.mkdir dir unless File.exists? dir

      if ENV['http_proxy']
        protocol, userinfo, host, port  = URI::split(ENV['http_proxy'])
        proxy_user, proxy_pass = userinfo.split(/:/) if userinfo
        http = Net::HTTP::Proxy(host, port, proxy_user, proxy_pass)
      else
        http = Net::HTTP
      end

      @log.write "    Downloading #{File.basename(full_path)}..."
      http.get_response(URI(url)) do |res|
        case res
        when Net::HTTPNotFound
          @log.write "      Not found."
          return false
        when Net::HTTPClientError
          @log.write "      ERROR: #{res.inspect}"
          return false
        end

        size = 0
        total = res.header['Content-Length'].to_i

        File.open full_path, "wb" do |f|
          res.read_body do |chunk|
            f << chunk
            size += chunk.size
            print "\r      [ %d%% (%d of %d) ]" % [(size * 100) / total, size, total]
          end
        end
        @log.write ": done!"
      end
    rescue Interrupt
      File.unlink full_path if File.exists?(full_path)
      raise
    rescue StandardError => e
      File.unlink full_path if File.exists?(full_path)
      @log.write " ERROR: #{e.message}"
      return false
    end

    return true
  end

  # Downloads a pre-built LLVM library for a platform if the file exists.  If
  # an MD5 checksum file exists for the library, the checksum of the library
  # is compared and the update fails if it does not match.  If no MD5 checksum
  # file exists, the library is used without check.
  def update_prebuilt(file, warn)
    full_path = File.join @llvm_prebuilt_path, file
    md5_path = "#{full_path}.md5"

    dir = File.dirname full_path
    Dir.mkdir dir unless File.exists? dir
    url = File.join @llvm_asset_path, file

    unless File.exists? full_path
      download url, full_path

      unless File.exists? full_path
        @log.write "ERROR. No #{file} available on server." if warn
        return false
      end
    end

    md5_url = "#{url}.md5"
    download md5_url, md5_path

    if File.exists? md5_path
      unless md5_checksum md5_path, full_path
        @log.write "ERROR. #{file} was corrupted or MD5 checksum is outdated."
        return false
      else
        @log.write "    MD5 checksum for prebuilt LLVM verified."
      end
    else
      @log.write "   No MD5 checksum for #{file} available on server."
      @log.write "   Using LLVM library without checksum validation."
    end

    @log.write "    Prebuilt packages updated."
  end

  def verify_llvm_source
    return false unless File.exists? @llvm_default

    if File.exists?(@llvm_include_path)
      @llvm = :svn
      @llvm_configure = llvm_config_cmd "#{@llvm_default}/Release/bin/llvm-config"
      return true
    else
      @log.write "  Code doesn't appear to be proper LLVM tree!"
      return false
    end
  end

  def setup_source
    @log.print "  Checking for existing LLVM source tree:"

    # Check if source already exists
    if verify_llvm_source
      @log.write " found!"
      return true
    else
      @log.write " not found."
    end

    url = @llvm_source_url
    path = File.join @llvm_prebuilt_path, @llvm_source

    unless File.exists?(path)
      @log.write "  Downloading #{url}..."
      return false unless download(url, path)
    end

    if File.exists?(path)
      @log.print "  Unpacking LLVM source: "
      Dir.chdir @llvm_parent_path do
        succeeded = system "#{@tar} xzf #{path}"
        unless succeeded
          @log.write "Error failed unpacking: #{path}"
          return false
        end

        FileUtils.mv @llvm_source_dir, "llvm"
      end
      @log.write "done!"

      if verify_llvm_source
        @log.write "  Code appears to be a proper tree."
        @llvm_source_build = true
        return true
      end
    end
  end

  def prebuilt_files
    files = [@llvm_generic_prebuilt]

    # If we have a system name, try to find a prebuilt specifically
    # for this system first.
    if @llvm_system_name
      files.unshift "llvm-#{@llvm_version}-#{@host}-#{@llvm_system_name}.tar.bz2"
    end

    # Try one for just the darwin major version (which increases for each
    # minor OS X version. ie. 10.5 == 9.x.x, 10.6 == 10.x.x)
    if m = /darwin(\d+)\.(\d+)\.(\d+)/.match(@os)
      # Try this last
      files.push "llvm-#{@llvm_version}-#{@cpu}-#{@vendor}-darwin#{m[1]}.tar.bz2"
    end

    # If the user specified a name, try that before anything.
    files.unshift @llvm_prebuilt_name if @llvm_prebuilt_name

    files
  end

  def setup_prebuilt
    @log.write "  Checking for prebuilt LLVM package..."

    prebuilt_files.each do |file|
      path = File.join @llvm_prebuilt_path, file

      update_prebuilt file, false unless File.exists?(path)

      if File.exists?(path)
        @log.print "  Unpacking prebuilt LLVM: #{file}: "
        dir = File.join @llvm_parent_path, "llvm"
        FileUtils.mkdir_p dir
        Dir.chdir dir do
          system "#{@tar} xjf #{path}"
        end
        @log.write "done!"
        @llvm = :prebuilt
        @llvm_configure = llvm_config_cmd "#{dir}/Release/bin/llvm-config"
        return true
      end
    end

    @log.write "  Unable to download any LLVM prebuilt"
    return false
  end

  def setup_path
    @log.print "Validating '#{@llvm_path}': "
    if File.directory? @llvm_path
      ["Release", "Debug", ""].each do |which|
        sub = File.join(@llvm_path, which, "bin")
        if File.directory? sub
          @log.write "Ok! Using #{which}"
          config = File.join(@llvm_path, which, "bin", "llvm-config")
          @llvm = :config
          @llvm_configure = llvm_config_cmd config
          return true
        end
      end

      @log.write "ERROR. Doesn't appear to be built already!"
      return false
    end

    @log.write "ERROR. Path doesn't exist."
    return false
  end

  def remove_default
    if File.exists?(File.join(@llvm_default, "Makefile.common"))
      failure "ABORT: Unwilling to override custom LLVM tree, please update it manually."
    else
      @log.write "    Removing outdated tree..."
      FileUtils.rm_rf(@llvm_default)
    end
  end

  def llvm_options_exist?
    !@llvm_skip_system and @llvm_configure
  end

  def setup_auto
    update_prebuilt @llvm_generic_prebuilt, true if @need_update_prebuilt

    @log.print "  Checking for existing LLVM library tree: "
    if File.directory?("#{@llvm_default}/Release") and
       not llvm_options_exist?
      config = llvm_config_cmd "#{@llvm_default}/Release/bin/llvm-config"
      version = `#{config} --version`.strip
      parts = version.sub(/svn$/, "").split(".").map { |i| i.to_i }
      api_version = ("%d%02d" % parts[0..1]).to_i
      if version >= "3.0"
        @log.write "found!"
        if File.exists?(File.join(@llvm_default, "Makefile.common"))
          @llvm = :svn
        else
          @llvm = :prebuilt
        end
        @llvm_version     = version
        @llvm_api_version = api_version
        @llvm_configure   = config
        return
      else
        @log.write "outdated (version #{version})"
        remove_default
      end
    else
      if llvm_options_exist?
        @log.write "skipping due to explicit LLVM options."
      else
        @log.write "not found."
      end
    end

    # If they explicitly said where LLVM is, use that and fail hard.
    if @llvm_path
      unless setup_path
        failure "ABORT: Path '#{@llvm_path}' not a proper LLVM path."
      end

      return
    end

    return if !@llvm_skip_system && setup_config
    return if !@llvm_skip_prebuilt && setup_prebuilt
    return if setup_source

    @log.write "WARNING: Unable to configure for LLVM, disabling support."
    @use_llvm = false
  end

  def setup_config
    @log.print "  Checking for 'llvm-config': "

    config = @llvm_configure
    if !config
      which = ENV['PATH'].split(":").find do |path|
        File.exists? File.join(path, "llvm-config")
      end
      if which
        config = File.join(which, "llvm-config")
      end
    end

    if config
      config_cmd = llvm_config_cmd config
      begin
        version = `#{config_cmd} --version`.strip

        # Ruby 1.8 returns an empty string
        failed = true if version.empty?
      rescue Errno::ENOENT
        # Ruby 1.9 raises this error
        failed = true
      end
      if failed
        @log.write "Executing #{config_cmd.inspect} failed"
        return false
      end

      parts = version.sub(/svn$/, "").split(".").map { |i| i.to_i }
      api_version = ("%d%02d" % parts[0..1]).to_i
      if api_version < 300
        @log.write "only LLVM 3.x is supported"
      else
        @log.write "found! (version #{version} - api: #{api_version})"
        @llvm = :config
        @llvm_configure = config_cmd
        @llvm_version = version
        @llvm_api_version = api_version
        return true
      end
    else
      @log.write "not found"
    end

    false
  end

  def env(which)
    ENV[which] || ""
  end

  def default_link_libs
    libs = []
    unless @host =~ /haiku/
      libs << "m"
    end
    libs
  end

  def failure(message=nil)
    message ||= "'configure' has failed."
    @log.error message

    STDERR.puts "\n#{message} Please check configure.log for more details."
    exit 1
  end

  def check_tools
    @cc ||= ENV['CC'] || 'gcc'
    @cxx ||= ENV['CXX'] || 'g++'

    check_tool_version @cc, '-dumpversion', [4, 1]
    check_tool_version @cxx, '-dumpversion', [4, 1]
    check_tool_version 'bison', '--version', [2, 3]

    @rake = ENV['RAKE'] || 'rake'
    @tar = ENV['TAR'] || (@windows ? 'bsdtar' : 'tar')
    @perl = ENV['PERL'] || 'perl'

    @gcc_major = `#{@cc} -dumpversion`.strip.split(".")[0,2].join(".")
    if @host == "i686-pc-linux-gnu" || @host == "x86_64-unknown-linux-gnu"
      @llvm_generic_prebuilt  = "llvm-#{@llvm_version}-#{@host}-#{@gcc_major}.tar.bz2"
    else
      @llvm_generic_prebuilt  = "llvm-#{@llvm_version}-#{@host}.tar.bz2"
    end

    @system_cflags =   ""
    @system_cxxflags = ""
    @system_cppflags = ""
    @system_ldflags =  ""

    @user_cflags =   ENV['CFLAGS']
    @user_cxxflags = ENV['CXXFLAGS']
    @user_cppflags = ENV['CPPFLAGS']
    @user_ldflags =  ENV['LDFLAGS']

    setup_platform
  end

  def setup_platform
    @ldsharedxx = "#{@cxx} -shared -lstdc++"
    @ldshared   = "#{@cc} -shared"
    @make       = "make"

    @include_dirs.each do |d|
      @system_cflags << "-I#{d} "
    end
    @lib_dirs.each do |d|
      @system_ldflags << "-L#{d} "
    end

    case RUBY_PLATFORM
    when /mswin/i, /mingw/i, /bccwin32/i
      # TODO: discovery helpers
      #check_heads(%w[windows.h winsock.h], true)
      #check_libs(%w[kernel32 rpcrt4 gdi32], true)

      unless RUBY_PLATFORM =~ /mingw/
        @system_cflags << "-EHs -GR"
      end
      @system_ldflags << "-lws2_32"
    when /solaris/i
      # GNU CHAIN only supported
      @ldsharedxx = "#{@cxx} -shared -G -fPIC -lstdc++"
      @ldshared   = "#{@cc} -shared -G -fPIC"
      @system_cflags << "-fPIC -Wno-strict-aliasing"
      @system_ldflags << "-lsocket -lnsl -fPIC"
      @make = "gmake"
    when /freebsd/i
      @ldsharedxx = "#{@cxx} -shared -lstdc++ -fPIC"
      @ldshared   = "#{@cc} -shared -fPIC"
      @system_cflags << "-fPIC"
      @system_ldflags << "-lcrypt -pthread -rdynamic"
      @lib_dirs.each do |d|
        @system_ldflags << " -Wl,-rpath=#{d}"
      end
      @make = "gmake"
    when /openbsd/i
      # OpenBSD branch contributed by Guillaume Sellier.

      # on Unix we need a g++ link, not gcc. On OpenBSD, linking against
      # libstdc++ have to be explicitly done for shared libs
      @ldsharedxx = "#{@cxx} -shared -lstdc++ -fPIC"
      @ldshared   = "#{@cc} -shared -fPIC"
      @system_cflags << "-fPIC"
      @system_ldflags << "-pthread -rdynamic -Wl,--export-dynamic"
      @lib_dirs.each do |d|
        @system_ldflags << " -Wl,-rpath=#{d}"
      end
      @make = "gmake"
    when /netbsd/i
      @ldsharedxx = "#{@cxx} -shared -lstdc++ -fPIC"
      @ldshared   = "#{@cc} -shared -fPIC"
      @system_cflags << "-fPIC"
      @system_ldflags << "-lcrypt -pthread -rdynamic -Wl,--export-dynamic"
      @lib_dirs.each do |d|
        @system_ldflags << " -Wl,-rpath=#{d}"
      end
      @make = "gmake"
    when /darwin/i
      # on Unix we need a g++ link, not gcc.
      # Ff line contributed by Daniel Harple.
      @ldsharedxx = "#{@cxx} -bundle -undefined suppress -flat_namespace -lstdc++"
      @ldshared   = "#{@cc} -bundle -undefined suppress -flat_namespace"
      @system_cflags << "-fPIC -D_DARWIN_USE_64_BIT_INODE"
    when /haiku/i
      @system_cflags << "-fPIC"
      @system_ldflags << "-ldl -lnetwork"
    when /aix/i
      @ldsharedxx = "#{@cxx} -shared -Wl,-G -Wl,-brtl"
      @ldshared   = "#{@cc} -shared -Wl,-G -Wl,-brtl"
    when /linux/i
      @system_cflags << "-fPIC"
      @system_ldflags << "-Wl,--export-dynamic -lrt -lcrypt -ldl -lpthread"
      @lib_dirs.each do |d|
        @system_ldflags << " -Wl,-rpath=#{d}"
      end
    else
      # on Unix we need a g++ link, not gcc.
      @system_cflags << "-fPIC"
      @system_ldflags << "-ldl -lpthread"
    end

  end

  def check_program(run=true, link_libs=[])
    begin
      basename = "rbx-configure-test"
      source   = basename + ".cpp"
      File.open source, "wb" do |f|
        yield f
      end

      File.open source, "rb" do |f|
        @log.log f.read
      end

      libs = (default_link_libs + link_libs).map { |l| "-l#{l}" }.join(" ")

      cmd = "#{@cxx} #{@user_cppflags} #{@user_cflags} #{@user_cxxflags} #{@user_ldflags} -o #{basename} #{source} #{@system_cppflags} #{@system_cflags} #{@system_cxxflags} #{@system_ldflags} -lstdc++ #{libs} >>#{@log.path} 2>&1"
      @log.log cmd
      system cmd
      return $?.exitstatus unless run

      unless $?.exitstatus == 0
        failure "Compiling configure test program failed."
      end

      system expand("./#{basename}")
      return $?.exitstatus
    ensure
      File.delete(*Dir["#{basename}*"])
    end
  end

  def write_have_defines(f)
    f.puts
    @defines.each { |d| f.puts "#define #{d.ljust(20)} 1" }
  end

  def write_have_sizeof_defines(f)
    f.puts
    @sizeof.keys.sort.each { |k| f.puts "#define HAVE_#{k}".ljust(30) + "1" }
  end

  def write_sizeof_defines(f)
    f.puts
    @sizeof.keys.sort.each { |k| f.puts "#define SIZEOF_#{k}".ljust(30) + @sizeof[k].to_s }
  end

  def sizeof_typename(type)
    if type =~ /(\*+)$/
      name = "#{type[0...-$1.size]}#{"p" * $1.size}"
    else
      name = type
    end
    name.gsub(/\W/, "_").upcase
  end

  def sizeof(type)
    @sizeof[sizeof_typename(type)] or failure("Unknown type: '#{type}'.")
  end

  def detect_sizeof(type, includes=[])
    @log.print "Checking sizeof(#{type}): "

    size = check_program do |f|
      src = includes.map { |include| "#include <#{include}>" }.join("\n")
      src += <<-EOP
#include <stddef.h>

int main() { return sizeof(#{type}); }
      EOP
      f.puts src
      @log.log src
    end

    @sizeof[sizeof_typename(type)] = size

    @log.write "#{size} bytes"
  end

  def detect_endian
    @log.print "Checking platform endianness: "

    status = check_program do |f|
      src = "int main() { int one = 1; return (*((char*)&one)) == 1 ? 0 : 1; }"
      f.puts src
      @log.log src
    end

    @little_endian = (status == 0)
    @log.write @little_endian ? "little endian" : "big endian"
  end

  def detect_tr1
    @log.print "Checking for tr1: "

    status = check_program(false) do |f|
      src = <<-EOP
#include <tr1/unordered_map>

typedef std::tr1::unordered_map<int, void*> X;

int main() { X x; return 0; }
      EOP
      f.puts src
      @log.log src
    end

    @tr1 = (status == 0)
    @log.write @tr1 ? "found" : "not found"
  end

  def detect_tr1_hash
    @log.print "Checking for tr1/hash definition: "

    status = check_program(false) do |f|
      src = <<-EOP
#include <stdint.h>
#include <tr1/unordered_map>

typedef std::tr1::unordered_map<uint64_t, void*> X;

int main() { X x; return 0; }
      EOP
      f.puts src
      @log.log src
    end

    @tr1_hash = (status == 0)
    @log.write @tr1_hash ? "found" : "not found"
  end

  def detect_x86
    print "Checking for x86_32: "

    if sizeof("long") == 4
      status = check_program do |f|
        src = <<-EOP
int main() {
#if defined(i386) || defined(__i386__) || defined(__i386)
  return 1;
#else
  return 0;
#endif
}
        EOP

        f.puts src
        @log.log src
      end
      @x86_32 = (status == 1)
    end

    puts @x86_32 ? "yes" : "no"

    return if @x86_32

    print "Checking for x86_64: "

    status = check_program do |f|
      src = <<-EOP
int main() {
#if defined(__x86_64) || defined(__x86_64__)
return 1;
#else
return 0;
#endif
}
      EOP

      f.puts src
      @log.log src
    end
    @x86_64 = (status == 1)

    puts @x86_64 ? "yes" : "no"
  end

  def detect_curses
    @log.print "Checking curses library: "

    src = <<-EOP
#include <curses.h>
#include <term.h>

int main() { return tgetnum(""); }
    EOP

    ["curses", "ncurses", "termcap"].each do |lib|
      status = check_program(false, [lib]) do |f|
        f.puts src
        @log.log src
      end

      if status == 0
        @curses = lib
        break
      end
    end

    if @curses
      @log.write(@curses)
    else
      @log.write("using rb-readline")
      @rb_readline = true
    end
  end

  def detect_build_dirs
    ["/usr/local", "/opt/local", "/usr/pkg"].each do |dir|
      @include_dirs << "#{dir}/include"
      @lib_dirs     << "#{dir}/lib" << "#{dir}/lib64"
    end

    @include_dirs = @include_dirs.select {|p| File.directory? p }
    @lib_dirs = @lib_dirs.select {|p| File.directory? p }
  end

  def has_struct_member(struct, member, includes = [])
    compile_check "struct #{struct} has member #{member}" do |src|
      includes.each do |i|
        src.puts "#include <#{i}>"
      end

      src.puts "int main() { struct #{struct} st; st.#{member}; }"
    end
  end

  def has_global(name, includes=[])
    compile_check "global '#{name}'" do |src|
      includes.each do |i|
        src.puts "#include <#{i}>"
      end
      src.puts "int main() { #{name}; }"
    end
  end

  def has_header(name)
    compile_check "header '#{name}'" do |src|
      src.puts "#include <#{name}>"
      src.puts "int main() {return 0;}"
    end
  end

  def has_function(name, includes=[], defines = [])
    compile_check "function '#{name}'", defines do |src|
      includes.each do |i|
        src.puts "#include <#{i}>"
      end
      src.puts "int main() { void* ptr = &#{name}; }"
    end
  end

  def has_library(name, function, libraries, includes=[])
    @log.print "Checking for library: #{name}: "

    status = check_program true, libraries do |src|
      includes.each do |i|
        src.puts "#include <#{i}>"
      end
      src.puts "int main() { void* ptr = (void*)(&#{function}); return 0; }"
    end

    success = status == 0
    @log.write(success ? "found!" : "not found!")
    success
  end

  def has_dtrace
    @log.print "Checking for dtrace: "

    begin
      basename = "rbx-configure-dtrace-test"
      source   = basename + ".d"
      File.open source, "wb" do |f|
        f.write "provider conftest{ probe fire(); };"
      end

      cmd = "dtrace -h -o #{basename}.h -s #{source}"
      @log.log cmd
      system cmd
      @dtrace = $?.exitstatus == 0
      puts @dtrace ? "yes" : "no"
      @dtrace
    ensure
      File.delete(*Dir["#{basename}*"])
    end
  end

  def compile_check(logpart, defines = [], &block)
    @log.print "Checking for #{logpart}: "

    source = StringIO.new
    yield source
    file = Tempfile.new("rbx-test")

    source.rewind
    string = source.read

    file.puts string
    file.close

    @log.log string

    cmd = "#{@cxx} -S -o - -x c #{defines.join(" ")} #{@user_cppflags} #{@user_cxxflags} #{@user_cflags} #{@user_ldflags} #{@system_cppflags} #{@system_cxxflags} #{@system_cflags} #{@system_ldflags} #{file.path} >>#{@log.path} 2>&1"
    @log.log cmd
    system cmd

    status = ($?.exitstatus == 0)
    file.unlink

    @log.write(status ? "found!" : "not found")
    status
  end

  def enable_features
    if @features["vendor-zlib"].value
      # Our vendored zlib uses long as the crc_table type
      # If we update vendored zlib in the future, we have to
      # review this and make sure we update it properly to
      # match the newer version which like will have uint32_t
      # as the type.
      @include_dirs << "#{@vendored_libdir}/zlib"
      @lib_dirs     << "#{@vendored_libdir}/zlib"
    end

    if @features["vendor-yaml"].value
      @include_dirs << "#{@vendored_libdir}/libyaml/include"
      @lib_dirs     << "#{@vendored_libdir}/libyaml/src/.libs"
    end
  end

  def detect_features
    # Default on *BSD is no execinfo
    if RUBY_PLATFORM =~ /bsd/i and @features["execinfo"].configured.nil?
      @features["execinfo"].configured = false
    end

    if @features["execinfo"].value and has_function("backtrace", ["execinfo.h"])
      @defines << "HAS_EXECINFO"
    end

    if @features["alloc-tracking"].value
      @defines << "RBX_ALLOC_TRACKING"
    end

    if @features["ruby-readline"].value
      @rb_readline = true
    else
      if @features["C-readline"].value and
          (has_function("readline", ["stdio.h", "stdlib.h", "readline/readline.h"]) or
           has_function("readline", ["stdio.h", "stdlib.h", "editline/readline.h"]))
        @rb_readline = false
      else
        @rb_readline = true
      end
    end

    if @features["fibers"].value
      @fibers = true if @x86_32 or @x86_64
    end

    if @features["dtrace"].value and has_dtrace
      @defines << "HAVE_DTRACE"
    end

    # Default on Windows is vendor-zlib
    if @windows and @features["vendor-zlib"].configured.nil?
      @features["vendor-zlib"].configured = true
    end

    @defines << "HAVE_SPT_REUSEARGV" if @linux || @darwin || @bsd
  end

  def detect_libraries
    if @language_version == "19" or @language_version == "20"
      unless has_library("libyaml", "yaml_parser_initialize", ["yaml"], ["yaml.h"])
        failure "libyaml is required for 1.9 and above"
      end
    end
  end

  def detect_functions
    if has_function("clock_gettime", ["time.h"])
      @defines << "HAVE_CLOCK_GETTIME"
    end

    if has_function("nl_langinfo", ["langinfo.h"])
      @defines << "HAVE_NL_LANGINFO"
    end

    if has_function("setproctitle", ["sys/types.h", "unistd.h"])
      @defines << "HAVE_SETPROCTITLE"
    end

    if has_function("posix_fadvise", ["fcntl.h"])
      @defines << "HAVE_POSIX_FADVISE"
    end

    if has_function("lchmod", ["sys/stat.h", "unistd.h"], ["-D_XOPEN_SOURCE", "-D_XOPEN_SOURCE_EXTENDED"])
      @have_lchmod = true
    end

    if has_function("lchown", ["sys/stat.h", "unistd.h"], ["-D_XOPEN_SOURCE", "-D_XOPEN_SOURCE_EXTENDED"])
      @have_lchown = true
    end
  end

  def detect_structures
    if has_struct_member("tm", "tm_gmtoff", ["time.h"])
      @defines << "HAVE_TM_GMTOFF"
    end

    if has_struct_member("tm", "tm_zone", ["time.h"])
      @defines << "HAVE_TM_ZONE"
    end
  end

  def detect_globals
    if has_global("timezone", ["time.h"])
      @defines << "HAVE_TIMEZONE"
    end

    if has_global("tzname", ["time.h"])
      @defines << "HAVE_TZNAME"
    end

    if has_global("daylight", ["time.h"])
      @defines << "HAVE_DAYLIGHT"
    end
  end

  def detect_headers
    unless @features["vendor-zlib"].value
      unless has_header("zlib.h")
        failure "zlib.h is required"
      end
    end

    unless has_header("openssl/ssl.h")
      failure "openssl/ssl.h is required"
    end

    if has_header("alloca.h")
      @defines << "HAVE_ALLOCA_H"
    end

    if has_header("string.h")
      @defines << "HAVE_STRING_H"
    end

    if has_header("sys/time.h")
      @defines << "HAVE_SYS_TIME_H"
    end

    if has_header("sys/times.h")
      @defines << "HAVE_SYS_TIMES_H"
    end

    if has_header("sys/types.h")
      @defines << "HAVE_SYS_TYPES_H"
    end

    if has_header("unistd.h")
      @defines << "HAVE_UNISTD_H"
    end

    if has_header("stdarg.h")
      @defines << "HAVE_STDARG_H"
    end

    if has_header("sys/pstat.h")
      @defines << "HAVE_SYS_PSTAT_H"
    end

    if has_header("valgrind/valgrind.h")
      @defines << "HAVE_VALGRIND_H"
    end
  end

  def strerror_r_returns_char_pointer
    status = check_program(false) do |src|
      src.puts "#include <string.h>"
      src.puts "int main() { char buf[1024]; static_cast<char*>(strerror_r(42, buf, 1024)); }"
    end
    status == 0
  end

  def detect_strerror
    @log.print "Checking if function 'strerror_r' returns char*: "
    if strerror_r_returns_char_pointer
      @defines << "STRERROR_R_CHAR_P"
      @log.write "yes"
    else
      @log.write "no"
    end
  end

  def warn_prefix(dir)
    delimiter = "-------------------------%s-----------------------"

    if File.file? dir
      @log.write delimiter % " ERROR "
      @log.write "The specified prefix '#{dir}' is a regular file."
      @log.write "Remove the file or specify a different prefix."
      @log.write delimiter % "-------"
      exit 1
    elsif File.directory? dir
      @log.write delimiter % " WARNING "
      @log.write "The specified prefix '#{dir}' already exists."
      @log.write "Installing Rubinius into an existing directory may"
      @log.write "overwrite existing unrelated files or cause conflicts"
      @log.write "between different versions of Rubinius files."
      @log.write delimiter % "---------"
      sleep 2
    end
  end

  def process
    set_host
    set_system_commands

    enable_features
    detect_build_dirs

    check_tools

    if @use_llvm
      @log.write "Configuring LLVM..."
      setup_auto
    else
      @log.write "WARNING: LLVM disabled."
    end

    @log.write ""

    detect_sizeof("short")
    detect_sizeof("int")
    detect_sizeof("void*")
    detect_sizeof("size_t")
    detect_sizeof("long")
    detect_sizeof("long long")
    detect_sizeof("float")
    detect_sizeof("double")
    detect_sizeof("off_t", ["unistd.h"])
    detect_sizeof("time_t", ["time.h"])

    detect_libc_name

    detect_endian
    detect_tr1
    detect_tr1_hash
    detect_x86
    detect_features
    detect_libraries
    detect_functions
    detect_structures
    detect_globals
    detect_headers
    detect_curses
    detect_strerror
 end

  def which_ruby
    if Object.const_defined?(:RUBY_ENGINE)
      @which_ruby = RUBY_ENGINE.to_sym
    else
      @which_ruby = :ruby
    end
  end

  # Records the full path to the ruby executable that runs this configure
  # script. That path will be made available to the rest of the build system
  # so the same version of ruby is invoked as needed.
  def build_ruby
    unless @build_ruby
      bin = RbConfig::CONFIG["RUBY_INSTALL_NAME"] || RbConfig::CONFIG["ruby_install_name"]
      bin += (RbConfig::CONFIG['EXEEXT'] || RbConfig::CONFIG['exeext'] || '')
      @build_ruby = File.join(RbConfig::CONFIG['bindir'], bin)
    end
    @build_ruby
  end

  # Checks whether the given config file is a Perl script by checking its first
  # line for a Perl hashbang.
  def llvm_config_cmd(config)
    begin
      File.open(config, "r") do |f|
        first_line = f.readline
        if first_line =~ /^#! ?\/usr(\/local)?\/bin\/(env )?perl/
          "#{@perl} #{config}"
        else
          config
        end
      end
    rescue Errno::ENOENT, ArgumentError
      # The file doesn't exist (ENOENT) or it's a binary file (ArgumentError).
      config
    end
  end

  def get_system_name
    return unless @os =~ /linux/
    return unless File.exists? "/etc/issue"

    data = IO.readlines("/etc/issue").first
    data =~ /([^ ]+)[^\d\.]*([\d\.]*)/

    name = $1.downcase
    version = $2

    if name == "debian" and File.exists? "/etc/debian_version"
      version = IO.read("/etc/debian_version").split.first.gsub(/\W/, "-")
    end

    return "#{name}-#{version}"
  end

  def check_tool_version(tool_name, opts, version, regexp=/(?=\d)(\d+).(\d+).?(\d+)?/)
    @log.print "Checking #{tool_name}:"

    output = `#{tool_name} #{opts}`

    if $?.exitstatus == 0
      v = output.scan(regexp)[0].map { |x| x.to_i }
      unless (v <=> version) >= 0
        failure " Expected #{tool_name} version >= #{version.join('.')}, found #{v.join('.')}"
      end
      @log.write " found"
    else
      failure "#{tool_name} not found."
    end
  end

  def detect_libc_name
    return if @libc

    @log.print "Checking for libc version: "

    case
    when @windows
      @libc = "msvcrt.dll"
    when @darwin
      @libc = "libc.dylib"
    else
      begin
        ldd_output = `ldd #{build_ruby}`

        @libc = ldd_output[/libc\.so\.[0-9]+/]
      rescue
        # Don't abort if the command is not found
      end

      unless $?.success? and @libc
        failure "libc not found. Use the --libc configure option."
      end
    end

    @log.write "#{@libc} found!"
  end

  def write_configure_files
    unless @use_llvm
      @llvm = :no
      @llvm_configure = ""
    end

    @bin_links.delete @program_name

    config_settings = {
      :command_line       => @command_line,
      :config_file        => @config,
      :which_ruby         => which_ruby,
      :build_ruby         => build_ruby,
      :build_rake         => @rake,
      :build_perl         => @perl,
      :llvm               => @llvm,
      :llvm_configure     => @llvm_configure,
      :llvm_version       => @llvm_version,
      :llvm_shared        => @llvm_shared,
      :cc                 => @cc,
      :cxx                => @cxx,
      :ldshared           => @ldshared,
      :ldsharedxx         => @ldsharedxx,
      :gcc_major          => @gcc_major,
      :user_cflags        => "#{@user_cflags}",
      :user_cxxflags      => "#{@user_cxxflags}",
      :user_cppflags      => "#{@user_cppflags}",
      :user_ldflags       => "#{@user_ldflags}",
      :system_cflags      => "#{@system_cflags}",
      :system_cxxflags    => "#{@system_cxxflags}",
      :system_cppflags    => "#{@system_cppflags}",
      :system_ldflags     => "#{@system_ldflags}",
      :make               => @make,
      :include_dirs       => @include_dirs,
      :lib_dirs           => @lib_dirs,
      :defines            => @defines,
      :curses             => @curses,
      :host               => @host,
      :cpu                => @cpu,
      :vendor             => @vendor,
      :os                 => @os,
      :little_endian      => @little_endian,
      :sizeof_long        => sizeof("long"),
      :x86_32             => @x86_32,
      :x86_64             => @x86_64,
      :dtrace             => @dtrace,
      :fibers             => @fibers,
      :sourcedir          => @sourcedir,
      :stagingdir         => @stagingdir,
      :prefixdir          => @prefixdir,
      :bindir             => @bindir,
      :libdir             => @libdir,
      :encdir             => @encdir,
      :runtimedir         => @runtimedir,
      :kerneldir          => @kerneldir,
      :sitedir            => @sitedir,
      :vendordir          => @vendordir,
      :includedir         => @includedir,
      :mandir             => @mandir,
      :gemsdir            => @gemsdir,
      :program_name       => @program_name,
      :bin_links          => @bin_links,
      :use_bin_links      => @use_bin_links,
      :version            => version,
      :patch_version      => @patch_version,
      :libversion         => @libversion,
      :release            => @release,
      :release_date       => @release_date,
      :revision           => read_revision,
      :config_version     => @config_version,
      :windows            => @windows,
      :darwin             => @darwin,
      :bsd                => @bsd,
      :linux              => @linux,
      :vendor_zlib        => @features["vendor-zlib"].value,
      :vendor_yaml        => @features["vendor-yaml"].value,
      :readline           => @rb_readline ? :rb_readline : :c_readline,
      :vm_release_h       => @vm_release_h,
      :vm_version_h       => @vm_version_h,
      :language_version   => @language_version,
      :supported_versions => @supported_versions
    }

    write_config_rb @config, config_settings

    Dir.mkdir "lib/rubinius" unless File.directory? "lib/rubinius"
    FileUtils.cp @config, "lib/rubinius/build_config.rb"

    # Write the config file used to build the C++ VM.
    Dir.mkdir "vm/gen" unless File.directory? "vm/gen"

    vm_paths_h = "vm/gen/paths.h"
    File.open vm_paths_h, "wb" do |f|
      f.puts <<-EOF
#define RBX_PREFIX_PATH      "#{@prefixdir}"
#define RBX_BIN_PATH         "#{@bindir}"
#define RBX_GEMS_PATH        "#{@gemsdir}"
#define RBX_RUNTIME_PATH     "#{@runtimedir}"
#define RBX_KERNEL_PATH      "#{@kerneldir}"
#define RBX_LIB_PATH         "#{@libdir}"
#define RBX_ENC_PATH         "#{@encdir}"
#define RBX_HDR_PATH         "#{@includedir}"
#define RBX_VENDOR_PATH      "#{@vendordir}"
      EOF
    end

    vm_config_h = "vm/gen/config.h"
    File.open vm_config_h, "wb" do |f|
      f.puts <<-EOC
#define RBX_HOST             "#{@host}"
#define RBX_CPU              "#{@cpu}"
#define RBX_VENDOR           "#{@vendor}"
#define RBX_OS               "#{@os}"
#define RBX_LIB_VERSION      "#{@libversion}"
#define RBX_LDSHARED         "#{@ldshared}"
#define RBX_LDSHAREDXX       "#{@ldsharedxx}"
#define RBX_SIZEOF_LONG      #{sizeof("long")}
#define RBX_LLVM_API_VER     #{@llvm_api_version}
#define RBX_LIBC             "#{@libc}"
#define RBX_HAVE_LCHMOD      #{@have_lchmod}
#define RBX_HAVE_LCHOWN      #{@have_lchown}
      EOC

      if @little_endian
        f.puts "#define RBX_LITTLE_ENDIAN    1"
      end

      if @tr1
        f.puts "#define RBX_HAVE_TR1         1"
      end

      if @tr1_hash
        f.puts "#define RBX_HAVE_TR1_HASH    1"
      end

      [:windows, :darwin, :bsd, :linux].each do |platform|
        if instance_variable_get(:"@#{platform}")
          f.puts "#define RBX_#{platform.to_s.upcase}           1"
        end
      end

      if @fibers
        f.puts "#define RBX_FIBER_ENABLED    1"
      end

      write_have_defines f
    end

    vm_capi_header_gen = "vm/capi/#{@language_version}/include/gen"
    FileUtils.mkdir_p vm_capi_header_gen

    FileUtils.cp vm_config_h, "#{vm_capi_header_gen}/rbx_config.h"

    # Write the config file for vendor/oniguruma.
    File.open "vendor/oniguruma/config.h", "wb" do |f|
      f.puts <<-EOC
/* This file is generated by the Rubinius build system. Your edits
 * will be lost. See the configure script.
 */
      EOC

      write_have_defines f
      write_have_sizeof_defines f
      write_sizeof_defines f
    end

    # Write the config file used in the C-API.
    config_h = "vm/capi/config.h"
    File.open config_h, "wb" do |f|
      f.puts <<-EOC
/* This file is generated by the build system. Your edits
 * will be lost. See the configure script.
 */

#ifndef NORETURN
#define NORETURN(x) __attribute__ ((noreturn)) x
#endif

#ifndef UNREACHABLE
#define UNREACHABLE __builtin_unreachable()
#endif

      EOC

      write_have_defines f
      write_have_sizeof_defines f
      write_sizeof_defines f

      if @windows
        f.puts "#define RBX_WINDOWS 1"
      end
    end

    FileUtils.cp config_h, "vm/capi/18/include/config.h"
    FileUtils.cp config_h, "vm/capi/19/include/ruby/config.h"
    FileUtils.cp config_h, "vm/capi/20/include/ruby/config.h"

    # Copy definitions for the MRI Object-Oriented Pointer (OOP) definitions.
    mri_oop_h = "vm/capi/mri_oop.h"
    FileUtils.cp mri_oop_h, "vm/capi/18/include/mri_oop.h"
    FileUtils.cp mri_oop_h, "vm/capi/19/include/ruby/mri_oop.h"
    FileUtils.cp mri_oop_h, "vm/capi/20/include/ruby/mri_oop.h"

    # Copy definitions for the C-Api constants
    capi_constants_h = "vm/capi/capi_constants.h"
    FileUtils.cp capi_constants_h, "vm/capi/18/include/capi_constants.h"
    FileUtils.cp capi_constants_h, "vm/capi/19/include/ruby/capi_constants.h"
    FileUtils.cp capi_constants_h, "vm/capi/20/include/ruby/capi_constants.h"

    # Write a require file depending on which Readline library we use.
    File.open "lib/readline.rb", "wb" do |f|
      if @rb_readline
        f.puts "require 'rb-readline/readline'"
      else
        f.puts "require 'c-readline'"
      end
    end
  end

  def print_debug
    puts "\nUsing the following configuration to build"
    puts "------------------------------------------"
    cat("config.rb")
    puts "\nSetting the following defines for the VM"
    puts "----------------------------------------"
    cat("vm/gen/config.h")
  end

  def cat(file)
    puts IO.read(relative_file(file))
  end

  def relative_file(name)
    File.expand_path("../#{name}", __FILE__)
  end

  def check_force_clean
    if Rubinius::BUILD_CONFIG[:config_version] != @config_version
      @log.write "\nDetected old configuration settings, forcing a clean build"
      system("#{build_ruby} -S #{@rake} clean")
    end
  end

  def run
    unless which_ruby == :ruby or which_ruby == :rbx
      failure "Sorry, building Rubinius requires MRI or Rubinius."
    end

    if File.exists? @config
      begin
        load @config
        verify_config = true
      rescue Object
        # ignore errors
      end
    end

    options
    parse ARGV

    set_filesystem_paths

    if File.join(@bindir, @program_name) == build_ruby
      @log.error "\nYou are attempting to build using the instance of Rubinius that you are building.\n\n"

      @log.error "To resolve this issue:"
      if ENV['PATH'] =~ /#{@bindir}/
        @log.error "  * Remove '#{@bindir}' from your PATH."
      end

      failure "  * Use a Ruby executable other than '#{build_ruby}' to build."
    end

    process
    write_configure_files
    record_revision
    write_release @vm_release_h, version, @release_date, read_revision
    write_version @vm_version_h, @language_version, @supported_versions

    check_force_clean if verify_config

    print_debug if @verbose

    if @llvm_source_build
      files = prebuilt_files.map { |f| File.basename f, ".tar.bz2" }.join("\n  ")

      @log.write <<-EOM

------------------------------------------------------------------
Unable to find an existing binary build of LLVM for your platform.

Please notify the Rubinius team at the #rubinius channel on
irc.freenode.net and provide the following system information:

  prebuilts:

  #{files}
------------------------------------------------------------------
      EOM
    end

    unless @stagingdir
      build_msg = <<-EOM
Rubinius has been configured.

Run 'rake' to build and test Rubinius.
      EOM
    else
      build_msg = <<-EOM
Rubinius has been configured for the following paths:

prefix:  #{@prefixdir}
bin:     #{@bindir}
lib:     #{@libdir}
runtime: #{@runtimedir}
kernel:  #{@kerneldir}
site:    #{@sitedir}
vendor:  #{@vendordir}
man:     #{@mandir}
gems:    #{@gemsdir}
include: #{@includedir}

Run 'rake' to build, test and install Rubinius.
      EOM
    end

    links = (@bin_links + [@program_name]).uniq

    @log.write <<-EOM
------------------------------------------------------------------

#{build_msg}
After building, you may add

'#{@prefixdir}#{@bindir}'

to your PATH or run commands directly from that directory.

Available commands are:

  #{links.join(", ")}

------------------------------------------------------------------
    EOM
  end


  # Configuration item that has both a default and a configured value
  class ConfigurationToggle
    attr_reader :default, :configured

    def initialize(default_value)
      @default = !!default_value
      @configured = nil
    end

    def configured=(value)
      @configured = !!value
    end

    def value
      unless @configured.nil?
        @configured
      else
        @default
      end
    end
  end

  # Handles user output and logging while running configure.
  class Logger
    attr_reader :path

    # Creates an instance of Logger writing to +file+.
    def initialize(file, init=true)
      @path = File.expand_path("../#{file}", __FILE__)
      if init
        File.open(@path, "wb") { }
        log "Configuring Rubinius..."
      end
    end

    # Copies the contents of +other+ into this logger's file.
    def replace(other)
      output do |f|
        f.puts File.read(other)
      end
    end

    # Writes +message+ to the logging file but not to the screen.
    def log(message, error=false)
      output do |f|
        stamp = "#{timestamp}#{'*** ERROR' if error}"
        if multiline?(message)
          f.puts "#{stamp} ---"
          f.puts message
          f.puts "---"
        else
          f.puts "#{stamp} #{message}"
        end
      end
    end

    # Writes a normal message to STDOUT and logs to the file.
    def write(message)
      log message
      STDOUT.puts message
    end

    # Writes a normal message to STDOUT with #print and logs to file.
    def print(message)
      log message
      STDOUT.print message
    end

    # Writes an error message to STDERR and logs to the file with
    # error decorations. This should only be used for errors that
    # affect configure itself.
    def error(message)
      log message, true
      STDERR.puts message
    end

    # Yields an IO for writing log messages.
    def output
      File.open @path, "a" do |f|
        yield f
      end
    end

    # Returns a formatted times suitable for logging.
    def timestamp
      Time.now.strftime "[%Y-%m-%d %H:%M:%S]"
    end

    # Returns true if the message has more than one line.
    def multiline?(message)
      message.index("\n") != nil
    end
  end
end

STDOUT.sync = true
Configure.new(root).run
