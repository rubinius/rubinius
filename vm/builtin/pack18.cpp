
/* This file was generated by Ragel. Your edits will be lost.
 *
 * This is a state machine implementation of Array#pack.
 * See http://github.com/rubinius/rapa.
 *
 * vim: filetype=cpp
 */

#include <stdint.h>
#include <sstream>

#include "vm/config.h"

#include "vm.hpp"
#include "object_utils.hpp"
#include "on_stack.hpp"
#include "objectmemory.hpp"

#include "builtin/array.hpp"
#include "builtin/bytearray.hpp"
#include "builtin/exception.hpp"
#include "builtin/float.hpp"
#include "builtin/module.hpp"
#include "builtin/object.hpp"
#include "builtin/string.hpp"

#ifdef RBX_WINDOWS
#include <malloc.h>
#endif

namespace rubinius {
  namespace pack18 {
    inline Object* to_int(STATE, CallFrame* call_frame, Object* obj) {
      Array* args = Array::create(state, 1);
      args->set(state, 0, obj);

      return G(rubinius)->send(state, call_frame, state->symbol("pack_to_int"), args);
    }

#define BITS_LONG   (RBX_SIZEOF_LONG * 8)

    inline long check_long(STATE, Integer* obj) {
      if((obj)->fixnum_p()) {
        return force_as<Fixnum>(obj)->to_long();
      } else {
        Bignum* big = as<Bignum>(obj);
        big->verify_size(state, BITS_LONG);
        return big->to_long();
      }
    }

#define BITS_64     (64)

    inline long long check_long_long(STATE, Integer* obj) {
      if((obj)->fixnum_p()) {
        return force_as<Fixnum>(obj)->to_long_long();
      } else {
        Bignum* big = as<Bignum>(obj);
        big->verify_size(state, BITS_64);
        return big->to_long_long();
      }
    }

    inline Object* to_f(STATE, CallFrame* call_frame, Object* obj) {
      Array* args = Array::create(state, 1);
      args->set(state, 0, obj);

      return G(rubinius)->send(state, call_frame, state->symbol("pack_to_float"), args);
    }

    inline String* encoding_string(STATE, CallFrame* call_frame, Object* obj,
                                          const char* coerce_name)
    {
      String* s = try_as<String>(obj);
      if(s) return s;

      Array* args = Array::create(state, 1);
      args->set(state, 0, obj);

      std::string coerce_method("pack_");
      coerce_method += coerce_name;
      Object* result = G(rubinius)->send(state, call_frame,
            state->symbol(coerce_method.c_str()), args);

      if(!result) return 0;
      return as<String>(result);
    }

    inline uint16_t swap_2bytes(uint16_t x) {
      return (((x & 0x00ff)<<8) | ((x & 0xff00)>>8));
    }

    inline uint32_t swap_4bytes(uint32_t x) {
      return (((x & 0x000000ff) << 24)
             |((x & 0xff000000) >> 24)
             |((x & 0x0000ff00) << 8)
             |((x & 0x00ff0000) >> 8));
    }

    inline uint64_t swap_8bytes(uint64_t x) {
      return (((x & 0x00000000000000ffLL) << 56)
             |((x & 0xff00000000000000LL) >> 56)
             |((x & 0x000000000000ff00LL) << 40)
             |((x & 0x00ff000000000000LL) >> 40)
             |((x & 0x0000000000ff0000LL) << 24)
             |((x & 0x0000ff0000000000LL) >> 24)
             |((x & 0x00000000ff000000LL) << 8)
             |((x & 0x000000ff00000000LL) >> 8));
    }

    inline void swap_float(std::string& str, float value) {
      uint32_t x;

      memcpy(&x, &value, sizeof(float));
      x = swap_4bytes(x);

      str.append((const char*)&x, sizeof(uint32_t));
    }

    inline void swap_double(std::string& str, double value) {
      uint64_t x;

      memcpy(&x, &value, sizeof(double));
      x = swap_8bytes(x);

      str.append((const char*)&x, sizeof(uint64_t));
    }

    inline void double_element(std::string& str, double value) {
      str.append((const char*)&value, sizeof(double));
    }

    inline void float_element(std::string& str, float value) {
      str.append((const char*)&value, sizeof(float));
    }

    inline void short_element(std::string& str, int16_t value) {
      str.append((const char*)&value, sizeof(int16_t));
    }

    inline void int_element(std::string& str, int32_t value) {
      str.append((const char*)&value, sizeof(int32_t));
    }

    inline void long_element(std::string& str, int64_t value) {
      str.append((const char*)&value, sizeof(int64_t));
    }

    inline int32_t int32_element(STATE, Integer* value) {
      if(value->fixnum_p()) {
        long l = as<Fixnum>(value)->to_long();
        if(l > INT32_MAX || l < INT32_MIN) {
          Exception::range_error(state, "Fixnum value out of range of int32");
        }
        return l;
      } else {
        Bignum* big = as<Bignum>(value);
        big->verify_size(state, 32);
        return big->to_int();
      }
    }

#define QUOTABLE_PRINTABLE_BUFSIZE 1024

    static const char hex_table[] = "0123456789ABCDEF";
    void quotable_printable(String* s, std::string& str, int count) {
      char buf[QUOTABLE_PRINTABLE_BUFSIZE];

      uint8_t* b = s->byte_address();
      uint8_t* e = b + s->byte_size();
      int i = 0, n = 0, prev = -1;

      for(; b < e; b++) {
        if((*b > 126) || (*b < 32 && *b != '\n' && *b != '\t') || (*b == '=')) {
          buf[i++] = '=';
          buf[i++] = hex_table[*b >> 4];
          buf[i++] = hex_table[*b & 0x0f];
          n += 3;
          prev = -1;
        } else if(*b == '\n') {
          if(prev == ' ' || prev == '\t') {
            buf[i++] = '=';
            buf[i++] = *b;
          }
          buf[i++] = *b;
          n = 0;
          prev = *b;
        } else {
          buf[i++] = *b;
          n++;
          prev = *b;
        }

        if(n > count) {
          buf[i++] = '=';
          buf[i++] = '\n';
          n = 0;
          prev = '\n';
        }

        if(i > QUOTABLE_PRINTABLE_BUFSIZE - 5) {
          str.append(buf, i);
          i = 0;
        }
      }

      if(n > 0) {
        buf[i++] = '=';
        buf[i++] = '\n';
      }

      if(i > 0) {
        str.append(buf, i);
      }
    }

    static const char uu_table[] =
      "`!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";
    static const char b64_table[] =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

#define b64_uu_byte1(t, b)      t[077 & (*b >> 2)]
#define b64_uu_byte2(t, b, c)   t[077 & (((*b << 4) & 060) | ((c >> 4) & 017))]
#define b64_uu_byte3(t, b, c)   t[077 & (((b[1] << 2) & 074) | ((c >> 6) & 03))];
#define b64_uu_byte4(t, b)      t[077 & b[2]];

    void b64_uu_encode(String* s, std::string& str, native_int count,
                              const char* table, int padding, bool encode_size)
    {
      char *buf = ALLOCA_N(char, count * 4 / 3 + 6);
      native_int i, chars, line, total = s->byte_size();
      uint8_t* b = s->byte_address();

      for(i = 0; total > 0; i = 0, total -= line) {
        line = total > count ? count : total;

        if(encode_size) buf[i++] = line + ' ';

        for(chars = line; chars >= 3; chars -= 3, b += 3) {
          buf[i++] = b64_uu_byte1(table, b);
          buf[i++] = b64_uu_byte2(table, b, b[1]);
          buf[i++] = b64_uu_byte3(table, b, b[2]);
          buf[i++] = b64_uu_byte4(table, b);
        }

        if(chars == 2) {
          buf[i++] = b64_uu_byte1(table, b);
          buf[i++] = b64_uu_byte2(table, b, b[1]);
          buf[i++] = b64_uu_byte3(table, b, '\0');
          buf[i++] = padding;
        } else if(chars == 1) {
          buf[i++] = b64_uu_byte1(table, b);
          buf[i++] = b64_uu_byte2(table, b, '\0');
          buf[i++] = padding;
          buf[i++] = padding;
        }

        b += chars;
        buf[i++] = '\n';
        str.append(buf, i);
      }
    }

    void utf8_encode(STATE, std::string& str, Integer* value) {
      int32_t v = int32_element(state, value);

      if(!(v & ~0x7f)) {
        str.push_back(v);
      } else if(!(v & ~0x7ff)) {
        str.push_back(((v >> 6) & 0xff) | 0xc0);
        str.push_back((v & 0x3f) | 0x80);
      } else if(!(v & ~0xffff)) {
        str.push_back(((v >> 12) & 0xff) | 0xe0);
        str.push_back(((v >> 6)  & 0x3f) | 0x80);
        str.push_back((v & 0x3f) | 0x80);
      } else if(!(v & ~0x1fffff)) {
        str.push_back(((v >> 18) & 0xff) | 0xf0);
        str.push_back(((v >> 12) & 0x3f) | 0x80);
        str.push_back(((v >> 6)  & 0x3f) | 0x80);
        str.push_back((v & 0x3f) | 0x80);
      } else if(!(v & ~0x3ffffff)) {
        str.push_back(((v >> 24) & 0xff) | 0xf8);
        str.push_back(((v >> 18) & 0x3f) | 0x80);
        str.push_back(((v >> 12) & 0x3f) | 0x80);
        str.push_back(((v >> 6)  & 0x3f) | 0x80);
        str.push_back((v & 0x3f) | 0x80);
      } else if(!(v & ~0x7fffffff)) {
        str.push_back(((v >> 30) & 0xff) | 0xfc);
        str.push_back(((v >> 24) & 0x3f) | 0x80);
        str.push_back(((v >> 18) & 0x3f) | 0x80);
        str.push_back(((v >> 12) & 0x3f) | 0x80);
        str.push_back(((v >> 6)  & 0x3f) | 0x80);
        str.push_back((v & 0x3f) | 0x80);
      } else {
        Exception::range_error(state, "pack('U') value out of range");
      }
    }

    void ber_encode(STATE, std::string& str, Integer* value) {
      if(!value->positive_p()) {
        Exception::argument_error(state, "cannot BER compress a negative number");
      }

      std::string buf;

      if(try_as<Bignum>(value)) {
        Fixnum* base = Fixnum::from(128);
        while(try_as<Bignum>(value)) {
          Array* ary;
          if(value->fixnum_p()) {
            ary = as<Fixnum>(value)->divmod(state, base);
          } else {
            ary = as<Bignum>(value)->divmod(state, base);
          }
          buf.push_back(as<Fixnum>(ary->get(state, 1))->to_native() | 0x80);
          value = as<Integer>(ary->get(state, 0));
        }
      }

      long v = value->to_long();

      while(v) {
        buf.push_back((v & 0x7f) | 0x80);
        v >>= 7;
      }

      if(buf.size() > 0) {
        char* a = const_cast<char*>(buf.c_str());
        char* b = a + buf.size() - 1;

        // clear continue bit
        *a &= 0x7f;

        // reverse string
        while(a < b) {
          int k = *a;
          *a++ = *b;
          *b-- = k;
        }

        str.append(buf.c_str(), buf.size());
      } else {
        str.push_back(0);
      }
    }

    inline native_int bit_extra(String* s, bool rest, native_int& count) {
      native_int extra = 0;

      if(rest) {
        count = s->byte_size();
      } else {
        native_int size = s->byte_size();
        if(count > size) {
          extra = (count - size + 1) / 2;
          count = size;
        }
      }

      return extra;
    }

    void bit_high(String* s, std::string& str, native_int count) {
      uint8_t* b = s->byte_address();
      int byte = 0;

      for(native_int i = 0; i++ < count; b++) {
        byte |= *b & 1;
        if(i & 7) {
          byte <<= 1;
        } else {
          str.push_back(byte & 0xff);
          byte = 0;
        }
      }

      if(count & 7) {
        byte <<= 7 - (count & 7);
        str.push_back(byte & 0xff);
      }
    }

    void bit_low(String* s, std::string& str, native_int count) {
      uint8_t* b = s->byte_address();
      int byte = 0;

      for(native_int i = 0; i++ < count; b++) {
        if(*b & 1)
          byte |= 128;

        if(i & 7) {
          byte >>= 1;
        } else {
          str.push_back(byte & 0xff);
          byte = 0;
        }
      }

      if(count & 7) {
        byte >>= 7 - (count & 7);
        str.push_back(byte & 0xff);
      }
    }

    inline native_int hex_extra(String* s, bool rest, native_int& count) {
      native_int extra = 0;

      if(rest) {
        count = s->byte_size();
      } else {
        native_int size = s->byte_size();
        if(count > size) {
          extra = (count + 1) / 2 - (size + 1) / 2;
          count = size;
        }
      }

      return extra;
    }

    void hex_high(String* s, std::string& str, native_int count) {
      uint8_t* b = s->byte_address();
      int byte = 0;

      for(native_int i = 0; i++ < count; b++) {
        if(ISALPHA(*b)) {
          byte |= ((*b & 15) + 9) & 15;
        } else {
          byte |= *b & 15;
        }

        if(i & 1) {
          byte <<= 4;
        } else {
          str.push_back(byte & 0xff);
          byte = 0;
        }
      }

      if(count & 1) {
        str.push_back(byte & 0xff);
      }
    }

    void hex_low(String* s, std::string& str, native_int count) {
      uint8_t* b = s->byte_address();
      int byte = 0;

      for(native_int i = 0; i++ < count; b++) {
        if(ISALPHA(*b)) {
          byte |= (((*b & 15) + 9) & 15) << 4;
        } else {
          byte |= (*b & 15) << 4;
        }

        if(i & 1) {
          byte >>= 4;
        } else {
          str.push_back(byte & 0xff);
          byte = 0;
        }
      }

      if(count & 1) {
        str.push_back(byte & 0xff);
      }
    }

    ByteArray* prepare_directives(STATE, String* directives,
                                  const char** p, const char** pe)
    {
      native_int size = directives->byte_size();
      ByteArray* ba = ByteArray::create_pinned(state, size);
      char* b = reinterpret_cast<char*>(ba->raw_bytes());
      char* d = reinterpret_cast<char*>(directives->byte_address());
      int i = 0, j = 0;

      while(i < size) {
        switch(d[i]) {
        case 0:
        case ' ':
        case '\t':
        case '\n':
        case '\v':
        case '\f':
        case '\r':
          i++;
          break;
        case '#':
          while(++i < size && d[i] != '\n')
            ; // ignore
          if(d[i] == '\n') i++;
          break;
        default:
          b[j++] = d[i++];
          break;
        }
      }

      *p = const_cast<const char*>(b);
      *pe = *p + j;

      return ba;
    }

    void exceeds_length_of_string(STATE, native_int count) {
      std::ostringstream msg;
      msg << "X" << count << " exceeds length of string";
      Exception::argument_error(state, msg.str().c_str());
    }

    void non_native_error(STATE, const char c) {
      std::ostringstream msg;
      msg << "'" << c << "' allowed only after types sSiIlL";
      Exception::argument_error(state, msg.str().c_str());
    }
  }


// Pack Float elements
#define pack_float_elements(format)   pack_elements(Float, pack18::to_f, format)

#define pack_double_le                pack_float_elements(pack_double_element_le)
#define pack_double_be                pack_float_elements(pack_double_element_be)

#define pack_float_le                 pack_float_elements(pack_float_element_le)
#define pack_float_be                 pack_float_elements(pack_float_element_be)

// Pack Integer elements
#define pack_integer_elements(format) pack_elements(Integer, pack18::to_int, format)

#define pack_byte_element(v)          str.push_back(pack18::check_long(state, v))
#define pack_byte                     pack_integer_elements(pack_byte_element)

#define pack_short_le                 pack_integer_elements(pack_short_element_le)
#define pack_short_be                 pack_integer_elements(pack_short_element_be)

#define pack_int_le                   pack_integer_elements(pack_int_element_le)
#define pack_int_be                   pack_integer_elements(pack_int_element_be)

#define pack_long_le                  pack_integer_elements(pack_long_element_le)
#define pack_long_be                  pack_integer_elements(pack_long_element_be)

// Pack UTF-8 elements
#define pack_utf8_element(v)          pack18::utf8_encode(state, str, v)
#define pack_utf8                     pack_elements(Integer, pack18::to_int, pack_utf8_element)

// Pack BER-compressed integers
#define pack_ber_element(v)           pack18::ber_encode(state, str, v)
#define pack_ber                      pack_elements(Integer, pack18::to_int, pack_ber_element)

// Wraps the logic for iterating over a number of elements,
// coercing them to the correct class and formatting them
// for the output string.
#define pack_elements(T, coerce, format)        \
  for(; index < stop; index++) {                \
    Object* item = self->get(state, index);     \
    T* value = try_as<T>(item);                 \
    if(!value) {                                \
      item = coerce(state, call_frame, item);   \
      if(!item) return 0;                       \
      value = as<T>(item);                      \
    }                                           \
    format(value);                              \
  }

// Macros that depend on endianness
#ifdef RBX_LITTLE_ENDIAN

# define pack_double_element_le(v)  (pack18::double_element(str, (v)->val))
# define pack_double_element_be(v)  (pack18::swap_double(str, (v)->val))
# define pack_double                pack_double_le

# define pack_float_element_le(v)   (pack18::float_element(str, (v)->val))
# define pack_float_element_be(v)   (pack18::swap_float(str, (v)->val))
# define pack_float                 pack_float_le

# define pack_short_element_le(v)   (pack18::short_element(str, pack18::check_long(state, v)))
# define pack_short_element_be(v)   (pack18::short_element(str, \
                                        pack18::swap_2bytes(pack18::check_long(state, v))))
# define pack_short                 pack_short_le

# define pack_int_element_le(v)     (pack18::int_element(str, pack18::check_long(state, v)))
# define pack_int_element_be(v)     (pack18::int_element(str, \
                                        pack18::swap_4bytes(pack18::check_long(state, v))))
# define pack_int                   pack_int_le

# define pack_long_element_le(v)    (pack18::long_element(str, pack18::check_long_long(state, v)))
# define pack_long_element_be(v)    (pack18::long_element(str, \
                                        pack18::swap_8bytes(pack18::check_long_long(state, v))))
# define pack_long                  pack_long_le

#else // Big endian

# define pack_double_element_le(v)  (pack18::swap_double(str, (v)->val))
# define pack_double_element_be(v)  (pack18::double_element(str, (v)->val))
# define pack_double                pack_double_be

# define pack_float_element_le(v)   (pack18::swap_float(str, (v)->val))
# define pack_float_element_be(v)   (pack18::float_element(str, (v)->val))
# define pack_float                 pack_float_be

# define pack_short_element_le(v)   (pack18::short_element(str, \
                                        pack18::swap_2bytes(pack18::check_long(state, v))))
# define pack_short_element_be(v)   (pack18::short_element(str, pack18::check_long(state, v)))
# define pack_short                 pack_short_be

# define pack_int_element_le(v)     (pack18::int_element(str, \
                                        pack18::swap_4bytes(pack18::check_long(state, v))))
# define pack_int_element_be(v)     (pack18::int_element(str, pack18::check_long(state, v)))
# define pack_int                   pack_int_be

# define pack_long_element_le(v)    (pack18::long_element(str, \
                                        pack18::swap_8bytes(pack18::check_long_long(state, v))))
# define pack_long_element_be(v)    (pack18::long_element(str, pack18::check_long_long(state, v)))
# define pack_long                  pack_long_be

#endif

  String* Array::pack18(STATE, String* directives, CallFrame* call_frame) {
    // Ragel-specific variables
    const char* p;
    const char* pe;
    ByteArray* d = pack18::prepare_directives(state, directives, &p, &pe);
    const char *eof = pe;
    int cs;

    // pack-specific variables
    Array* self = this;
    OnStack<2> sv(state, self, d);

    native_int array_size = self->size();
    native_int index = 0;
    native_int count UNUSED = 0;
    native_int stop = 0;
    bool rest UNUSED = false;
    bool platform UNUSED = false;
    bool tainted UNUSED  = false;

    String* string_value = 0;
    std::string str("");

    // Use information we have to reduce repeated allocation.
    str.reserve(array_size * 4);

    if(CBOOL(directives->tainted_p(state))) tainted = true;

static const char _trans_keys[] = {
	0, 0, 64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 
	33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 
	33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 42, 120, 64, 120, 33, 120, 
	42, 120, 64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 
	33, 120, 64, 120, 33, 120, 42, 120, 64, 120, 33, 120, 64, 120, 33, 120, 
	64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 
	64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 
	64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 64, 120, 33, 120, 
	64, 120, 33, 120, 64, 120, 64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 
	48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 
	48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 
	48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 
	48, 120, 48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 
	64, 120, 48, 120, 48, 120, 48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 
	64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 
	64, 120, 48, 120, 64, 120, 48, 120, 64, 120, 48, 120, 0
};

static const char _key_spans[] = {
	0, 57, 88, 57, 88, 57, 88, 57, 
	88, 57, 88, 57, 88, 57, 88, 57, 
	88, 57, 88, 57, 88, 79, 57, 88, 
	79, 57, 88, 57, 88, 57, 88, 57, 
	88, 57, 88, 79, 57, 88, 57, 88, 
	57, 88, 57, 88, 57, 88, 57, 88, 
	57, 88, 57, 88, 57, 88, 57, 88, 
	57, 88, 57, 88, 57, 88, 57, 88, 
	57, 88, 57, 57, 73, 57, 73, 57, 
	73, 57, 73, 57, 73, 57, 73, 57, 
	73, 57, 73, 57, 73, 57, 73, 57, 
	73, 57, 73, 57, 73, 57, 73, 57, 
	73, 73, 57, 73, 57, 73, 57, 73, 
	57, 73, 73, 73, 57, 73, 57, 73, 
	57, 73, 57, 73, 57, 73, 57, 73, 
	57, 73, 57, 73, 57, 73
};

static const short _index_offsets[] = {
	0, 0, 58, 147, 205, 294, 352, 441, 
	499, 588, 646, 735, 793, 882, 940, 1029, 
	1087, 1176, 1234, 1323, 1381, 1470, 1550, 1608, 
	1697, 1777, 1835, 1924, 1982, 2071, 2129, 2218, 
	2276, 2365, 2423, 2512, 2592, 2650, 2739, 2797, 
	2886, 2944, 3033, 3091, 3180, 3238, 3327, 3385, 
	3474, 3532, 3621, 3679, 3768, 3826, 3915, 3973, 
	4062, 4120, 4209, 4267, 4356, 4414, 4503, 4561, 
	4650, 4708, 4797, 4855, 4913, 4987, 5045, 5119, 
	5177, 5251, 5309, 5383, 5441, 5515, 5573, 5647, 
	5705, 5779, 5837, 5911, 5969, 6043, 6101, 6175, 
	6233, 6307, 6365, 6439, 6497, 6571, 6629, 6703, 
	6761, 6835, 6909, 6967, 7041, 7099, 7173, 7231, 
	7305, 7363, 7437, 7511, 7585, 7643, 7717, 7775, 
	7849, 7907, 7981, 8039, 8113, 8171, 8245, 8303, 
	8377, 8435, 8509, 8567, 8641, 8699
};

static const short _indicies[] = {
	0, 2, 3, 4, 5, 6, 7, 
	8, 9, 10, 1, 1, 11, 12, 13, 
	1, 14, 15, 1, 16, 1, 17, 18, 
	1, 19, 1, 20, 1, 1, 1, 1, 
	1, 1, 21, 22, 4, 5, 23, 7, 
	24, 25, 10, 1, 1, 11, 26, 27, 
	1, 14, 15, 1, 16, 1, 28, 29, 
	30, 31, 1, 32, 1, 1, 1, 1, 
	1, 1, 1, 1, 33, 1, 1, 1, 
	1, 1, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 1, 1, 1, 1, 
	1, 1, 35, 36, 37, 38, 39, 40, 
	41, 42, 43, 44, 1, 1, 45, 46, 
	47, 1, 48, 49, 1, 50, 1, 51, 
	52, 1, 53, 1, 54, 1, 1, 1, 
	1, 32, 1, 55, 56, 38, 39, 57, 
	41, 58, 59, 44, 1, 1, 45, 60, 
	61, 1, 48, 49, 1, 50, 1, 62, 
	63, 64, 65, 1, 35, 36, 37, 38, 
	39, 40, 41, 42, 43, 44, 1, 1, 
	45, 46, 47, 1, 48, 49, 1, 50, 
	1, 51, 52, 1, 53, 1, 54, 1, 
	1, 1, 1, 1, 1, 55, 56, 38, 
	39, 57, 41, 58, 59, 44, 1, 1, 
	45, 60, 61, 1, 48, 49, 1, 50, 
	1, 62, 63, 64, 65, 1, 66, 1, 
	1, 1, 1, 1, 1, 1, 1, 67, 
	1, 1, 1, 1, 1, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 1, 
	1, 1, 1, 1, 1, 69, 70, 71, 
	72, 73, 74, 75, 76, 77, 78, 1, 
	1, 79, 80, 81, 1, 82, 83, 1, 
	84, 1, 85, 86, 1, 87, 1, 88, 
	1, 1, 1, 1, 66, 1, 89, 90, 
	72, 73, 91, 75, 92, 93, 78, 1, 
	1, 79, 94, 95, 1, 82, 83, 1, 
	84, 1, 96, 97, 98, 99, 1, 69, 
	70, 71, 72, 73, 74, 75, 76, 77, 
	78, 1, 1, 79, 80, 81, 1, 82, 
	83, 1, 84, 1, 85, 86, 1, 87, 
	1, 88, 1, 1, 1, 1, 1, 1, 
	89, 90, 72, 73, 91, 75, 92, 93, 
	78, 1, 1, 79, 94, 95, 1, 82, 
	83, 1, 84, 1, 96, 97, 98, 99, 
	1, 100, 1, 1, 1, 1, 1, 1, 
	1, 1, 101, 1, 1, 1, 1, 1, 
	102, 102, 102, 102, 102, 102, 102, 102, 
	102, 102, 1, 1, 1, 1, 1, 1, 
	103, 104, 105, 106, 107, 108, 109, 110, 
	111, 112, 1, 1, 113, 114, 115, 1, 
	116, 117, 1, 118, 1, 119, 120, 1, 
	121, 1, 122, 1, 1, 1, 1, 100, 
	1, 123, 124, 106, 107, 125, 109, 126, 
	127, 112, 1, 1, 113, 128, 129, 1, 
	116, 117, 1, 118, 1, 130, 131, 132, 
	133, 1, 103, 104, 105, 106, 107, 108, 
	109, 110, 111, 112, 1, 1, 113, 114, 
	115, 1, 116, 117, 1, 118, 1, 119, 
	120, 1, 121, 1, 122, 1, 1, 1, 
	1, 1, 1, 123, 124, 106, 107, 125, 
	109, 126, 127, 112, 1, 1, 113, 128, 
	129, 1, 116, 117, 1, 118, 1, 130, 
	131, 132, 133, 1, 134, 1, 1, 1, 
	1, 1, 1, 1, 1, 135, 1, 1, 
	1, 1, 1, 136, 136, 136, 136, 136, 
	136, 136, 136, 136, 136, 1, 1, 1, 
	1, 1, 1, 137, 138, 139, 140, 141, 
	142, 143, 144, 145, 146, 1, 1, 147, 
	148, 149, 1, 150, 151, 1, 152, 1, 
	153, 154, 1, 155, 1, 156, 1, 1, 
	1, 1, 134, 1, 157, 158, 140, 141, 
	159, 143, 160, 161, 146, 1, 1, 147, 
	162, 163, 1, 150, 151, 1, 152, 1, 
	164, 165, 166, 167, 1, 137, 138, 139, 
	140, 141, 142, 143, 144, 145, 146, 1, 
	1, 147, 148, 149, 1, 150, 151, 1, 
	152, 1, 153, 154, 1, 155, 1, 156, 
	1, 1, 1, 1, 1, 1, 157, 158, 
	140, 141, 159, 143, 160, 161, 146, 1, 
	1, 147, 162, 163, 1, 150, 151, 1, 
	152, 1, 164, 165, 166, 167, 1, 168, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	169, 1, 1, 1, 1, 1, 170, 170, 
	170, 170, 170, 170, 170, 170, 170, 170, 
	1, 1, 1, 1, 1, 1, 171, 172, 
	173, 174, 175, 176, 177, 178, 179, 180, 
	1, 1, 181, 182, 183, 1, 184, 185, 
	1, 186, 1, 187, 188, 1, 189, 1, 
	190, 1, 1, 1, 1, 168, 1, 191, 
	192, 174, 175, 193, 177, 194, 195, 180, 
	1, 1, 181, 196, 197, 1, 184, 185, 
	1, 186, 1, 198, 199, 200, 201, 1, 
	171, 172, 173, 174, 175, 176, 177, 178, 
	179, 180, 1, 1, 181, 182, 183, 1, 
	184, 185, 1, 186, 1, 187, 188, 1, 
	189, 1, 190, 1, 1, 1, 1, 1, 
	1, 191, 192, 174, 175, 193, 177, 194, 
	195, 180, 1, 1, 181, 196, 197, 1, 
	184, 185, 1, 186, 1, 198, 199, 200, 
	201, 1, 202, 1, 1, 1, 1, 1, 
	1, 1, 1, 203, 1, 1, 1, 1, 
	1, 204, 204, 204, 204, 204, 204, 204, 
	204, 204, 204, 1, 1, 1, 1, 1, 
	1, 205, 206, 207, 208, 209, 210, 211, 
	212, 213, 214, 1, 1, 215, 216, 217, 
	1, 218, 219, 1, 220, 1, 221, 222, 
	1, 223, 1, 224, 1, 1, 1, 1, 
	202, 1, 225, 226, 208, 209, 227, 211, 
	228, 229, 214, 1, 1, 215, 230, 231, 
	1, 218, 219, 1, 220, 1, 232, 233, 
	234, 235, 1, 205, 206, 207, 208, 209, 
	210, 211, 212, 213, 214, 1, 1, 215, 
	216, 217, 1, 218, 219, 1, 220, 1, 
	221, 222, 1, 223, 1, 224, 1, 1, 
	1, 1, 1, 1, 225, 226, 208, 209, 
	227, 211, 228, 229, 214, 1, 1, 215, 
	230, 231, 1, 218, 219, 1, 220, 1, 
	232, 233, 234, 235, 1, 236, 1, 1, 
	1, 1, 1, 1, 1, 1, 237, 1, 
	1, 1, 1, 1, 238, 238, 238, 238, 
	238, 238, 238, 238, 238, 238, 1, 1, 
	1, 1, 1, 1, 239, 240, 241, 242, 
	243, 244, 245, 246, 247, 248, 1, 1, 
	249, 250, 251, 1, 252, 253, 1, 254, 
	1, 255, 256, 1, 257, 1, 258, 1, 
	1, 1, 1, 236, 1, 259, 260, 242, 
	243, 261, 245, 262, 263, 248, 1, 1, 
	249, 264, 265, 1, 252, 253, 1, 254, 
	1, 266, 267, 268, 269, 1, 239, 240, 
	241, 242, 243, 244, 245, 246, 247, 248, 
	1, 1, 249, 250, 251, 1, 252, 253, 
	1, 254, 1, 255, 256, 1, 257, 1, 
	258, 1, 1, 1, 1, 1, 1, 259, 
	260, 242, 243, 261, 245, 262, 263, 248, 
	1, 1, 249, 264, 265, 1, 252, 253, 
	1, 254, 1, 266, 267, 268, 269, 1, 
	270, 1, 1, 1, 1, 1, 1, 1, 
	1, 271, 1, 1, 1, 1, 1, 272, 
	272, 272, 272, 272, 272, 272, 272, 272, 
	272, 1, 1, 1, 1, 1, 1, 273, 
	274, 275, 276, 277, 278, 279, 280, 281, 
	282, 1, 1, 283, 284, 285, 1, 286, 
	287, 1, 288, 1, 289, 290, 1, 291, 
	1, 292, 1, 1, 1, 1, 270, 1, 
	293, 294, 276, 277, 295, 279, 296, 297, 
	282, 1, 1, 283, 298, 299, 1, 286, 
	287, 1, 288, 1, 300, 301, 302, 303, 
	1, 273, 274, 275, 276, 277, 278, 279, 
	280, 281, 282, 1, 1, 283, 284, 285, 
	1, 286, 287, 1, 288, 1, 289, 290, 
	1, 291, 1, 292, 1, 1, 1, 1, 
	1, 1, 293, 294, 276, 277, 295, 279, 
	296, 297, 282, 1, 1, 283, 298, 299, 
	1, 286, 287, 1, 288, 1, 300, 301, 
	302, 303, 1, 304, 1, 1, 1, 1, 
	1, 1, 1, 1, 305, 1, 1, 1, 
	1, 1, 306, 306, 306, 306, 306, 306, 
	306, 306, 306, 306, 1, 1, 1, 1, 
	1, 1, 307, 308, 309, 310, 311, 312, 
	313, 314, 315, 316, 1, 1, 317, 318, 
	319, 1, 320, 321, 1, 322, 1, 323, 
	324, 1, 325, 1, 326, 1, 1, 1, 
	1, 304, 1, 327, 328, 310, 311, 329, 
	313, 330, 331, 316, 1, 1, 317, 332, 
	333, 1, 320, 321, 1, 322, 1, 334, 
	335, 336, 337, 1, 307, 308, 309, 310, 
	311, 312, 313, 314, 315, 316, 1, 1, 
	317, 318, 319, 1, 320, 321, 1, 322, 
	1, 323, 324, 1, 325, 1, 326, 1, 
	1, 1, 1, 1, 1, 327, 328, 310, 
	311, 329, 313, 330, 331, 316, 1, 1, 
	317, 332, 333, 1, 320, 321, 1, 322, 
	1, 334, 335, 336, 337, 1, 338, 1, 
	1, 1, 1, 1, 1, 1, 1, 339, 
	1, 1, 1, 1, 1, 340, 340, 340, 
	340, 340, 340, 340, 340, 340, 340, 1, 
	1, 1, 1, 1, 1, 341, 342, 343, 
	344, 345, 346, 347, 348, 349, 350, 1, 
	1, 351, 352, 353, 1, 354, 355, 1, 
	356, 1, 357, 358, 1, 359, 1, 360, 
	1, 1, 1, 1, 338, 1, 361, 362, 
	344, 345, 363, 347, 364, 365, 350, 1, 
	1, 351, 366, 367, 1, 354, 355, 1, 
	356, 1, 368, 369, 370, 371, 1, 372, 
	1, 1, 1, 1, 1, 373, 373, 373, 
	373, 373, 373, 373, 373, 373, 373, 1, 
	1, 1, 1, 1, 1, 374, 375, 376, 
	377, 378, 379, 380, 381, 382, 383, 1, 
	1, 384, 385, 386, 1, 387, 388, 1, 
	389, 1, 390, 391, 1, 392, 1, 393, 
	1, 1, 1, 1, 1, 1, 394, 395, 
	377, 378, 396, 380, 397, 398, 383, 1, 
	1, 384, 399, 400, 1, 387, 388, 1, 
	389, 1, 401, 402, 403, 404, 1, 405, 
	406, 407, 408, 409, 410, 411, 412, 413, 
	414, 1, 1, 415, 416, 417, 1, 418, 
	419, 1, 420, 1, 421, 422, 1, 423, 
	1, 424, 1, 1, 1, 1, 1, 1, 
	425, 426, 408, 409, 427, 411, 428, 429, 
	414, 1, 1, 415, 430, 431, 1, 418, 
	419, 1, 420, 1, 432, 433, 434, 435, 
	1, 436, 1, 1, 1, 1, 1, 1, 
	1, 1, 437, 1, 1, 1, 1, 1, 
	438, 438, 438, 438, 438, 438, 438, 438, 
	438, 438, 1, 1, 1, 1, 1, 1, 
	439, 440, 441, 442, 443, 444, 445, 446, 
	447, 448, 1, 1, 449, 450, 451, 1, 
	452, 453, 1, 454, 1, 455, 456, 1, 
	457, 1, 458, 1, 1, 1, 1, 436, 
	1, 459, 460, 442, 443, 461, 445, 462, 
	463, 448, 1, 1, 449, 464, 465, 1, 
	452, 453, 1, 454, 1, 466, 467, 468, 
	469, 1, 470, 1, 1, 1, 1, 1, 
	471, 471, 471, 471, 471, 471, 471, 471, 
	471, 471, 1, 1, 1, 1, 1, 1, 
	472, 473, 474, 475, 476, 477, 478, 479, 
	480, 481, 1, 1, 482, 483, 484, 1, 
	485, 486, 1, 487, 1, 488, 489, 1, 
	490, 1, 491, 1, 1, 1, 1, 1, 
	1, 492, 493, 475, 476, 494, 478, 495, 
	496, 481, 1, 1, 482, 497, 498, 1, 
	485, 486, 1, 487, 1, 499, 500, 501, 
	502, 1, 503, 504, 505, 506, 507, 508, 
	509, 510, 511, 512, 1, 1, 513, 514, 
	515, 1, 516, 517, 1, 518, 1, 519, 
	520, 1, 521, 1, 522, 1, 1, 1, 
	1, 1, 1, 523, 524, 506, 507, 525, 
	509, 526, 527, 512, 1, 1, 513, 528, 
	529, 1, 516, 517, 1, 518, 1, 530, 
	531, 532, 533, 1, 534, 1, 1, 1, 
	1, 1, 1, 1, 1, 535, 1, 1, 
	1, 1, 1, 536, 536, 536, 536, 536, 
	536, 536, 536, 536, 536, 1, 1, 1, 
	1, 1, 1, 537, 538, 539, 540, 541, 
	542, 543, 544, 545, 546, 1, 1, 547, 
	548, 549, 1, 550, 551, 1, 552, 1, 
	553, 554, 1, 555, 1, 556, 1, 1, 
	1, 1, 534, 1, 557, 558, 540, 541, 
	559, 543, 560, 561, 546, 1, 1, 547, 
	562, 563, 1, 550, 551, 1, 552, 1, 
	564, 565, 566, 567, 1, 537, 538, 539, 
	540, 541, 542, 543, 544, 545, 546, 1, 
	1, 547, 548, 549, 1, 550, 551, 1, 
	552, 1, 553, 554, 1, 555, 1, 556, 
	1, 1, 1, 1, 1, 1, 557, 558, 
	540, 541, 559, 543, 560, 561, 546, 1, 
	1, 547, 562, 563, 1, 550, 551, 1, 
	552, 1, 564, 565, 566, 567, 1, 568, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	569, 1, 1, 1, 1, 1, 570, 570, 
	570, 570, 570, 570, 570, 570, 570, 570, 
	1, 1, 1, 1, 1, 1, 571, 572, 
	573, 574, 575, 576, 577, 578, 579, 580, 
	1, 1, 581, 582, 583, 1, 584, 585, 
	1, 586, 1, 587, 588, 1, 589, 1, 
	590, 1, 1, 1, 1, 568, 1, 591, 
	592, 574, 575, 593, 577, 594, 595, 580, 
	1, 1, 581, 596, 597, 1, 584, 585, 
	1, 586, 1, 598, 599, 600, 601, 1, 
	571, 572, 573, 574, 575, 576, 577, 578, 
	579, 580, 1, 1, 581, 582, 583, 1, 
	584, 585, 1, 586, 1, 587, 588, 1, 
	589, 1, 590, 1, 1, 1, 1, 1, 
	1, 591, 592, 574, 575, 593, 577, 594, 
	595, 580, 1, 1, 581, 596, 597, 1, 
	584, 585, 1, 586, 1, 598, 599, 600, 
	601, 1, 602, 1, 1, 1, 1, 1, 
	1, 1, 1, 603, 1, 1, 1, 1, 
	1, 604, 604, 604, 604, 604, 604, 604, 
	604, 604, 604, 1, 1, 1, 1, 1, 
	1, 605, 606, 607, 608, 609, 610, 611, 
	612, 613, 614, 1, 1, 615, 616, 617, 
	1, 618, 619, 1, 620, 1, 621, 622, 
	1, 623, 1, 624, 1, 1, 1, 1, 
	602, 1, 625, 626, 608, 609, 627, 611, 
	628, 629, 614, 1, 1, 615, 630, 631, 
	1, 618, 619, 1, 620, 1, 632, 633, 
	634, 635, 1, 605, 606, 607, 608, 609, 
	610, 611, 612, 613, 614, 1, 1, 615, 
	616, 617, 1, 618, 619, 1, 620, 1, 
	621, 622, 1, 623, 1, 624, 1, 1, 
	1, 1, 1, 1, 625, 626, 608, 609, 
	627, 611, 628, 629, 614, 1, 1, 615, 
	630, 631, 1, 618, 619, 1, 620, 1, 
	632, 633, 634, 635, 1, 636, 1, 1, 
	1, 1, 1, 1, 1, 1, 637, 1, 
	1, 1, 1, 1, 638, 638, 638, 638, 
	638, 638, 638, 638, 638, 638, 1, 1, 
	1, 1, 1, 1, 639, 640, 641, 642, 
	643, 644, 645, 646, 647, 648, 1, 1, 
	649, 650, 651, 1, 652, 653, 1, 654, 
	1, 655, 656, 1, 657, 1, 658, 1, 
	1, 1, 1, 636, 1, 659, 660, 642, 
	643, 661, 645, 662, 663, 648, 1, 1, 
	649, 664, 665, 1, 652, 653, 1, 654, 
	1, 666, 667, 668, 669, 1, 639, 640, 
	641, 642, 643, 644, 645, 646, 647, 648, 
	1, 1, 649, 650, 651, 1, 652, 653, 
	1, 654, 1, 655, 656, 1, 657, 1, 
	658, 1, 1, 1, 1, 1, 1, 659, 
	660, 642, 643, 661, 645, 662, 663, 648, 
	1, 1, 649, 664, 665, 1, 652, 653, 
	1, 654, 1, 666, 667, 668, 669, 1, 
	670, 1, 1, 1, 1, 1, 1, 1, 
	1, 671, 1, 1, 1, 1, 1, 672, 
	672, 672, 672, 672, 672, 672, 672, 672, 
	672, 1, 1, 1, 1, 1, 1, 673, 
	674, 675, 676, 677, 678, 679, 680, 681, 
	682, 1, 1, 683, 684, 685, 1, 686, 
	687, 1, 688, 1, 689, 690, 1, 691, 
	1, 692, 1, 1, 1, 1, 670, 1, 
	693, 694, 676, 677, 695, 679, 696, 697, 
	682, 1, 1, 683, 698, 699, 1, 686, 
	687, 1, 688, 1, 700, 701, 702, 703, 
	1, 704, 1, 1, 1, 1, 1, 705, 
	705, 705, 705, 705, 705, 705, 705, 705, 
	705, 1, 1, 1, 1, 1, 1, 706, 
	707, 708, 709, 710, 711, 712, 713, 714, 
	715, 1, 1, 716, 717, 718, 1, 719, 
	720, 1, 721, 1, 722, 723, 1, 724, 
	1, 725, 1, 1, 1, 1, 1, 1, 
	726, 727, 709, 710, 728, 712, 729, 730, 
	715, 1, 1, 716, 731, 732, 1, 719, 
	720, 1, 721, 1, 733, 734, 735, 736, 
	1, 737, 738, 739, 740, 741, 742, 743, 
	744, 745, 746, 1, 1, 747, 748, 749, 
	1, 750, 751, 1, 752, 1, 753, 754, 
	1, 755, 1, 756, 1, 1, 1, 1, 
	1, 1, 757, 758, 740, 741, 759, 743, 
	760, 761, 746, 1, 1, 747, 762, 763, 
	1, 750, 751, 1, 752, 1, 764, 765, 
	766, 767, 1, 768, 1, 1, 1, 1, 
	1, 1, 1, 1, 769, 1, 1, 1, 
	1, 1, 770, 770, 770, 770, 770, 770, 
	770, 770, 770, 770, 1, 1, 1, 1, 
	1, 1, 771, 772, 773, 774, 775, 776, 
	777, 778, 779, 780, 1, 1, 781, 782, 
	783, 1, 784, 785, 1, 786, 1, 787, 
	788, 1, 789, 1, 790, 1, 1, 1, 
	1, 768, 1, 791, 792, 774, 775, 793, 
	777, 794, 795, 780, 1, 1, 781, 796, 
	797, 1, 784, 785, 1, 786, 1, 798, 
	799, 800, 801, 1, 771, 772, 773, 774, 
	775, 776, 777, 778, 779, 780, 1, 1, 
	781, 782, 783, 1, 784, 785, 1, 786, 
	1, 787, 788, 1, 789, 1, 790, 1, 
	1, 1, 1, 1, 1, 791, 792, 774, 
	775, 793, 777, 794, 795, 780, 1, 1, 
	781, 796, 797, 1, 784, 785, 1, 786, 
	1, 798, 799, 800, 801, 1, 802, 1, 
	1, 1, 1, 1, 1, 1, 1, 803, 
	1, 1, 1, 1, 1, 804, 804, 804, 
	804, 804, 804, 804, 804, 804, 804, 1, 
	1, 1, 1, 1, 1, 805, 806, 807, 
	808, 809, 810, 811, 812, 813, 814, 1, 
	1, 815, 816, 817, 1, 818, 819, 1, 
	820, 1, 821, 822, 1, 823, 1, 824, 
	1, 1, 1, 1, 802, 1, 825, 826, 
	808, 809, 827, 811, 828, 829, 814, 1, 
	1, 815, 830, 831, 1, 818, 819, 1, 
	820, 1, 832, 833, 834, 835, 1, 805, 
	806, 807, 808, 809, 810, 811, 812, 813, 
	814, 1, 1, 815, 816, 817, 1, 818, 
	819, 1, 820, 1, 821, 822, 1, 823, 
	1, 824, 1, 1, 1, 1, 1, 1, 
	825, 826, 808, 809, 827, 811, 828, 829, 
	814, 1, 1, 815, 830, 831, 1, 818, 
	819, 1, 820, 1, 832, 833, 834, 835, 
	1, 836, 1, 1, 1, 1, 1, 1, 
	1, 1, 837, 1, 1, 1, 1, 1, 
	838, 838, 838, 838, 838, 838, 838, 838, 
	838, 838, 1, 1, 1, 1, 1, 1, 
	839, 840, 841, 842, 843, 844, 845, 846, 
	847, 848, 1, 1, 849, 850, 851, 1, 
	852, 853, 1, 854, 1, 855, 856, 1, 
	857, 1, 858, 1, 1, 1, 1, 836, 
	1, 859, 860, 842, 843, 861, 845, 862, 
	863, 848, 1, 1, 849, 864, 865, 1, 
	852, 853, 1, 854, 1, 866, 867, 868, 
	869, 1, 839, 840, 841, 842, 843, 844, 
	845, 846, 847, 848, 1, 1, 849, 850, 
	851, 1, 852, 853, 1, 854, 1, 855, 
	856, 1, 857, 1, 858, 1, 1, 1, 
	1, 1, 1, 859, 860, 842, 843, 861, 
	845, 862, 863, 848, 1, 1, 849, 864, 
	865, 1, 852, 853, 1, 854, 1, 866, 
	867, 868, 869, 1, 870, 1, 1, 1, 
	1, 1, 1, 1, 1, 871, 1, 1, 
	1, 1, 1, 872, 872, 872, 872, 872, 
	872, 872, 872, 872, 872, 1, 1, 1, 
	1, 1, 1, 873, 874, 875, 876, 877, 
	878, 879, 880, 881, 882, 1, 1, 883, 
	884, 885, 1, 886, 887, 1, 888, 1, 
	889, 890, 1, 891, 1, 892, 1, 1, 
	1, 1, 870, 1, 893, 894, 876, 877, 
	895, 879, 896, 897, 882, 1, 1, 883, 
	898, 899, 1, 886, 887, 1, 888, 1, 
	900, 901, 902, 903, 1, 873, 874, 875, 
	876, 877, 878, 879, 880, 881, 882, 1, 
	1, 883, 884, 885, 1, 886, 887, 1, 
	888, 1, 889, 890, 1, 891, 1, 892, 
	1, 1, 1, 1, 1, 1, 893, 894, 
	876, 877, 895, 879, 896, 897, 882, 1, 
	1, 883, 898, 899, 1, 886, 887, 1, 
	888, 1, 900, 901, 902, 903, 1, 904, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	905, 1, 1, 1, 1, 1, 906, 906, 
	906, 906, 906, 906, 906, 906, 906, 906, 
	1, 1, 1, 1, 1, 1, 907, 908, 
	909, 910, 911, 912, 913, 914, 915, 916, 
	1, 1, 917, 918, 919, 1, 920, 921, 
	1, 922, 1, 923, 924, 1, 925, 1, 
	926, 1, 1, 1, 1, 904, 1, 927, 
	928, 910, 911, 929, 913, 930, 931, 916, 
	1, 1, 917, 932, 933, 1, 920, 921, 
	1, 922, 1, 934, 935, 936, 937, 1, 
	907, 908, 909, 910, 911, 912, 913, 914, 
	915, 916, 1, 1, 917, 918, 919, 1, 
	920, 921, 1, 922, 1, 923, 924, 1, 
	925, 1, 926, 1, 1, 1, 1, 1, 
	1, 927, 928, 910, 911, 929, 913, 930, 
	931, 916, 1, 1, 917, 932, 933, 1, 
	920, 921, 1, 922, 1, 934, 935, 936, 
	937, 1, 938, 1, 1, 1, 1, 1, 
	1, 1, 1, 939, 1, 1, 1, 1, 
	1, 940, 940, 940, 940, 940, 940, 940, 
	940, 940, 940, 1, 1, 1, 1, 1, 
	1, 941, 942, 943, 944, 945, 946, 947, 
	948, 949, 950, 1, 1, 951, 952, 953, 
	1, 954, 955, 1, 956, 1, 957, 958, 
	1, 959, 1, 960, 1, 1, 1, 1, 
	938, 1, 961, 962, 944, 945, 963, 947, 
	964, 965, 950, 1, 1, 951, 966, 967, 
	1, 954, 955, 1, 956, 1, 968, 969, 
	970, 971, 1, 941, 942, 943, 944, 945, 
	946, 947, 948, 949, 950, 1, 1, 951, 
	952, 953, 1, 954, 955, 1, 956, 1, 
	957, 958, 1, 959, 1, 960, 1, 1, 
	1, 1, 1, 1, 961, 962, 944, 945, 
	963, 947, 964, 965, 950, 1, 1, 951, 
	966, 967, 1, 954, 955, 1, 956, 1, 
	968, 969, 970, 971, 1, 972, 1, 1, 
	1, 1, 1, 1, 1, 1, 973, 1, 
	1, 1, 1, 1, 974, 974, 974, 974, 
	974, 974, 974, 974, 974, 974, 1, 1, 
	1, 1, 1, 1, 975, 976, 977, 978, 
	979, 980, 981, 982, 983, 984, 1, 1, 
	985, 986, 987, 1, 988, 989, 1, 990, 
	1, 991, 992, 1, 993, 1, 994, 1, 
	1, 1, 1, 972, 1, 995, 996, 978, 
	979, 997, 981, 998, 999, 984, 1, 1, 
	985, 1000, 1001, 1, 988, 989, 1, 990, 
	1, 1002, 1003, 1004, 1005, 1, 975, 976, 
	977, 978, 979, 980, 981, 982, 983, 984, 
	1, 1, 985, 986, 987, 1, 988, 989, 
	1, 990, 1, 991, 992, 1, 993, 1, 
	994, 1, 1, 1, 1, 1, 1, 995, 
	996, 978, 979, 997, 981, 998, 999, 984, 
	1, 1, 985, 1000, 1001, 1, 988, 989, 
	1, 990, 1, 1002, 1003, 1004, 1005, 1, 
	1006, 1, 1, 1, 1, 1, 1, 1, 
	1, 1007, 1, 1, 1, 1, 1, 1008, 
	1008, 1008, 1008, 1008, 1008, 1008, 1008, 1008, 
	1008, 1, 1, 1, 1, 1, 1, 1009, 
	1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 
	1018, 1, 1, 1019, 1020, 1021, 1, 1022, 
	1023, 1, 1024, 1, 1025, 1026, 1, 1027, 
	1, 1028, 1, 1, 1, 1, 1006, 1, 
	1029, 1030, 1012, 1013, 1031, 1015, 1032, 1033, 
	1018, 1, 1, 1019, 1034, 1035, 1, 1022, 
	1023, 1, 1024, 1, 1036, 1037, 1038, 1039, 
	1, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 
	1016, 1017, 1018, 1, 1, 1019, 1020, 1021, 
	1, 1022, 1023, 1, 1024, 1, 1025, 1026, 
	1, 1027, 1, 1028, 1, 1, 1, 1, 
	1, 1, 1029, 1030, 1012, 1013, 1031, 1015, 
	1032, 1033, 1018, 1, 1, 1019, 1034, 1035, 
	1, 1022, 1023, 1, 1024, 1, 1036, 1037, 
	1038, 1039, 1, 1040, 1, 1, 1, 1, 
	1, 1, 1, 1, 1041, 1, 1, 1, 
	1, 1, 1042, 1042, 1042, 1042, 1042, 1042, 
	1042, 1042, 1042, 1042, 1, 1, 1, 1, 
	1, 1, 1043, 1044, 1045, 1046, 1047, 1048, 
	1049, 1050, 1051, 1052, 1, 1, 1053, 1054, 
	1055, 1, 1056, 1057, 1, 1058, 1, 1059, 
	1060, 1, 1061, 1, 1062, 1, 1, 1, 
	1, 1040, 1, 1063, 1064, 1046, 1047, 1065, 
	1049, 1066, 1067, 1052, 1, 1, 1053, 1068, 
	1069, 1, 1056, 1057, 1, 1058, 1, 1070, 
	1071, 1072, 1073, 1, 1043, 1044, 1045, 1046, 
	1047, 1048, 1049, 1050, 1051, 1052, 1, 1, 
	1053, 1054, 1055, 1, 1056, 1057, 1, 1058, 
	1, 1059, 1060, 1, 1061, 1, 1062, 1, 
	1, 1, 1, 1, 1, 1063, 1064, 1046, 
	1047, 1065, 1049, 1066, 1067, 1052, 1, 1, 
	1053, 1068, 1069, 1, 1056, 1057, 1, 1058, 
	1, 1070, 1071, 1072, 1073, 1, 1074, 1, 
	1, 1, 1, 1, 1, 1, 1, 1075, 
	1, 1, 1, 1, 1, 1076, 1076, 1076, 
	1076, 1076, 1076, 1076, 1076, 1076, 1076, 1, 
	1, 1, 1, 1, 1, 1077, 1078, 1079, 
	1080, 1081, 1082, 1083, 1084, 1085, 1086, 1, 
	1, 1087, 1088, 1089, 1, 1090, 1091, 1, 
	1092, 1, 1093, 1094, 1, 1095, 1, 1096, 
	1, 1, 1, 1, 1074, 1, 1097, 1098, 
	1080, 1081, 1099, 1083, 1100, 1101, 1086, 1, 
	1, 1087, 1102, 1103, 1, 1090, 1091, 1, 
	1092, 1, 1104, 1105, 1106, 1107, 1, 1077, 
	1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 
	1086, 1, 1, 1087, 1088, 1089, 1, 1090, 
	1091, 1, 1092, 1, 1093, 1094, 1, 1095, 
	1, 1096, 1, 1, 1, 1, 1, 1, 
	1097, 1098, 1080, 1081, 1099, 1083, 1100, 1101, 
	1086, 1, 1, 1087, 1102, 1103, 1, 1090, 
	1091, 1, 1092, 1, 1104, 1105, 1106, 1107, 
	1, 1108, 1, 1, 1, 1, 1, 1, 
	1, 1, 1109, 1, 1, 1, 1, 1, 
	1110, 1110, 1110, 1110, 1110, 1110, 1110, 1110, 
	1110, 1110, 1, 1, 1, 1, 1, 1, 
	1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 
	1119, 1120, 1, 1, 1121, 1122, 1123, 1, 
	1124, 1125, 1, 1126, 1, 1127, 1128, 1, 
	1129, 1, 1130, 1, 1, 1, 1, 1108, 
	1, 1131, 1132, 1114, 1115, 1133, 1117, 1134, 
	1135, 1120, 1, 1, 1121, 1136, 1137, 1, 
	1124, 1125, 1, 1126, 1, 1138, 1139, 1140, 
	1141, 1, 1111, 1112, 1113, 1114, 1115, 1116, 
	1117, 1118, 1119, 1120, 1, 1, 1121, 1122, 
	1123, 1, 1124, 1125, 1, 1126, 1, 1127, 
	1128, 1, 1129, 1, 1130, 1, 1, 1, 
	1, 1, 1, 1131, 1132, 1114, 1115, 1133, 
	1117, 1134, 1135, 1120, 1, 1, 1121, 1136, 
	1137, 1, 1124, 1125, 1, 1126, 1, 1138, 
	1139, 1140, 1141, 1, 1142, 1, 1, 1, 
	1, 1, 1, 1, 1, 1143, 1, 1, 
	1, 1, 1, 1144, 1144, 1144, 1144, 1144, 
	1144, 1144, 1144, 1144, 1144, 1, 1, 1, 
	1, 1, 1, 1145, 1146, 1147, 1148, 1149, 
	1150, 1151, 1152, 1153, 1154, 1, 1, 1155, 
	1156, 1157, 1, 1158, 1159, 1, 1160, 1, 
	1161, 1162, 1, 1163, 1, 1164, 1, 1, 
	1, 1, 1142, 1, 1165, 1166, 1148, 1149, 
	1167, 1151, 1168, 1169, 1154, 1, 1, 1155, 
	1170, 1171, 1, 1158, 1159, 1, 1160, 1, 
	1172, 1173, 1174, 1175, 1, 1145, 1146, 1147, 
	1148, 1149, 1150, 1151, 1152, 1153, 1154, 1, 
	1, 1155, 1156, 1157, 1, 1158, 1159, 1, 
	1160, 1, 1161, 1162, 1, 1163, 1, 1164, 
	1, 1, 1, 1, 1, 1, 1165, 1166, 
	1148, 1149, 1167, 1151, 1168, 1169, 1154, 1, 
	1, 1155, 1170, 1171, 1, 1158, 1159, 1, 
	1160, 1, 1172, 1173, 1174, 1175, 1, 1176, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1177, 1, 1, 1, 1, 1, 1178, 1178, 
	1178, 1178, 1178, 1178, 1178, 1178, 1178, 1178, 
	1, 1, 1, 1, 1, 1, 1179, 1180, 
	1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 
	1, 1, 1189, 1190, 1191, 1, 1192, 1193, 
	1, 1194, 1, 1195, 1196, 1, 1197, 1, 
	1198, 1, 1, 1, 1, 1176, 1, 1199, 
	1200, 1182, 1183, 1201, 1185, 1202, 1203, 1188, 
	1, 1, 1189, 1204, 1205, 1, 1192, 1193, 
	1, 1194, 1, 1206, 1207, 1208, 1209, 1, 
	1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 
	1187, 1188, 1, 1, 1189, 1190, 1191, 1, 
	1192, 1193, 1, 1194, 1, 1195, 1196, 1, 
	1197, 1, 1198, 1, 1, 1, 1, 1, 
	1, 1199, 1200, 1182, 1183, 1201, 1185, 1202, 
	1203, 1188, 1, 1, 1189, 1204, 1205, 1, 
	1192, 1193, 1, 1194, 1, 1206, 1207, 1208, 
	1209, 1, 1210, 1, 1, 1, 1, 1, 
	1, 1, 1, 1211, 1, 1, 1, 1, 
	1, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 
	1212, 1212, 1212, 1, 1, 1, 1, 1, 
	1, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 
	1220, 1221, 1222, 1, 1, 1223, 1224, 1225, 
	1, 1226, 1227, 1, 1228, 1, 1229, 1230, 
	1, 1231, 1, 1232, 1, 1, 1, 1, 
	1210, 1, 1233, 1234, 1216, 1217, 1235, 1219, 
	1236, 1237, 1222, 1, 1, 1223, 1238, 1239, 
	1, 1226, 1227, 1, 1228, 1, 1240, 1241, 
	1242, 1243, 1, 1213, 1214, 1215, 1216, 1217, 
	1218, 1219, 1220, 1221, 1222, 1, 1, 1223, 
	1224, 1225, 1, 1226, 1227, 1, 1228, 1, 
	1229, 1230, 1, 1231, 1, 1232, 1, 1, 
	1, 1, 1, 1, 1233, 1234, 1216, 1217, 
	1235, 1219, 1236, 1237, 1222, 1, 1, 1223, 
	1238, 1239, 1, 1226, 1227, 1, 1228, 1, 
	1240, 1241, 1242, 1243, 1, 1244, 1, 1, 
	1, 1, 1, 1, 1, 1, 1245, 1, 
	1, 1, 1, 1, 1246, 1246, 1246, 1246, 
	1246, 1246, 1246, 1246, 1246, 1246, 1, 1, 
	1, 1, 1, 1, 1247, 1248, 1249, 1250, 
	1251, 1252, 1253, 1254, 1255, 1256, 1, 1, 
	1257, 1258, 1259, 1, 1260, 1261, 1, 1262, 
	1, 1263, 1264, 1, 1265, 1, 1266, 1, 
	1, 1, 1, 1244, 1, 1267, 1268, 1250, 
	1251, 1269, 1253, 1270, 1271, 1256, 1, 1, 
	1257, 1272, 1273, 1, 1260, 1261, 1, 1262, 
	1, 1274, 1275, 1276, 1277, 1, 1247, 1248, 
	1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 
	1, 1, 1257, 1258, 1259, 1, 1260, 1261, 
	1, 1262, 1, 1263, 1264, 1, 1265, 1, 
	1266, 1, 1, 1, 1, 1, 1, 1267, 
	1268, 1250, 1251, 1269, 1253, 1270, 1271, 1256, 
	1, 1, 1257, 1272, 1273, 1, 1260, 1261, 
	1, 1262, 1, 1274, 1275, 1276, 1277, 1, 
	1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 
	1286, 1287, 1, 1, 1288, 1289, 1290, 1, 
	1291, 1292, 1, 1293, 1, 1294, 1295, 1, 
	1296, 1, 1297, 1, 1, 1, 1, 1, 
	1, 1298, 1299, 1281, 1282, 1300, 1284, 1301, 
	1302, 1287, 1, 1, 1288, 1303, 1304, 1, 
	1291, 1292, 1, 1293, 1, 1305, 1306, 1307, 
	1308, 1, 1309, 1309, 1309, 1309, 1309, 1309, 
	1309, 1309, 1309, 1309, 1, 1, 1, 1, 
	1, 1, 1247, 1248, 1249, 1250, 1251, 1252, 
	1253, 1254, 1255, 1256, 1, 1, 1257, 1258, 
	1259, 1, 1260, 1261, 1, 1262, 1, 1263, 
	1264, 1, 1265, 1, 1266, 1, 1, 1, 
	1, 1, 1, 1267, 1268, 1250, 1251, 1269, 
	1253, 1270, 1271, 1256, 1, 1, 1257, 1272, 
	1273, 1, 1260, 1261, 1, 1262, 1, 1274, 
	1275, 1276, 1277, 1, 1310, 1311, 1312, 1313, 
	1314, 1315, 1316, 1317, 1318, 1319, 1, 1, 
	1320, 1321, 1322, 1, 1323, 1324, 1, 1325, 
	1, 1326, 1327, 1, 1328, 1, 1329, 1, 
	1, 1, 1, 1, 1, 1330, 1331, 1313, 
	1314, 1332, 1316, 1333, 1334, 1319, 1, 1, 
	1320, 1335, 1336, 1, 1323, 1324, 1, 1325, 
	1, 1337, 1338, 1339, 1340, 1, 1341, 1341, 
	1341, 1341, 1341, 1341, 1341, 1341, 1341, 1341, 
	1, 1, 1, 1, 1, 1, 1213, 1214, 
	1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 
	1, 1, 1223, 1224, 1225, 1, 1226, 1227, 
	1, 1228, 1, 1229, 1230, 1, 1231, 1, 
	1232, 1, 1, 1, 1, 1, 1, 1233, 
	1234, 1216, 1217, 1235, 1219, 1236, 1237, 1222, 
	1, 1, 1223, 1238, 1239, 1, 1226, 1227, 
	1, 1228, 1, 1240, 1241, 1242, 1243, 1, 
	1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 
	1350, 1351, 1, 1, 1352, 1353, 1354, 1, 
	1355, 1356, 1, 1357, 1, 1358, 1359, 1, 
	1360, 1, 1361, 1, 1, 1, 1, 1, 
	1, 1362, 1363, 1345, 1346, 1364, 1348, 1365, 
	1366, 1351, 1, 1, 1352, 1367, 1368, 1, 
	1355, 1356, 1, 1357, 1, 1369, 1370, 1371, 
	1372, 1, 1373, 1373, 1373, 1373, 1373, 1373, 
	1373, 1373, 1373, 1373, 1, 1, 1, 1, 
	1, 1, 1179, 1180, 1181, 1182, 1183, 1184, 
	1185, 1186, 1187, 1188, 1, 1, 1189, 1190, 
	1191, 1, 1192, 1193, 1, 1194, 1, 1195, 
	1196, 1, 1197, 1, 1198, 1, 1, 1, 
	1, 1, 1, 1199, 1200, 1182, 1183, 1201, 
	1185, 1202, 1203, 1188, 1, 1, 1189, 1204, 
	1205, 1, 1192, 1193, 1, 1194, 1, 1206, 
	1207, 1208, 1209, 1, 1374, 1375, 1376, 1377, 
	1378, 1379, 1380, 1381, 1382, 1383, 1, 1, 
	1384, 1385, 1386, 1, 1387, 1388, 1, 1389, 
	1, 1390, 1391, 1, 1392, 1, 1393, 1, 
	1, 1, 1, 1, 1, 1394, 1395, 1377, 
	1378, 1396, 1380, 1397, 1398, 1383, 1, 1, 
	1384, 1399, 1400, 1, 1387, 1388, 1, 1389, 
	1, 1401, 1402, 1403, 1404, 1, 1405, 1405, 
	1405, 1405, 1405, 1405, 1405, 1405, 1405, 1405, 
	1, 1, 1, 1, 1, 1, 1145, 1146, 
	1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 
	1, 1, 1155, 1156, 1157, 1, 1158, 1159, 
	1, 1160, 1, 1161, 1162, 1, 1163, 1, 
	1164, 1, 1, 1, 1, 1, 1, 1165, 
	1166, 1148, 1149, 1167, 1151, 1168, 1169, 1154, 
	1, 1, 1155, 1170, 1171, 1, 1158, 1159, 
	1, 1160, 1, 1172, 1173, 1174, 1175, 1, 
	1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 
	1414, 1415, 1, 1, 1416, 1417, 1418, 1, 
	1419, 1420, 1, 1421, 1, 1422, 1423, 1, 
	1424, 1, 1425, 1, 1, 1, 1, 1, 
	1, 1426, 1427, 1409, 1410, 1428, 1412, 1429, 
	1430, 1415, 1, 1, 1416, 1431, 1432, 1, 
	1419, 1420, 1, 1421, 1, 1433, 1434, 1435, 
	1436, 1, 1437, 1437, 1437, 1437, 1437, 1437, 
	1437, 1437, 1437, 1437, 1, 1, 1, 1, 
	1, 1, 1111, 1112, 1113, 1114, 1115, 1116, 
	1117, 1118, 1119, 1120, 1, 1, 1121, 1122, 
	1123, 1, 1124, 1125, 1, 1126, 1, 1127, 
	1128, 1, 1129, 1, 1130, 1, 1, 1, 
	1, 1, 1, 1131, 1132, 1114, 1115, 1133, 
	1117, 1134, 1135, 1120, 1, 1, 1121, 1136, 
	1137, 1, 1124, 1125, 1, 1126, 1, 1138, 
	1139, 1140, 1141, 1, 1438, 1439, 1440, 1441, 
	1442, 1443, 1444, 1445, 1446, 1447, 1, 1, 
	1448, 1449, 1450, 1, 1451, 1452, 1, 1453, 
	1, 1454, 1455, 1, 1456, 1, 1457, 1, 
	1, 1, 1, 1, 1, 1458, 1459, 1441, 
	1442, 1460, 1444, 1461, 1462, 1447, 1, 1, 
	1448, 1463, 1464, 1, 1451, 1452, 1, 1453, 
	1, 1465, 1466, 1467, 1468, 1, 1469, 1469, 
	1469, 1469, 1469, 1469, 1469, 1469, 1469, 1469, 
	1, 1, 1, 1, 1, 1, 1077, 1078, 
	1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 
	1, 1, 1087, 1088, 1089, 1, 1090, 1091, 
	1, 1092, 1, 1093, 1094, 1, 1095, 1, 
	1096, 1, 1, 1, 1, 1, 1, 1097, 
	1098, 1080, 1081, 1099, 1083, 1100, 1101, 1086, 
	1, 1, 1087, 1102, 1103, 1, 1090, 1091, 
	1, 1092, 1, 1104, 1105, 1106, 1107, 1, 
	1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 
	1478, 1479, 1, 1, 1480, 1481, 1482, 1, 
	1483, 1484, 1, 1485, 1, 1486, 1487, 1, 
	1488, 1, 1489, 1, 1, 1, 1, 1, 
	1, 1490, 1491, 1473, 1474, 1492, 1476, 1493, 
	1494, 1479, 1, 1, 1480, 1495, 1496, 1, 
	1483, 1484, 1, 1485, 1, 1497, 1498, 1499, 
	1500, 1, 1501, 1501, 1501, 1501, 1501, 1501, 
	1501, 1501, 1501, 1501, 1, 1, 1, 1, 
	1, 1, 1043, 1044, 1045, 1046, 1047, 1048, 
	1049, 1050, 1051, 1052, 1, 1, 1053, 1054, 
	1055, 1, 1056, 1057, 1, 1058, 1, 1059, 
	1060, 1, 1061, 1, 1062, 1, 1, 1, 
	1, 1, 1, 1063, 1064, 1046, 1047, 1065, 
	1049, 1066, 1067, 1052, 1, 1, 1053, 1068, 
	1069, 1, 1056, 1057, 1, 1058, 1, 1070, 
	1071, 1072, 1073, 1, 1502, 1503, 1504, 1505, 
	1506, 1507, 1508, 1509, 1510, 1511, 1, 1, 
	1512, 1513, 1514, 1, 1515, 1516, 1, 1517, 
	1, 1518, 1519, 1, 1520, 1, 1521, 1, 
	1, 1, 1, 1, 1, 1522, 1523, 1505, 
	1506, 1524, 1508, 1525, 1526, 1511, 1, 1, 
	1512, 1527, 1528, 1, 1515, 1516, 1, 1517, 
	1, 1529, 1530, 1531, 1532, 1, 1533, 1533, 
	1533, 1533, 1533, 1533, 1533, 1533, 1533, 1533, 
	1, 1, 1, 1, 1, 1, 1009, 1010, 
	1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 
	1, 1, 1019, 1020, 1021, 1, 1022, 1023, 
	1, 1024, 1, 1025, 1026, 1, 1027, 1, 
	1028, 1, 1, 1, 1, 1, 1, 1029, 
	1030, 1012, 1013, 1031, 1015, 1032, 1033, 1018, 
	1, 1, 1019, 1034, 1035, 1, 1022, 1023, 
	1, 1024, 1, 1036, 1037, 1038, 1039, 1, 
	1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 
	1542, 1543, 1, 1, 1544, 1545, 1546, 1, 
	1547, 1548, 1, 1549, 1, 1550, 1551, 1, 
	1552, 1, 1553, 1, 1, 1, 1, 1, 
	1, 1554, 1555, 1537, 1538, 1556, 1540, 1557, 
	1558, 1543, 1, 1, 1544, 1559, 1560, 1, 
	1547, 1548, 1, 1549, 1, 1561, 1562, 1563, 
	1564, 1, 1565, 1565, 1565, 1565, 1565, 1565, 
	1565, 1565, 1565, 1565, 1, 1, 1, 1, 
	1, 1, 975, 976, 977, 978, 979, 980, 
	981, 982, 983, 984, 1, 1, 985, 986, 
	987, 1, 988, 989, 1, 990, 1, 991, 
	992, 1, 993, 1, 994, 1, 1, 1, 
	1, 1, 1, 995, 996, 978, 979, 997, 
	981, 998, 999, 984, 1, 1, 985, 1000, 
	1001, 1, 988, 989, 1, 990, 1, 1002, 
	1003, 1004, 1005, 1, 1566, 1567, 1568, 1569, 
	1570, 1571, 1572, 1573, 1574, 1575, 1, 1, 
	1576, 1577, 1578, 1, 1579, 1580, 1, 1581, 
	1, 1582, 1583, 1, 1584, 1, 1585, 1, 
	1, 1, 1, 1, 1, 1586, 1587, 1569, 
	1570, 1588, 1572, 1589, 1590, 1575, 1, 1, 
	1576, 1591, 1592, 1, 1579, 1580, 1, 1581, 
	1, 1593, 1594, 1595, 1596, 1, 1597, 1597, 
	1597, 1597, 1597, 1597, 1597, 1597, 1597, 1597, 
	1, 1, 1, 1, 1, 1, 941, 942, 
	943, 944, 945, 946, 947, 948, 949, 950, 
	1, 1, 951, 952, 953, 1, 954, 955, 
	1, 956, 1, 957, 958, 1, 959, 1, 
	960, 1, 1, 1, 1, 1, 1, 961, 
	962, 944, 945, 963, 947, 964, 965, 950, 
	1, 1, 951, 966, 967, 1, 954, 955, 
	1, 956, 1, 968, 969, 970, 971, 1, 
	1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 
	1606, 1607, 1, 1, 1608, 1609, 1610, 1, 
	1611, 1612, 1, 1613, 1, 1614, 1615, 1, 
	1616, 1, 1617, 1, 1, 1, 1, 1, 
	1, 1618, 1619, 1601, 1602, 1620, 1604, 1621, 
	1622, 1607, 1, 1, 1608, 1623, 1624, 1, 
	1611, 1612, 1, 1613, 1, 1625, 1626, 1627, 
	1628, 1, 1629, 1629, 1629, 1629, 1629, 1629, 
	1629, 1629, 1629, 1629, 1, 1, 1, 1, 
	1, 1, 907, 908, 909, 910, 911, 912, 
	913, 914, 915, 916, 1, 1, 917, 918, 
	919, 1, 920, 921, 1, 922, 1, 923, 
	924, 1, 925, 1, 926, 1, 1, 1, 
	1, 1, 1, 927, 928, 910, 911, 929, 
	913, 930, 931, 916, 1, 1, 917, 932, 
	933, 1, 920, 921, 1, 922, 1, 934, 
	935, 936, 937, 1, 1630, 1631, 1632, 1633, 
	1634, 1635, 1636, 1637, 1638, 1639, 1, 1, 
	1640, 1641, 1642, 1, 1643, 1644, 1, 1645, 
	1, 1646, 1647, 1, 1648, 1, 1649, 1, 
	1, 1, 1, 1, 1, 1650, 1651, 1633, 
	1634, 1652, 1636, 1653, 1654, 1639, 1, 1, 
	1640, 1655, 1656, 1, 1643, 1644, 1, 1645, 
	1, 1657, 1658, 1659, 1660, 1, 1661, 1661, 
	1661, 1661, 1661, 1661, 1661, 1661, 1661, 1661, 
	1, 1, 1, 1, 1, 1, 873, 874, 
	875, 876, 877, 878, 879, 880, 881, 882, 
	1, 1, 883, 884, 885, 1, 886, 887, 
	1, 888, 1, 889, 890, 1, 891, 1, 
	892, 1, 1, 1, 1, 1, 1, 893, 
	894, 876, 877, 895, 879, 896, 897, 882, 
	1, 1, 883, 898, 899, 1, 886, 887, 
	1, 888, 1, 900, 901, 902, 903, 1, 
	1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 
	1670, 1671, 1, 1, 1672, 1673, 1674, 1, 
	1675, 1676, 1, 1677, 1, 1678, 1679, 1, 
	1680, 1, 1681, 1, 1, 1, 1, 1, 
	1, 1682, 1683, 1665, 1666, 1684, 1668, 1685, 
	1686, 1671, 1, 1, 1672, 1687, 1688, 1, 
	1675, 1676, 1, 1677, 1, 1689, 1690, 1691, 
	1692, 1, 1693, 1693, 1693, 1693, 1693, 1693, 
	1693, 1693, 1693, 1693, 1, 1, 1, 1, 
	1, 1, 839, 840, 841, 842, 843, 844, 
	845, 846, 847, 848, 1, 1, 849, 850, 
	851, 1, 852, 853, 1, 854, 1, 855, 
	856, 1, 857, 1, 858, 1, 1, 1, 
	1, 1, 1, 859, 860, 842, 843, 861, 
	845, 862, 863, 848, 1, 1, 849, 864, 
	865, 1, 852, 853, 1, 854, 1, 866, 
	867, 868, 869, 1, 1694, 1695, 1696, 1697, 
	1698, 1699, 1700, 1701, 1702, 1703, 1, 1, 
	1704, 1705, 1706, 1, 1707, 1708, 1, 1709, 
	1, 1710, 1711, 1, 1712, 1, 1713, 1, 
	1, 1, 1, 1, 1, 1714, 1715, 1697, 
	1698, 1716, 1700, 1717, 1718, 1703, 1, 1, 
	1704, 1719, 1720, 1, 1707, 1708, 1, 1709, 
	1, 1721, 1722, 1723, 1724, 1, 1725, 1725, 
	1725, 1725, 1725, 1725, 1725, 1725, 1725, 1725, 
	1, 1, 1, 1, 1, 1, 805, 806, 
	807, 808, 809, 810, 811, 812, 813, 814, 
	1, 1, 815, 816, 817, 1, 818, 819, 
	1, 820, 1, 821, 822, 1, 823, 1, 
	824, 1, 1, 1, 1, 1, 1, 825, 
	826, 808, 809, 827, 811, 828, 829, 814, 
	1, 1, 815, 830, 831, 1, 818, 819, 
	1, 820, 1, 832, 833, 834, 835, 1, 
	1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 
	1734, 1735, 1, 1, 1736, 1737, 1738, 1, 
	1739, 1740, 1, 1741, 1, 1742, 1743, 1, 
	1744, 1, 1745, 1, 1, 1, 1, 1, 
	1, 1746, 1747, 1729, 1730, 1748, 1732, 1749, 
	1750, 1735, 1, 1, 1736, 1751, 1752, 1, 
	1739, 1740, 1, 1741, 1, 1753, 1754, 1755, 
	1756, 1, 1757, 1757, 1757, 1757, 1757, 1757, 
	1757, 1757, 1757, 1757, 1, 1, 1, 1, 
	1, 1, 771, 772, 773, 774, 775, 776, 
	777, 778, 779, 780, 1, 1, 781, 782, 
	783, 1, 784, 785, 1, 786, 1, 787, 
	788, 1, 789, 1, 790, 1, 1, 1, 
	1, 1, 1, 791, 792, 774, 775, 793, 
	777, 794, 795, 780, 1, 1, 781, 796, 
	797, 1, 784, 785, 1, 786, 1, 798, 
	799, 800, 801, 1, 1758, 1758, 1758, 1758, 
	1758, 1758, 1758, 1758, 1758, 1758, 1, 1, 
	1, 1, 1, 1, 673, 674, 675, 676, 
	677, 678, 679, 680, 681, 682, 1, 1, 
	683, 684, 685, 1, 686, 687, 1, 688, 
	1, 689, 690, 1, 691, 1, 692, 1, 
	1, 1, 1, 1, 1, 693, 694, 676, 
	677, 695, 679, 696, 697, 682, 1, 1, 
	683, 698, 699, 1, 686, 687, 1, 688, 
	1, 700, 701, 702, 703, 1, 1759, 1760, 
	1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 
	1, 1, 1769, 1770, 1771, 1, 1772, 1773, 
	1, 1774, 1, 1775, 1776, 1, 1777, 1, 
	1778, 1, 1, 1, 1, 1, 1, 1779, 
	1780, 1762, 1763, 1781, 1765, 1782, 1783, 1768, 
	1, 1, 1769, 1784, 1785, 1, 1772, 1773, 
	1, 1774, 1, 1786, 1787, 1788, 1789, 1, 
	1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 
	1790, 1790, 1, 1, 1, 1, 1, 1, 
	639, 640, 641, 642, 643, 644, 645, 646, 
	647, 648, 1, 1, 649, 650, 651, 1, 
	652, 653, 1, 654, 1, 655, 656, 1, 
	657, 1, 658, 1, 1, 1, 1, 1, 
	1, 659, 660, 642, 643, 661, 645, 662, 
	663, 648, 1, 1, 649, 664, 665, 1, 
	652, 653, 1, 654, 1, 666, 667, 668, 
	669, 1, 1791, 1792, 1793, 1794, 1795, 1796, 
	1797, 1798, 1799, 1800, 1, 1, 1801, 1802, 
	1803, 1, 1804, 1805, 1, 1806, 1, 1807, 
	1808, 1, 1809, 1, 1810, 1, 1, 1, 
	1, 1, 1, 1811, 1812, 1794, 1795, 1813, 
	1797, 1814, 1815, 1800, 1, 1, 1801, 1816, 
	1817, 1, 1804, 1805, 1, 1806, 1, 1818, 
	1819, 1820, 1821, 1, 1822, 1822, 1822, 1822, 
	1822, 1822, 1822, 1822, 1822, 1822, 1, 1, 
	1, 1, 1, 1, 605, 606, 607, 608, 
	609, 610, 611, 612, 613, 614, 1, 1, 
	615, 616, 617, 1, 618, 619, 1, 620, 
	1, 621, 622, 1, 623, 1, 624, 1, 
	1, 1, 1, 1, 1, 625, 626, 608, 
	609, 627, 611, 628, 629, 614, 1, 1, 
	615, 630, 631, 1, 618, 619, 1, 620, 
	1, 632, 633, 634, 635, 1, 1823, 1824, 
	1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 
	1, 1, 1833, 1834, 1835, 1, 1836, 1837, 
	1, 1838, 1, 1839, 1840, 1, 1841, 1, 
	1842, 1, 1, 1, 1, 1, 1, 1843, 
	1844, 1826, 1827, 1845, 1829, 1846, 1847, 1832, 
	1, 1, 1833, 1848, 1849, 1, 1836, 1837, 
	1, 1838, 1, 1850, 1851, 1852, 1853, 1, 
	1854, 1854, 1854, 1854, 1854, 1854, 1854, 1854, 
	1854, 1854, 1, 1, 1, 1, 1, 1, 
	571, 572, 573, 574, 575, 576, 577, 578, 
	579, 580, 1, 1, 581, 582, 583, 1, 
	584, 585, 1, 586, 1, 587, 588, 1, 
	589, 1, 590, 1, 1, 1, 1, 1, 
	1, 591, 592, 574, 575, 593, 577, 594, 
	595, 580, 1, 1, 581, 596, 597, 1, 
	584, 585, 1, 586, 1, 598, 599, 600, 
	601, 1, 1855, 1856, 1857, 1858, 1859, 1860, 
	1861, 1862, 1863, 1864, 1, 1, 1865, 1866, 
	1867, 1, 1868, 1869, 1, 1870, 1, 1871, 
	1872, 1, 1873, 1, 1874, 1, 1, 1, 
	1, 1, 1, 1875, 1876, 1858, 1859, 1877, 
	1861, 1878, 1879, 1864, 1, 1, 1865, 1880, 
	1881, 1, 1868, 1869, 1, 1870, 1, 1882, 
	1883, 1884, 1885, 1, 1886, 1886, 1886, 1886, 
	1886, 1886, 1886, 1886, 1886, 1886, 1, 1, 
	1, 1, 1, 1, 537, 538, 539, 540, 
	541, 542, 543, 544, 545, 546, 1, 1, 
	547, 548, 549, 1, 550, 551, 1, 552, 
	1, 553, 554, 1, 555, 1, 556, 1, 
	1, 1, 1, 1, 1, 557, 558, 540, 
	541, 559, 543, 560, 561, 546, 1, 1, 
	547, 562, 563, 1, 550, 551, 1, 552, 
	1, 564, 565, 566, 567, 1, 1887, 1887, 
	1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 
	1, 1, 1, 1, 1, 1, 439, 440, 
	441, 442, 443, 444, 445, 446, 447, 448, 
	1, 1, 449, 450, 451, 1, 452, 453, 
	1, 454, 1, 455, 456, 1, 457, 1, 
	458, 1, 1, 1, 1, 1, 1, 459, 
	460, 442, 443, 461, 445, 462, 463, 448, 
	1, 1, 449, 464, 465, 1, 452, 453, 
	1, 454, 1, 466, 467, 468, 469, 1, 
	1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 
	1888, 1888, 1, 1, 1, 1, 1, 1, 
	341, 342, 343, 344, 345, 346, 347, 348, 
	349, 350, 1, 1, 351, 352, 353, 1, 
	354, 355, 1, 356, 1, 357, 358, 1, 
	359, 1, 360, 1, 1, 1, 1, 1, 
	1, 361, 362, 344, 345, 363, 347, 364, 
	365, 350, 1, 1, 351, 366, 367, 1, 
	354, 355, 1, 356, 1, 368, 369, 370, 
	371, 1, 1889, 1890, 1891, 1892, 1893, 1894, 
	1895, 1896, 1897, 1898, 1, 1, 1899, 1900, 
	1901, 1, 1902, 1903, 1, 1904, 1, 1905, 
	1906, 1, 1907, 1, 1908, 1, 1, 1, 
	1, 1, 1, 1909, 1910, 1892, 1893, 1911, 
	1895, 1912, 1913, 1898, 1, 1, 1899, 1914, 
	1915, 1, 1902, 1903, 1, 1904, 1, 1916, 
	1917, 1918, 1919, 1, 1920, 1920, 1920, 1920, 
	1920, 1920, 1920, 1920, 1920, 1920, 1, 1, 
	1, 1, 1, 1, 307, 308, 309, 310, 
	311, 312, 313, 314, 315, 316, 1, 1, 
	317, 318, 319, 1, 320, 321, 1, 322, 
	1, 323, 324, 1, 325, 1, 326, 1, 
	1, 1, 1, 1, 1, 327, 328, 310, 
	311, 329, 313, 330, 331, 316, 1, 1, 
	317, 332, 333, 1, 320, 321, 1, 322, 
	1, 334, 335, 336, 337, 1, 1921, 1922, 
	1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 
	1, 1, 1931, 1932, 1933, 1, 1934, 1935, 
	1, 1936, 1, 1937, 1938, 1, 1939, 1, 
	1940, 1, 1, 1, 1, 1, 1, 1941, 
	1942, 1924, 1925, 1943, 1927, 1944, 1945, 1930, 
	1, 1, 1931, 1946, 1947, 1, 1934, 1935, 
	1, 1936, 1, 1948, 1949, 1950, 1951, 1, 
	1952, 1952, 1952, 1952, 1952, 1952, 1952, 1952, 
	1952, 1952, 1, 1, 1, 1, 1, 1, 
	273, 274, 275, 276, 277, 278, 279, 280, 
	281, 282, 1, 1, 283, 284, 285, 1, 
	286, 287, 1, 288, 1, 289, 290, 1, 
	291, 1, 292, 1, 1, 1, 1, 1, 
	1, 293, 294, 276, 277, 295, 279, 296, 
	297, 282, 1, 1, 283, 298, 299, 1, 
	286, 287, 1, 288, 1, 300, 301, 302, 
	303, 1, 1953, 1954, 1955, 1956, 1957, 1958, 
	1959, 1960, 1961, 1962, 1, 1, 1963, 1964, 
	1965, 1, 1966, 1967, 1, 1968, 1, 1969, 
	1970, 1, 1971, 1, 1972, 1, 1, 1, 
	1, 1, 1, 1973, 1974, 1956, 1957, 1975, 
	1959, 1976, 1977, 1962, 1, 1, 1963, 1978, 
	1979, 1, 1966, 1967, 1, 1968, 1, 1980, 
	1981, 1982, 1983, 1, 1984, 1984, 1984, 1984, 
	1984, 1984, 1984, 1984, 1984, 1984, 1, 1, 
	1, 1, 1, 1, 239, 240, 241, 242, 
	243, 244, 245, 246, 247, 248, 1, 1, 
	249, 250, 251, 1, 252, 253, 1, 254, 
	1, 255, 256, 1, 257, 1, 258, 1, 
	1, 1, 1, 1, 1, 259, 260, 242, 
	243, 261, 245, 262, 263, 248, 1, 1, 
	249, 264, 265, 1, 252, 253, 1, 254, 
	1, 266, 267, 268, 269, 1, 1985, 1986, 
	1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 
	1, 1, 1995, 1996, 1997, 1, 1998, 1999, 
	1, 2000, 1, 2001, 2002, 1, 2003, 1, 
	2004, 1, 1, 1, 1, 1, 1, 2005, 
	2006, 1988, 1989, 2007, 1991, 2008, 2009, 1994, 
	1, 1, 1995, 2010, 2011, 1, 1998, 1999, 
	1, 2000, 1, 2012, 2013, 2014, 2015, 1, 
	2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 
	2016, 2016, 1, 1, 1, 1, 1, 1, 
	205, 206, 207, 208, 209, 210, 211, 212, 
	213, 214, 1, 1, 215, 216, 217, 1, 
	218, 219, 1, 220, 1, 221, 222, 1, 
	223, 1, 224, 1, 1, 1, 1, 1, 
	1, 225, 226, 208, 209, 227, 211, 228, 
	229, 214, 1, 1, 215, 230, 231, 1, 
	218, 219, 1, 220, 1, 232, 233, 234, 
	235, 1, 2017, 2018, 2019, 2020, 2021, 2022, 
	2023, 2024, 2025, 2026, 1, 1, 2027, 2028, 
	2029, 1, 2030, 2031, 1, 2032, 1, 2033, 
	2034, 1, 2035, 1, 2036, 1, 1, 1, 
	1, 1, 1, 2037, 2038, 2020, 2021, 2039, 
	2023, 2040, 2041, 2026, 1, 1, 2027, 2042, 
	2043, 1, 2030, 2031, 1, 2032, 1, 2044, 
	2045, 2046, 2047, 1, 2048, 2048, 2048, 2048, 
	2048, 2048, 2048, 2048, 2048, 2048, 1, 1, 
	1, 1, 1, 1, 171, 172, 173, 174, 
	175, 176, 177, 178, 179, 180, 1, 1, 
	181, 182, 183, 1, 184, 185, 1, 186, 
	1, 187, 188, 1, 189, 1, 190, 1, 
	1, 1, 1, 1, 1, 191, 192, 174, 
	175, 193, 177, 194, 195, 180, 1, 1, 
	181, 196, 197, 1, 184, 185, 1, 186, 
	1, 198, 199, 200, 201, 1, 2049, 2050, 
	2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 
	1, 1, 2059, 2060, 2061, 1, 2062, 2063, 
	1, 2064, 1, 2065, 2066, 1, 2067, 1, 
	2068, 1, 1, 1, 1, 1, 1, 2069, 
	2070, 2052, 2053, 2071, 2055, 2072, 2073, 2058, 
	1, 1, 2059, 2074, 2075, 1, 2062, 2063, 
	1, 2064, 1, 2076, 2077, 2078, 2079, 1, 
	2080, 2080, 2080, 2080, 2080, 2080, 2080, 2080, 
	2080, 2080, 1, 1, 1, 1, 1, 1, 
	137, 138, 139, 140, 141, 142, 143, 144, 
	145, 146, 1, 1, 147, 148, 149, 1, 
	150, 151, 1, 152, 1, 153, 154, 1, 
	155, 1, 156, 1, 1, 1, 1, 1, 
	1, 157, 158, 140, 141, 159, 143, 160, 
	161, 146, 1, 1, 147, 162, 163, 1, 
	150, 151, 1, 152, 1, 164, 165, 166, 
	167, 1, 2081, 2082, 2083, 2084, 2085, 2086, 
	2087, 2088, 2089, 2090, 1, 1, 2091, 2092, 
	2093, 1, 2094, 2095, 1, 2096, 1, 2097, 
	2098, 1, 2099, 1, 2100, 1, 1, 1, 
	1, 1, 1, 2101, 2102, 2084, 2085, 2103, 
	2087, 2104, 2105, 2090, 1, 1, 2091, 2106, 
	2107, 1, 2094, 2095, 1, 2096, 1, 2108, 
	2109, 2110, 2111, 1, 2112, 2112, 2112, 2112, 
	2112, 2112, 2112, 2112, 2112, 2112, 1, 1, 
	1, 1, 1, 1, 103, 104, 105, 106, 
	107, 108, 109, 110, 111, 112, 1, 1, 
	113, 114, 115, 1, 116, 117, 1, 118, 
	1, 119, 120, 1, 121, 1, 122, 1, 
	1, 1, 1, 1, 1, 123, 124, 106, 
	107, 125, 109, 126, 127, 112, 1, 1, 
	113, 128, 129, 1, 116, 117, 1, 118, 
	1, 130, 131, 132, 133, 1, 2113, 2114, 
	2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 
	1, 1, 2123, 2124, 2125, 1, 2126, 2127, 
	1, 2128, 1, 2129, 2130, 1, 2131, 1, 
	2132, 1, 1, 1, 1, 1, 1, 2133, 
	2134, 2116, 2117, 2135, 2119, 2136, 2137, 2122, 
	1, 1, 2123, 2138, 2139, 1, 2126, 2127, 
	1, 2128, 1, 2140, 2141, 2142, 2143, 1, 
	2144, 2144, 2144, 2144, 2144, 2144, 2144, 2144, 
	2144, 2144, 1, 1, 1, 1, 1, 1, 
	69, 70, 71, 72, 73, 74, 75, 76, 
	77, 78, 1, 1, 79, 80, 81, 1, 
	82, 83, 1, 84, 1, 85, 86, 1, 
	87, 1, 88, 1, 1, 1, 1, 1, 
	1, 89, 90, 72, 73, 91, 75, 92, 
	93, 78, 1, 1, 79, 94, 95, 1, 
	82, 83, 1, 84, 1, 96, 97, 98, 
	99, 1, 2145, 2146, 2147, 2148, 2149, 2150, 
	2151, 2152, 2153, 2154, 1, 1, 2155, 2156, 
	2157, 1, 2158, 2159, 1, 2160, 1, 2161, 
	2162, 1, 2163, 1, 2164, 1, 1, 1, 
	1, 1, 1, 2165, 2166, 2148, 2149, 2167, 
	2151, 2168, 2169, 2154, 1, 1, 2155, 2170, 
	2171, 1, 2158, 2159, 1, 2160, 1, 2172, 
	2173, 2174, 2175, 1, 2176, 2176, 2176, 2176, 
	2176, 2176, 2176, 2176, 2176, 2176, 1, 1, 
	1, 1, 1, 1, 35, 36, 37, 38, 
	39, 40, 41, 42, 43, 44, 1, 1, 
	45, 46, 47, 1, 48, 49, 1, 50, 
	1, 51, 52, 1, 53, 1, 54, 1, 
	1, 1, 1, 1, 1, 55, 56, 38, 
	39, 57, 41, 58, 59, 44, 1, 1, 
	45, 60, 61, 1, 48, 49, 1, 50, 
	1, 62, 63, 64, 65, 1, 0
};

static const char _trans_targs[] = {
	2, 0, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	3, 124, 125, 2, 4, 6, 8, 10, 
	12, 14, 16, 18, 20, 23, 26, 28, 
	30, 32, 34, 37, 39, 41, 43, 45, 
	47, 49, 51, 53, 55, 57, 59, 61, 
	63, 65, 5, 122, 123, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 23, 
	26, 28, 30, 32, 34, 37, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 57, 
	59, 61, 63, 65, 7, 120, 121, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 9, 118, 
	119, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	11, 116, 117, 2, 4, 6, 8, 10, 
	12, 14, 16, 18, 20, 23, 26, 28, 
	30, 32, 34, 37, 39, 41, 43, 45, 
	47, 49, 51, 53, 55, 57, 59, 61, 
	63, 65, 13, 114, 115, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 23, 
	26, 28, 30, 32, 34, 37, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 57, 
	59, 61, 63, 65, 15, 112, 113, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 17, 110, 
	111, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	19, 108, 109, 2, 4, 6, 8, 10, 
	12, 14, 16, 18, 20, 23, 26, 28, 
	30, 32, 34, 37, 39, 41, 43, 45, 
	47, 49, 51, 53, 55, 57, 59, 61, 
	63, 65, 21, 22, 107, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 23, 
	26, 28, 30, 32, 34, 37, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 57, 
	59, 61, 63, 65, 22, 107, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 23, 
	26, 28, 30, 32, 34, 37, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 57, 
	59, 61, 63, 65, 24, 25, 106, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 25, 106, 
	2, 4, 6, 8, 10, 12, 14, 16, 
	18, 20, 23, 26, 28, 30, 32, 34, 
	37, 39, 41, 43, 45, 47, 49, 51, 
	53, 55, 57, 59, 61, 63, 65, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 27, 104, 
	105, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	29, 102, 103, 2, 4, 6, 8, 10, 
	12, 14, 16, 18, 20, 23, 26, 28, 
	30, 32, 34, 37, 39, 41, 43, 45, 
	47, 49, 51, 53, 55, 57, 59, 61, 
	63, 65, 31, 100, 101, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 23, 
	26, 28, 30, 32, 34, 37, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 57, 
	59, 61, 63, 65, 33, 98, 99, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 35, 36, 
	97, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	36, 97, 2, 4, 6, 8, 10, 12, 
	14, 16, 18, 20, 23, 26, 28, 30, 
	32, 34, 37, 39, 41, 43, 45, 47, 
	49, 51, 53, 55, 57, 59, 61, 63, 
	65, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	38, 95, 96, 2, 4, 6, 8, 10, 
	12, 14, 16, 18, 20, 23, 26, 28, 
	30, 32, 34, 37, 39, 41, 43, 45, 
	47, 49, 51, 53, 55, 57, 59, 61, 
	63, 65, 40, 93, 94, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 23, 
	26, 28, 30, 32, 34, 37, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 57, 
	59, 61, 63, 65, 42, 91, 92, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 44, 89, 
	90, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	46, 87, 88, 2, 4, 6, 8, 10, 
	12, 14, 16, 18, 20, 23, 26, 28, 
	30, 32, 34, 37, 39, 41, 43, 45, 
	47, 49, 51, 53, 55, 57, 59, 61, 
	63, 65, 48, 85, 86, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 23, 
	26, 28, 30, 32, 34, 37, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 57, 
	59, 61, 63, 65, 50, 83, 84, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 52, 81, 
	82, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	54, 79, 80, 2, 4, 6, 8, 10, 
	12, 14, 16, 18, 20, 23, 26, 28, 
	30, 32, 34, 37, 39, 41, 43, 45, 
	47, 49, 51, 53, 55, 57, 59, 61, 
	63, 65, 56, 77, 78, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 23, 
	26, 28, 30, 32, 34, 37, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 57, 
	59, 61, 63, 65, 58, 75, 76, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 60, 73, 
	74, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	62, 71, 72, 2, 4, 6, 8, 10, 
	12, 14, 16, 18, 20, 23, 26, 28, 
	30, 32, 34, 37, 39, 41, 43, 45, 
	47, 49, 51, 53, 55, 57, 59, 61, 
	63, 65, 64, 69, 70, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 23, 
	26, 28, 30, 32, 34, 37, 39, 41, 
	43, 45, 47, 49, 51, 53, 55, 57, 
	59, 61, 63, 65, 66, 67, 68, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 68, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 70, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 72, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 74, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 76, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 78, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 80, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 82, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 84, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 86, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 88, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 90, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 92, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 94, 2, 4, 
	6, 8, 10, 12, 14, 16, 18, 20, 
	23, 26, 28, 30, 32, 34, 37, 39, 
	41, 43, 45, 47, 49, 51, 53, 55, 
	57, 59, 61, 63, 65, 96, 97, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 99, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 101, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 103, 2, 
	4, 6, 8, 10, 12, 14, 16, 18, 
	20, 23, 26, 28, 30, 32, 34, 37, 
	39, 41, 43, 45, 47, 49, 51, 53, 
	55, 57, 59, 61, 63, 65, 105, 106, 
	107, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	109, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	111, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	113, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	115, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	117, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	119, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	121, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	123, 2, 4, 6, 8, 10, 12, 14, 
	16, 18, 20, 23, 26, 28, 30, 32, 
	34, 37, 39, 41, 43, 45, 47, 49, 
	51, 53, 55, 57, 59, 61, 63, 65, 
	125
};

static const unsigned char _trans_actions[] = {
	2, 0, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	4, 0, 5, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 4, 0, 5, 8, 8, 8, 
	8, 8, 8, 8, 8, 8, 8, 8, 
	8, 8, 8, 8, 8, 8, 8, 8, 
	8, 8, 8, 8, 8, 8, 8, 8, 
	8, 8, 8, 8, 4, 0, 5, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 4, 0, 
	5, 12, 12, 12, 12, 12, 12, 12, 
	12, 12, 12, 12, 12, 12, 12, 12, 
	12, 12, 12, 12, 12, 12, 12, 12, 
	12, 12, 12, 12, 12, 12, 12, 12, 
	4, 0, 5, 14, 14, 14, 14, 14, 
	14, 14, 14, 14, 14, 14, 14, 14, 
	14, 14, 14, 14, 14, 14, 14, 14, 
	14, 14, 14, 14, 14, 14, 14, 14, 
	14, 14, 4, 0, 5, 16, 16, 16, 
	16, 16, 16, 16, 16, 16, 16, 16, 
	16, 16, 16, 16, 16, 16, 16, 16, 
	16, 16, 16, 16, 16, 16, 16, 16, 
	16, 16, 16, 16, 4, 0, 5, 18, 
	18, 18, 18, 18, 18, 18, 18, 18, 
	18, 18, 18, 18, 18, 18, 18, 18, 
	18, 18, 18, 18, 18, 18, 18, 18, 
	18, 18, 18, 18, 18, 18, 4, 0, 
	5, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	4, 0, 5, 22, 22, 22, 22, 22, 
	22, 22, 22, 22, 22, 22, 22, 22, 
	22, 22, 22, 22, 22, 22, 22, 22, 
	22, 22, 22, 22, 22, 22, 22, 22, 
	22, 22, 0, 0, 5, 24, 24, 24, 
	24, 24, 24, 24, 24, 24, 24, 24, 
	24, 24, 24, 24, 24, 24, 24, 24, 
	24, 24, 24, 24, 24, 24, 24, 24, 
	24, 24, 24, 24, 26, 27, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 30, 30, 30, 
	30, 30, 30, 30, 30, 30, 30, 30, 
	30, 30, 30, 30, 30, 30, 30, 30, 
	30, 30, 30, 30, 30, 30, 30, 30, 
	30, 30, 30, 30, 0, 0, 5, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 26, 27, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 36, 
	36, 36, 36, 36, 36, 36, 36, 36, 
	36, 36, 36, 36, 36, 36, 36, 36, 
	36, 36, 36, 36, 36, 36, 36, 36, 
	36, 36, 36, 36, 36, 36, 4, 0, 
	5, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 
	4, 0, 5, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 4, 0, 5, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 42, 42, 42, 42, 
	42, 42, 42, 42, 4, 0, 5, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 44, 44, 
	44, 44, 44, 44, 44, 44, 0, 0, 
	5, 46, 46, 46, 46, 46, 46, 46, 
	46, 46, 46, 46, 46, 46, 46, 46, 
	46, 46, 46, 46, 46, 46, 46, 46, 
	46, 46, 46, 46, 46, 46, 46, 46, 
	26, 27, 48, 48, 48, 48, 48, 48, 
	48, 48, 48, 48, 48, 48, 48, 48, 
	48, 48, 48, 48, 48, 48, 48, 48, 
	48, 48, 48, 48, 48, 48, 48, 48, 
	48, 50, 50, 50, 50, 50, 50, 50, 
	50, 50, 50, 50, 50, 50, 50, 50, 
	50, 50, 50, 50, 50, 50, 50, 50, 
	50, 50, 50, 50, 50, 50, 50, 50, 
	4, 0, 5, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 4, 0, 5, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 4, 0, 5, 56, 
	56, 56, 56, 56, 56, 56, 56, 56, 
	56, 56, 56, 56, 56, 56, 56, 56, 
	56, 56, 56, 56, 56, 56, 56, 56, 
	56, 56, 56, 56, 56, 56, 4, 0, 
	5, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	4, 0, 5, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 4, 0, 5, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 4, 0, 5, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 4, 0, 
	5, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66, 66, 
	4, 0, 5, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 4, 0, 5, 70, 70, 70, 
	70, 70, 70, 70, 70, 70, 70, 70, 
	70, 70, 70, 70, 70, 70, 70, 70, 
	70, 70, 70, 70, 70, 70, 70, 70, 
	70, 70, 70, 70, 4, 0, 5, 72, 
	72, 72, 72, 72, 72, 72, 72, 72, 
	72, 72, 72, 72, 72, 72, 72, 72, 
	72, 72, 72, 72, 72, 72, 72, 72, 
	72, 72, 72, 72, 72, 72, 4, 0, 
	5, 74, 74, 74, 74, 74, 74, 74, 
	74, 74, 74, 74, 74, 74, 74, 74, 
	74, 74, 74, 74, 74, 74, 74, 74, 
	74, 74, 74, 74, 74, 74, 74, 74, 
	4, 0, 5, 76, 76, 76, 76, 76, 
	76, 76, 76, 76, 76, 76, 76, 76, 
	76, 76, 76, 76, 76, 76, 76, 76, 
	76, 76, 76, 76, 76, 76, 76, 76, 
	76, 76, 4, 0, 5, 78, 78, 78, 
	78, 78, 78, 78, 78, 78, 78, 78, 
	78, 78, 78, 78, 78, 78, 78, 78, 
	78, 78, 78, 78, 78, 78, 78, 78, 
	78, 78, 78, 78, 4, 0, 5, 80, 
	80, 80, 80, 80, 80, 80, 80, 80, 
	80, 80, 80, 80, 80, 80, 80, 80, 
	80, 80, 80, 80, 80, 80, 80, 80, 
	80, 80, 80, 80, 80, 80, 82, 82, 
	82, 82, 82, 82, 82, 82, 82, 82, 
	82, 82, 82, 82, 82, 82, 82, 82, 
	82, 82, 82, 82, 82, 82, 82, 82, 
	82, 82, 82, 82, 82, 83, 85, 85, 
	85, 85, 85, 85, 85, 85, 85, 85, 
	85, 85, 85, 85, 85, 85, 85, 85, 
	85, 85, 85, 85, 85, 85, 85, 85, 
	85, 85, 85, 85, 85, 83, 87, 87, 
	87, 87, 87, 87, 87, 87, 87, 87, 
	87, 87, 87, 87, 87, 87, 87, 87, 
	87, 87, 87, 87, 87, 87, 87, 87, 
	87, 87, 87, 87, 87, 83, 89, 89, 
	89, 89, 89, 89, 89, 89, 89, 89, 
	89, 89, 89, 89, 89, 89, 89, 89, 
	89, 89, 89, 89, 89, 89, 89, 89, 
	89, 89, 89, 89, 89, 83, 91, 91, 
	91, 91, 91, 91, 91, 91, 91, 91, 
	91, 91, 91, 91, 91, 91, 91, 91, 
	91, 91, 91, 91, 91, 91, 91, 91, 
	91, 91, 91, 91, 91, 83, 93, 93, 
	93, 93, 93, 93, 93, 93, 93, 93, 
	93, 93, 93, 93, 93, 93, 93, 93, 
	93, 93, 93, 93, 93, 93, 93, 93, 
	93, 93, 93, 93, 93, 83, 95, 95, 
	95, 95, 95, 95, 95, 95, 95, 95, 
	95, 95, 95, 95, 95, 95, 95, 95, 
	95, 95, 95, 95, 95, 95, 95, 95, 
	95, 95, 95, 95, 95, 83, 97, 97, 
	97, 97, 97, 97, 97, 97, 97, 97, 
	97, 97, 97, 97, 97, 97, 97, 97, 
	97, 97, 97, 97, 97, 97, 97, 97, 
	97, 97, 97, 97, 97, 83, 99, 99, 
	99, 99, 99, 99, 99, 99, 99, 99, 
	99, 99, 99, 99, 99, 99, 99, 99, 
	99, 99, 99, 99, 99, 99, 99, 99, 
	99, 99, 99, 99, 99, 83, 101, 101, 
	101, 101, 101, 101, 101, 101, 101, 101, 
	101, 101, 101, 101, 101, 101, 101, 101, 
	101, 101, 101, 101, 101, 101, 101, 101, 
	101, 101, 101, 101, 101, 83, 103, 103, 
	103, 103, 103, 103, 103, 103, 103, 103, 
	103, 103, 103, 103, 103, 103, 103, 103, 
	103, 103, 103, 103, 103, 103, 103, 103, 
	103, 103, 103, 103, 103, 83, 105, 105, 
	105, 105, 105, 105, 105, 105, 105, 105, 
	105, 105, 105, 105, 105, 105, 105, 105, 
	105, 105, 105, 105, 105, 105, 105, 105, 
	105, 105, 105, 105, 105, 83, 107, 107, 
	107, 107, 107, 107, 107, 107, 107, 107, 
	107, 107, 107, 107, 107, 107, 107, 107, 
	107, 107, 107, 107, 107, 107, 107, 107, 
	107, 107, 107, 107, 107, 83, 109, 109, 
	109, 109, 109, 109, 109, 109, 109, 109, 
	109, 109, 109, 109, 109, 109, 109, 109, 
	109, 109, 109, 109, 109, 109, 109, 109, 
	109, 109, 109, 109, 109, 83, 111, 111, 
	111, 111, 111, 111, 111, 111, 111, 111, 
	111, 111, 111, 111, 111, 111, 111, 111, 
	111, 111, 111, 111, 111, 111, 111, 111, 
	111, 111, 111, 111, 111, 83, 83, 113, 
	113, 113, 113, 113, 113, 113, 113, 113, 
	113, 113, 113, 113, 113, 113, 113, 113, 
	113, 113, 113, 113, 113, 113, 113, 113, 
	113, 113, 113, 113, 113, 113, 83, 115, 
	115, 115, 115, 115, 115, 115, 115, 115, 
	115, 115, 115, 115, 115, 115, 115, 115, 
	115, 115, 115, 115, 115, 115, 115, 115, 
	115, 115, 115, 115, 115, 115, 83, 117, 
	117, 117, 117, 117, 117, 117, 117, 117, 
	117, 117, 117, 117, 117, 117, 117, 117, 
	117, 117, 117, 117, 117, 117, 117, 117, 
	117, 117, 117, 117, 117, 117, 83, 119, 
	119, 119, 119, 119, 119, 119, 119, 119, 
	119, 119, 119, 119, 119, 119, 119, 119, 
	119, 119, 119, 119, 119, 119, 119, 119, 
	119, 119, 119, 119, 119, 119, 83, 83, 
	83, 121, 121, 121, 121, 121, 121, 121, 
	121, 121, 121, 121, 121, 121, 121, 121, 
	121, 121, 121, 121, 121, 121, 121, 121, 
	121, 121, 121, 121, 121, 121, 121, 121, 
	83, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	83, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	83, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	83, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	83, 131, 131, 131, 131, 131, 131, 131, 
	131, 131, 131, 131, 131, 131, 131, 131, 
	131, 131, 131, 131, 131, 131, 131, 131, 
	131, 131, 131, 131, 131, 131, 131, 131, 
	83, 133, 133, 133, 133, 133, 133, 133, 
	133, 133, 133, 133, 133, 133, 133, 133, 
	133, 133, 133, 133, 133, 133, 133, 133, 
	133, 133, 133, 133, 133, 133, 133, 133, 
	83, 135, 135, 135, 135, 135, 135, 135, 
	135, 135, 135, 135, 135, 135, 135, 135, 
	135, 135, 135, 135, 135, 135, 135, 135, 
	135, 135, 135, 135, 135, 135, 135, 135, 
	83, 137, 137, 137, 137, 137, 137, 137, 
	137, 137, 137, 137, 137, 137, 137, 137, 
	137, 137, 137, 137, 137, 137, 137, 137, 
	137, 137, 137, 137, 137, 137, 137, 137, 
	83
};

static const unsigned char _eof_actions[] = {
	0, 1, 3, 3, 7, 7, 9, 9, 
	11, 11, 13, 13, 15, 15, 17, 17, 
	19, 19, 21, 21, 23, 25, 29, 31, 
	33, 35, 37, 37, 39, 39, 41, 41, 
	43, 43, 45, 47, 49, 51, 51, 53, 
	53, 55, 55, 57, 57, 59, 59, 61, 
	61, 63, 63, 65, 65, 67, 67, 69, 
	69, 71, 71, 73, 73, 75, 75, 77, 
	77, 79, 79, 81, 79, 84, 77, 86, 
	75, 88, 73, 90, 71, 92, 69, 94, 
	67, 96, 65, 98, 63, 100, 61, 102, 
	59, 104, 57, 106, 55, 108, 53, 110, 
	51, 45, 112, 43, 114, 41, 116, 39, 
	118, 37, 31, 23, 120, 21, 122, 19, 
	124, 17, 126, 15, 128, 13, 130, 11, 
	132, 9, 134, 7, 136, 3
};

static const int start = 1;

static const int en_main = 1;


	{
	cs = start;
	}

	{
	int _slen;
	int _trans;
	const char *_keys;
	const short *_inds;
	if ( p == pe )
		goto _test_eof;
	if ( cs == 0 )
		goto _out;
_resume:
	_keys = _trans_keys + (cs<<1);
	_inds = _indicies + _index_offsets[cs];

	_slen = _key_spans[cs];
	_trans = _inds[ _slen > 0 && _keys[0] <=(*p) &&
		(*p) <= _keys[1] ?
		(*p) - _keys[0] : _slen ];

	cs = _trans_targs[_trans];

	if ( _trans_actions[_trans] == 0 )
		goto _again;

	switch ( _trans_actions[_trans] ) {
	case 2:
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 5:
	{
    count = (*p) - '0';
  }
	break;
	case 83:
	{
    count = count * 10 + ((*p) - '0');
  }
	break;
	case 26:
	{
    platform = true;
  }
	break;
	case 4:
	{
    pack18::non_native_error(state, *p);
  }
	break;
	case 27:
	{
    platform = true;
  }
	{
    count = (*p) - '0';
  }
	break;
	case 56:
	{
    if(rest) count = 0;

    if(count > (native_int)str.size()) {
      pack18::exceeds_length_of_string(state, count);
    }

    str.resize(str.size() - count);
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 80:
	{
    if(rest) count = 0;

    str.append(count, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 6:
	{
    if(rest) count = 1;

    if(count > (native_int)str.size()) {
      str.append(count - str.size(), '\0');
    } else {
      str.resize(count);
    }
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 107:
	{
    rest = true;
  }
	{
    if(rest) count = 0;

    if(count > (native_int)str.size()) {
      pack18::exceeds_length_of_string(state, count);
    }

    str.resize(str.size() - count);
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 82:
	{
    rest = true;
  }
	{
    if(rest) count = 0;

    str.append(count, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 137:
	{
    rest = true;
  }
	{
    if(rest) count = 1;

    if(count > (native_int)str.size()) {
      str.append(count - str.size(), '\0');
    } else {
      str.resize(count);
    }
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 12:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_byte;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 46:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 24:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 32:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(platform) {
#if RBX_SIZEOF_LONG == 4
      pack_int;
#else
      pack_long;
#endif
    } else {
      pack_int;
    }
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 72:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short_be;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 40:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int_be;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 76:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short_le;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 54:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int_le;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 44:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_long;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 42:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
#if RBX_SIZEOF_LONG == 4
    str.append("\0\0\0\0", 4);
#else
    str.append("\0\0\0\0\0\0\0\0", 8);
#endif
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 52:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_utf8
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 78:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_ber
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 14:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 16:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double_le;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 64:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float_le;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 18:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 20:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double_be;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 66:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float_be;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 131:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_byte;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 50:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 30:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 36:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(platform) {
#if RBX_SIZEOF_LONG == 4
      pack_int;
#else
      pack_long;
#endif
    } else {
      pack_int;
    }
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 91:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short_be;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 117:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int_be;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 87:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short_le;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 109:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int_le;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 113:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_long;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 115:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
#if RBX_SIZEOF_LONG == 4
    str.append("\0\0\0\0", 4);
#else
    str.append("\0\0\0\0\0\0\0\0", 8);
#endif
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 111:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_utf8
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 85:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_ber
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 129:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 127:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double_le;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 99:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float_le;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 125:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 123:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double_be;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 97:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float_be;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 48:
	{
    platform = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 28:
	{
    platform = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int;
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 34:
	{
    platform = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(platform) {
#if RBX_SIZEOF_LONG == 4
      pack_int;
#else
      pack_long;
#endif
    } else {
      pack_int;
    }
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 10:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::bit_extra(string_value, rest, count);

    pack18::bit_high(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 62:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::bit_extra(string_value, rest, count);

    pack18::bit_low(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 22:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::hex_extra(string_value, rest, count);

    pack18::hex_high(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 68:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::hex_extra(string_value, rest, count);

    pack18::hex_low(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 38:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_s");
    if(!string_value) return 0;
  }
	{
    if(rest || count < 2) count = 72;
    pack18::quotable_printable(string_value, str, count);
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 133:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::bit_extra(string_value, rest, count);

    pack18::bit_high(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 101:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::bit_extra(string_value, rest, count);

    pack18::bit_low(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 121:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::hex_extra(string_value, rest, count);

    pack18::hex_high(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 95:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::hex_extra(string_value, rest, count);

    pack18::hex_low(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 119:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_s");
    if(!string_value) return 0;
  }
	{
    if(rest || count < 2) count = 72;
    pack18::quotable_printable(string_value, str, count);
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 8:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(count > 0) str.append(count, ' ');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 60:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(count > 0) str.append(count, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 58:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(rest) {
      if(count == 0) str.append(1, '\0');
    } else {
      if(count > 0) str.append(count, '\0');
    }
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 70:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(rest || count < 3) {
      count = 45;
    } else {
      count = count / 3 * 3;
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str");
    if(!string_value) return 0;
  }
	{
    pack18::b64_uu_encode(string_value, str, count, pack18::b64_table, '=', false);
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 74:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(rest || count < 3) {
      count = 45;
    } else {
      count = count / 3 * 3;
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str");
    if(!string_value) return 0;
  }
	{
    pack18::b64_uu_encode(string_value, str, count, pack18::uu_table, '`', true);
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 135:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(count > 0) str.append(count, ' ');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 103:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(count > 0) str.append(count, '\0');
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 105:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(rest) {
      if(count == 0) str.append(1, '\0');
    } else {
      if(count > 0) str.append(count, '\0');
    }
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 93:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(rest || count < 3) {
      count = 45;
    } else {
      count = count / 3 * 3;
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str");
    if(!string_value) return 0;
  }
	{
    pack18::b64_uu_encode(string_value, str, count, pack18::b64_table, '=', false);
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	case 89:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(rest || count < 3) {
      count = 45;
    } else {
      count = count / 3 * 3;
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str");
    if(!string_value) return 0;
  }
	{
    pack18::b64_uu_encode(string_value, str, count, pack18::uu_table, '`', true);
  }
	{
    count = 1;
    rest = false;
    platform = false;
  }
	break;
	}

_again:
	if ( cs == 0 )
		goto _out;
	if ( ++p != pe )
		goto _resume;
	_test_eof: {}
	if ( p == eof )
	{
	switch ( _eof_actions[cs] ) {
	case 1:
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 55:
	{
    if(rest) count = 0;

    if(count > (native_int)str.size()) {
      pack18::exceeds_length_of_string(state, count);
    }

    str.resize(str.size() - count);
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 79:
	{
    if(rest) count = 0;

    str.append(count, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 3:
	{
    if(rest) count = 1;

    if(count > (native_int)str.size()) {
      str.append(count - str.size(), '\0');
    } else {
      str.resize(count);
    }
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 106:
	{
    rest = true;
  }
	{
    if(rest) count = 0;

    if(count > (native_int)str.size()) {
      pack18::exceeds_length_of_string(state, count);
    }

    str.resize(str.size() - count);
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 81:
	{
    rest = true;
  }
	{
    if(rest) count = 0;

    str.append(count, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 136:
	{
    rest = true;
  }
	{
    if(rest) count = 1;

    if(count > (native_int)str.size()) {
      str.append(count - str.size(), '\0');
    } else {
      str.resize(count);
    }
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 11:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_byte;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 45:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 23:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 31:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(platform) {
#if RBX_SIZEOF_LONG == 4
      pack_int;
#else
      pack_long;
#endif
    } else {
      pack_int;
    }
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 71:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short_be;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 39:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int_be;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 75:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short_le;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 53:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int_le;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 43:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_long;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 41:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
#if RBX_SIZEOF_LONG == 4
    str.append("\0\0\0\0", 4);
#else
    str.append("\0\0\0\0\0\0\0\0", 8);
#endif
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 51:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_utf8
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 77:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_ber
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 13:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 15:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double_le;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 63:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float_le;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 17:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 19:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double_be;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 65:
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float_be;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 130:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_byte;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 49:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 29:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 35:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(platform) {
#if RBX_SIZEOF_LONG == 4
      pack_int;
#else
      pack_long;
#endif
    } else {
      pack_int;
    }
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 90:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short_be;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 116:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int_be;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 86:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short_le;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 108:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int_le;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 112:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_long;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 114:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
#if RBX_SIZEOF_LONG == 4
    str.append("\0\0\0\0", 4);
#else
    str.append("\0\0\0\0\0\0\0\0", 8);
#endif
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 110:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_utf8
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 84:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_ber
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 128:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 126:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double_le;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 98:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float_le;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 124:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 122:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_double_be;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 96:
	{
    rest = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_float_be;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 47:
	{
    platform = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_short;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 25:
	{
    platform = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    pack_int;
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 33:
	{
    platform = true;
  }
	{
    stop = rest ? array_size : index + count;
    if(stop > array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(platform) {
#if RBX_SIZEOF_LONG == 4
      pack_int;
#else
      pack_long;
#endif
    } else {
      pack_int;
    }
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 9:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::bit_extra(string_value, rest, count);

    pack18::bit_high(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 61:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::bit_extra(string_value, rest, count);

    pack18::bit_low(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 21:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::hex_extra(string_value, rest, count);

    pack18::hex_high(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 67:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::hex_extra(string_value, rest, count);

    pack18::hex_low(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 37:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_s");
    if(!string_value) return 0;
  }
	{
    if(rest || count < 2) count = 72;
    pack18::quotable_printable(string_value, str, count);
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 132:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::bit_extra(string_value, rest, count);

    pack18::bit_high(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 100:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::bit_extra(string_value, rest, count);

    pack18::bit_low(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 120:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::hex_extra(string_value, rest, count);

    pack18::hex_high(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 94:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    native_int extra = pack18::hex_extra(string_value, rest, count);

    pack18::hex_low(string_value, str, count);
    if(extra > 0) str.append(extra, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 118:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_s");
    if(!string_value) return 0;
  }
	{
    if(rest || count < 2) count = 72;
    pack18::quotable_printable(string_value, str, count);
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 7:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(count > 0) str.append(count, ' ');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 59:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(count > 0) str.append(count, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 57:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(rest) {
      if(count == 0) str.append(1, '\0');
    } else {
      if(count > 0) str.append(count, '\0');
    }
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 69:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(rest || count < 3) {
      count = 45;
    } else {
      count = count / 3 * 3;
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str");
    if(!string_value) return 0;
  }
	{
    pack18::b64_uu_encode(string_value, str, count, pack18::b64_table, '=', false);
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 73:
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(rest || count < 3) {
      count = 45;
    } else {
      count = count / 3 * 3;
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str");
    if(!string_value) return 0;
  }
	{
    pack18::b64_uu_encode(string_value, str, count, pack18::uu_table, '`', true);
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 134:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(count > 0) str.append(count, ' ');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 102:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(count > 0) str.append(count, '\0');
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 104:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str_or_nil");
    if(!string_value) return 0;
  }
	{
    if(CBOOL(string_value->tainted_p(state))) tainted = true;
    native_int size = string_value->byte_size();
    if(rest) count = size;
    if(count <= size) {
      str.append((const char*)string_value->byte_address(), count);
      count = 0;
    } else {
      str.append((const char*)string_value->byte_address(), size);
      count = count - size;
    }
  }
	{
    if(rest) {
      if(count == 0) str.append(1, '\0');
    } else {
      if(count > 0) str.append(count, '\0');
    }
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 92:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(rest || count < 3) {
      count = 45;
    } else {
      count = count / 3 * 3;
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str");
    if(!string_value) return 0;
  }
	{
    pack18::b64_uu_encode(string_value, str, count, pack18::b64_table, '=', false);
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	case 88:
	{
    rest = true;
  }
	{
    if(index >= array_size) {
      Exception::argument_error(state, "too few arguments");
    }
  }
	{
    if(rest || count < 3) {
      count = 45;
    } else {
      count = count / 3 * 3;
    }
  }
	{
    string_value = pack18::encoding_string(state, call_frame,
        self->get(state, index++), "to_str");
    if(!string_value) return 0;
  }
	{
    pack18::b64_uu_encode(string_value, str, count, pack18::uu_table, '`', true);
  }
	{
    String* result = String::create(state, str.c_str(), str.size());
    if(tainted) {
      result->taint(state);
      tainted = false;
    }
    return result;
  }
	break;
	}
	}

	_out: {}
	}



    if(en_main) {
      // do nothing
    }

    return force_as<String>(Primitives::failure());
  }
}
